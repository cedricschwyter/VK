VUID_NAME,CHECKED,TEST,TYPE,API/STRUCT,EXTENSION,VUID_TEXT
VUID-VkAccelerationStructureCreateInfoNVX-flags-parameter,Y,None,implicit,VkAccelerationStructureCreateInfoNVX,(VK_NVX_raytracing), flags must be a valid combination of VkBuildAccelerationStructureFlagBitsNVX values
VUID-VkAccelerationStructureCreateInfoNVX-geometryCount-02239,N,None,explicit,VkAccelerationStructureCreateInfoNVX,(VK_NVX_raytracing), geometryCount must be less than or equal to VkPhysicalDeviceRaytracingPropertiesNVX::maxGeometryCount
VUID-VkAccelerationStructureCreateInfoNVX-pGeometries-parameter,Y,None,implicit,VkAccelerationStructureCreateInfoNVX,(VK_NVX_raytracing)," If geometryCount is not 0, pGeometries must be a valid pointer to an array of geometryCount valid VkGeometryNVX structures"
VUID-VkAccelerationStructureCreateInfoNVX-pNext-pNext,Y,None,implicit,VkAccelerationStructureCreateInfoNVX,(VK_NVX_raytracing), pNext must be NULL
VUID-VkAccelerationStructureCreateInfoNVX-sType-sType,Y,None,implicit,VkAccelerationStructureCreateInfoNVX,(VK_NVX_raytracing), sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NVX
VUID-VkAccelerationStructureCreateInfoNVX-type-parameter,Y,None,implicit,VkAccelerationStructureCreateInfoNVX,(VK_NVX_raytracing), type must be a valid VkAccelerationStructureTypeNVX value
VUID-VkAccelerationStructureMemoryRequirementsInfoNVX-accelerationStructure-parameter,Y,None,implicit,VkAccelerationStructureMemoryRequirementsInfoNVX,(VK_NVX_raytracing), accelerationStructure must be a valid VkAccelerationStructureNVX handle
VUID-VkAccelerationStructureMemoryRequirementsInfoNVX-pNext-pNext,Y,None,implicit,VkAccelerationStructureMemoryRequirementsInfoNVX,(VK_NVX_raytracing), pNext must be NULL
VUID-VkAccelerationStructureMemoryRequirementsInfoNVX-sType-sType,Y,None,implicit,VkAccelerationStructureMemoryRequirementsInfoNVX,(VK_NVX_raytracing), sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NVX
VUID-VkAcquireNextImageInfoKHR-commonparent,Y,None,implicit,VkAcquireNextImageInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)"," Each of fence, semaphore, and swapchain that are valid handles must have been created, allocated, or retrieved from the same VkInstance"
VUID-VkAcquireNextImageInfoKHR-deviceMask-01290,N,None,explicit,VkAcquireNextImageInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", deviceMask must be a valid device mask
VUID-VkAcquireNextImageInfoKHR-deviceMask-01291,N,None,explicit,VkAcquireNextImageInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", deviceMask must not be zero
VUID-VkAcquireNextImageInfoKHR-fence-01289,N,None,explicit,VkAcquireNextImageInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", If fence is not VK_NULL_HANDLE it must be unsignaled and must not be associated with any other queue command that has not yet completed execution on that queue
VUID-VkAcquireNextImageInfoKHR-fence-parameter,Y,None,implicit,VkAcquireNextImageInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)"," If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle"
VUID-VkAcquireNextImageInfoKHR-pNext-pNext,Y,None,implicit,VkAcquireNextImageInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", pNext must be NULL
VUID-VkAcquireNextImageInfoKHR-sType-sType,Y,None,implicit,VkAcquireNextImageInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", sType must be VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR
VUID-VkAcquireNextImageInfoKHR-semaphore-01288,N,None,explicit,VkAcquireNextImageInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", If semaphore is not VK_NULL_HANDLE it must be unsignaled
VUID-VkAcquireNextImageInfoKHR-semaphore-01781,N,None,explicit,VkAcquireNextImageInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", If semaphore is not VK_NULL_HANDLE it must not have any uncompleted signal or wait operations pending
VUID-VkAcquireNextImageInfoKHR-semaphore-01782,N,None,explicit,VkAcquireNextImageInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", semaphore and fence must not both be equal to VK_NULL_HANDLE
VUID-VkAcquireNextImageInfoKHR-semaphore-01804,N,None,explicit,VkAcquireNextImageInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", semaphore and fence must not both be equal to VK_NULL_HANDLE.
VUID-VkAcquireNextImageInfoKHR-semaphore-parameter,Y,None,implicit,VkAcquireNextImageInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)"," If semaphore is not VK_NULL_HANDLE, semaphore must be a valid VkSemaphore handle"
VUID-VkAcquireNextImageInfoKHR-swapchain-01675,N,None,explicit,VkAcquireNextImageInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", swapchain must not be in the retired state
VUID-VkAcquireNextImageInfoKHR-swapchain-parameter,Y,None,implicit,VkAcquireNextImageInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", swapchain must be a valid VkSwapchainKHR handle
VUID-VkAllocationCallbacks-pfnAllocation-00632,Y,None,explicit,VkAllocationCallbacks,core, pfnAllocation must be a valid pointer to a valid user-defined PFN_vkAllocationFunction
VUID-VkAllocationCallbacks-pfnFree-00634,Y,None,explicit,VkAllocationCallbacks,core, pfnFree must be a valid pointer to a valid user-defined PFN_vkFreeFunction
VUID-VkAllocationCallbacks-pfnInternalAllocation-00635,N,None,explicit,VkAllocationCallbacks,core," If either of pfnInternalAllocation or pfnInternalFree is not NULL, both must be valid callbacks"
VUID-VkAllocationCallbacks-pfnReallocation-00633,Y,None,explicit,VkAllocationCallbacks,core, pfnReallocation must be a valid pointer to a valid user-defined PFN_vkReallocationFunction
VUID-VkAndroidHardwareBufferFormatPropertiesANDROID-sType-sType,N,None,implicit,VkAndroidHardwareBufferFormatPropertiesANDROID,(VK_ANDROID_external_memory_android_hardware_buffer), sType must be VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID
VUID-VkAndroidHardwareBufferUsageANDROID-sType-sType,N,None,implicit,VkAndroidHardwareBufferUsageANDROID,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_ANDROID_external_memory_android_hardware_buffer)", sType must be VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID
VUID-VkAndroidSurfaceCreateInfoKHR-flags-zerobitmask,Y,None,implicit,VkAndroidSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_android_surface), flags must be 0
VUID-VkAndroidSurfaceCreateInfoKHR-pNext-pNext,Y,None,implicit,VkAndroidSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_android_surface), pNext must be NULL
VUID-VkAndroidSurfaceCreateInfoKHR-sType-sType,Y,None,implicit,VkAndroidSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_android_surface), sType must be VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR
VUID-VkAndroidSurfaceCreateInfoKHR-window-01248,N,None,explicit,VkAndroidSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_android_surface), window must point to a valid Android ANativeWindow.
VUID-VkApplicationInfo-pApplicationName-parameter,Y,None,implicit,VkApplicationInfo,core," If pApplicationName is not NULL, pApplicationName must be a null-terminated UTF-8 string"
VUID-VkApplicationInfo-pEngineName-parameter,Y,None,implicit,VkApplicationInfo,core," If pEngineName is not NULL, pEngineName must be a null-terminated UTF-8 string"
VUID-VkApplicationInfo-pNext-pNext,Y,None,implicit,VkApplicationInfo,core, pNext must be NULL
VUID-VkApplicationInfo-sType-sType,Y,None,implicit,VkApplicationInfo,core, sType must be VK_STRUCTURE_TYPE_APPLICATION_INFO
VUID-VkAttachmentDescription-finalLayout-00843,Y,AttachmentDescriptionInvalidFinalLayout,explicit,VkAttachmentDescription,core, finalLayout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED
VUID-VkAttachmentDescription-finalLayout-parameter,Y,None,implicit,VkAttachmentDescription,core, finalLayout must be a valid VkImageLayout value
VUID-VkAttachmentDescription-flags-parameter,Y,None,implicit,VkAttachmentDescription,core, flags must be a valid combination of VkAttachmentDescriptionFlagBits values
VUID-VkAttachmentDescription-format-parameter,Y,None,implicit,VkAttachmentDescription,core, format must be a valid VkFormat value
VUID-VkAttachmentDescription-initialLayout-parameter,Y,None,implicit,VkAttachmentDescription,core, initialLayout must be a valid VkImageLayout value
VUID-VkAttachmentDescription-loadOp-parameter,Y,None,implicit,VkAttachmentDescription,core, loadOp must be a valid VkAttachmentLoadOp value
VUID-VkAttachmentDescription-samples-parameter,Y,CreateRenderPassAttachments,implicit,VkAttachmentDescription,core, samples must be a valid VkSampleCountFlagBits value
VUID-VkAttachmentDescription-stencilLoadOp-parameter,Y,None,implicit,VkAttachmentDescription,core, stencilLoadOp must be a valid VkAttachmentLoadOp value
VUID-VkAttachmentDescription-stencilStoreOp-parameter,Y,None,implicit,VkAttachmentDescription,core, stencilStoreOp must be a valid VkAttachmentStoreOp value
VUID-VkAttachmentDescription-storeOp-parameter,Y,None,implicit,VkAttachmentDescription,core, storeOp must be a valid VkAttachmentStoreOp value
VUID-VkAttachmentDescription2KHR-finalLayout-03061,N,None,explicit,VkAttachmentDescription2KHR,(VK_KHR_create_renderpass2), finalLayout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED
VUID-VkAttachmentDescription2KHR-finalLayout-parameter,Y,None,implicit,VkAttachmentDescription2KHR,(VK_KHR_create_renderpass2), finalLayout must be a valid VkImageLayout value
VUID-VkAttachmentDescription2KHR-flags-parameter,Y,None,implicit,VkAttachmentDescription2KHR,(VK_KHR_create_renderpass2), flags must be a valid combination of VkAttachmentDescriptionFlagBits values
VUID-VkAttachmentDescription2KHR-format-parameter,Y,None,implicit,VkAttachmentDescription2KHR,(VK_KHR_create_renderpass2), format must be a valid VkFormat value
VUID-VkAttachmentDescription2KHR-initialLayout-parameter,Y,None,implicit,VkAttachmentDescription2KHR,(VK_KHR_create_renderpass2), initialLayout must be a valid VkImageLayout value
VUID-VkAttachmentDescription2KHR-loadOp-parameter,Y,None,implicit,VkAttachmentDescription2KHR,(VK_KHR_create_renderpass2), loadOp must be a valid VkAttachmentLoadOp value
VUID-VkAttachmentDescription2KHR-sType-sType,Y,None,implicit,VkAttachmentDescription2KHR,(VK_KHR_create_renderpass2), sType must be VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR
VUID-VkAttachmentDescription2KHR-samples-parameter,Y,None,implicit,VkAttachmentDescription2KHR,(VK_KHR_create_renderpass2), samples must be a valid VkSampleCountFlagBits value
VUID-VkAttachmentDescription2KHR-stencilLoadOp-parameter,Y,None,implicit,VkAttachmentDescription2KHR,(VK_KHR_create_renderpass2), stencilLoadOp must be a valid VkAttachmentLoadOp value
VUID-VkAttachmentDescription2KHR-stencilStoreOp-parameter,Y,None,implicit,VkAttachmentDescription2KHR,(VK_KHR_create_renderpass2), stencilStoreOp must be a valid VkAttachmentStoreOp value
VUID-VkAttachmentDescription2KHR-storeOp-parameter,Y,None,implicit,VkAttachmentDescription2KHR,(VK_KHR_create_renderpass2), storeOp must be a valid VkAttachmentStoreOp value
VUID-VkAttachmentReference-layout-00857,N,None,explicit,VkAttachmentReference,core, layout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED
VUID-VkAttachmentReference-layout-parameter,Y,None,implicit,VkAttachmentReference,core, layout must be a valid VkImageLayout value
VUID-VkAttachmentReference2KHR-layout-03077,N,None,explicit,VkAttachmentReference2KHR,(VK_KHR_create_renderpass2), layout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED
VUID-VkAttachmentReference2KHR-layout-parameter,Y,None,implicit,VkAttachmentReference2KHR,(VK_KHR_create_renderpass2), layout must be a valid VkImageLayout value
VUID-VkAttachmentReference2KHR-sType-sType,Y,None,implicit,VkAttachmentReference2KHR,(VK_KHR_create_renderpass2), sType must be VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR
VUID-VkAttachmentSampleLocationsEXT-attachmentIndex-01531,N,None,explicit,VkAttachmentSampleLocationsEXT,(VK_EXT_sample_locations), attachmentIndex must be less than the attachmentCount specified in VkRenderPassCreateInfo the render pass specified by VkRenderPassBeginInfo::renderPass was created with
VUID-VkAttachmentSampleLocationsEXT-sampleLocationsInfo-parameter,N,None,implicit,VkAttachmentSampleLocationsEXT,(VK_EXT_sample_locations), sampleLocationsInfo must be a valid VkSampleLocationsInfoEXT structure
VUID-VkBindAccelerationStructureMemoryInfoNVX-accelerationStructure-parameter,Y,None,implicit,VkBindAccelerationStructureMemoryInfoNVX,(VK_NVX_raytracing), accelerationStructure must be a valid VkAccelerationStructureNVX handle
VUID-VkBindAccelerationStructureMemoryInfoNVX-commonparent,Y,None,implicit,VkBindAccelerationStructureMemoryInfoNVX,(VK_NVX_raytracing)," Both of accelerationStructure, and memory must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkBindAccelerationStructureMemoryInfoNVX-memory-parameter,Y,None,implicit,VkBindAccelerationStructureMemoryInfoNVX,(VK_NVX_raytracing), memory must be a valid VkDeviceMemory handle
VUID-VkBindAccelerationStructureMemoryInfoNVX-pDeviceIndices-parameter,Y,None,implicit,VkBindAccelerationStructureMemoryInfoNVX,(VK_NVX_raytracing)," If deviceIndexCount is not 0, pDeviceIndices must be a valid pointer to an array of deviceIndexCount uint32_t values"
VUID-VkBindAccelerationStructureMemoryInfoNVX-pNext-pNext,Y,None,implicit,VkBindAccelerationStructureMemoryInfoNVX,(VK_NVX_raytracing), pNext must be NULL
VUID-VkBindAccelerationStructureMemoryInfoNVX-sType-sType,Y,None,implicit,VkBindAccelerationStructureMemoryInfoNVX,(VK_NVX_raytracing), sType must be VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NVX
VUID-VkBindBufferMemoryDeviceGroupInfo-deviceIndexCount-01606,N,None,explicit,VkBindBufferMemoryDeviceGroupInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)", deviceIndexCount must either be zero or equal to the number of physical devices in the logical device
VUID-VkBindBufferMemoryDeviceGroupInfo-pDeviceIndices-01607,N,None,explicit,VkBindBufferMemoryDeviceGroupInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)", All elements of pDeviceIndices must be valid device indices
VUID-VkBindBufferMemoryDeviceGroupInfo-pDeviceIndices-parameter,Y,None,implicit,VkBindBufferMemoryDeviceGroupInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)"," If deviceIndexCount is not 0, pDeviceIndices must be a valid pointer to an array of deviceIndexCount uint32_t values"
VUID-VkBindBufferMemoryDeviceGroupInfo-sType-sType,N,None,implicit,VkBindBufferMemoryDeviceGroupInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)", sType must be VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO
VUID-VkBindBufferMemoryInfo-buffer-01593,N,None,explicit,VkBindBufferMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", buffer must not already be backed by a memory object
VUID-VkBindBufferMemoryInfo-buffer-01594,N,None,explicit,VkBindBufferMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", buffer must not have been created with any sparse memory binding flags
VUID-VkBindBufferMemoryInfo-buffer-01602,N,None,explicit,VkBindBufferMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_dedicated_allocation)"," If buffer requires a dedicated allocation(as reported by vkGetBufferMemoryRequirements2 in VkMemoryDedicatedRequirements::requiresDedicatedAllocation for buffer), memory must have been created with VkMemoryDedicatedAllocateInfo::buffer equal to buffer and memoryOffset must be zero"
VUID-VkBindBufferMemoryInfo-buffer-01603,N,None,explicit,VkBindBufferMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_NV_dedicated_allocation)"," If buffer was created with VkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must have been created with VkDedicatedAllocationMemoryAllocateInfoNV::buffer equal to buffer and memoryOffset must be zero"
VUID-VkBindBufferMemoryInfo-buffer-01604,N,None,explicit,VkBindBufferMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_NV_dedicated_allocation)+!(VK_VERSION_1_1,VK_KHR_dedicated_allocation)"," If buffer was not created with VkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must not have been allocated dedicated for a specific buffer or image"
VUID-VkBindBufferMemoryInfo-buffer-parameter,Y,None,implicit,VkBindBufferMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", buffer must be a valid VkBuffer handle
VUID-VkBindBufferMemoryInfo-commonparent,Y,None,implicit,VkBindBufferMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)"," Both of buffer, and memory must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkBindBufferMemoryInfo-memory-01599,N,None,explicit,VkBindBufferMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer
VUID-VkBindBufferMemoryInfo-memory-01900,N,None,explicit,VkBindBufferMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_dedicated_allocation)"," If the VkMemoryAllocateInfo provided when memory was allocated included an instance of VkMemoryDedicatedAllocateInfo in its pNext chain, and VkMemoryDedicatedAllocateInfo::buffer was not VK_NULL_HANDLE, then buffer must equal VkMemoryDedicatedAllocateInfo::buffer and memoryOffset must be zero."
VUID-VkBindBufferMemoryInfo-memory-parameter,Y,None,implicit,VkBindBufferMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", memory must be a valid VkDeviceMemory handle
VUID-VkBindBufferMemoryInfo-memoryOffset-01595,N,None,explicit,VkBindBufferMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", memoryOffset must be less than the size of memory
VUID-VkBindBufferMemoryInfo-memoryOffset-01600,N,None,explicit,VkBindBufferMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer
VUID-VkBindBufferMemoryInfo-pNext-01605,N,None,explicit,VkBindBufferMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)"," If the pNext chain includes VkBindBufferMemoryDeviceGroupInfo, all instances of memory specified by VkBindBufferMemoryDeviceGroupInfo::pDeviceIndices must have been allocated"
VUID-VkBindBufferMemoryInfo-pNext-pNext,Y,None,implicit,VkBindBufferMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", pNext must be NULL or a pointer to a valid instance of VkBindBufferMemoryDeviceGroupInfo
VUID-VkBindBufferMemoryInfo-sType-sType,Y,None,implicit,VkBindBufferMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", sType must be VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO
VUID-VkBindBufferMemoryInfo-size-01601,N,None,explicit,VkBindBufferMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", The size member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer must be less than or equal to the size of memory minus memoryOffset
VUID-VkBindImageMemoryDeviceGroupInfo-deviceIndexCount-01633,N,None,explicit,VkBindImageMemoryDeviceGroupInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)", At least one of deviceIndexCount and splitInstanceBindRegionCount must be zero.
VUID-VkBindImageMemoryDeviceGroupInfo-deviceIndexCount-01634,N,None,explicit,VkBindImageMemoryDeviceGroupInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)", deviceIndexCount must either be zero or equal to the number of physical devices in the logical device
VUID-VkBindImageMemoryDeviceGroupInfo-extent-01640,N,None,explicit,VkBindImageMemoryDeviceGroupInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)"," The extent.width member of any element of pSplitInstanceBindRegions must either be a multiple of the sparse image block width of all non-metadata aspects of the image, or else extent.width + offset.x must equal the width of the image subresource"
VUID-VkBindImageMemoryDeviceGroupInfo-extent-01641,N,None,explicit,VkBindImageMemoryDeviceGroupInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)"," The extent.height member of any element of pSplitInstanceBindRegions must either be a multiple of the sparse image block height of all non-metadata aspects of the image, or else extent.height offset.y must equal the width of the image subresource"
VUID-VkBindImageMemoryDeviceGroupInfo-offset-01638,N,None,explicit,VkBindImageMemoryDeviceGroupInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)", The offset.x member of any element of pSplitInstanceBindRegions must be a multiple of the sparse image block width (VkSparseImageFormatProperties::imageGranularity.width) of all non-metadata aspects of the image
VUID-VkBindImageMemoryDeviceGroupInfo-offset-01639,N,None,explicit,VkBindImageMemoryDeviceGroupInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)", The offset.y member of any element of pSplitInstanceBindRegions must be a multiple of the sparse image block height (VkSparseImageFormatProperties::imageGranularity.height) of all non-metadata aspects of the image
VUID-VkBindImageMemoryDeviceGroupInfo-pDeviceIndices-01635,N,None,explicit,VkBindImageMemoryDeviceGroupInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)", All elements of pDeviceIndices must be valid device indices.
VUID-VkBindImageMemoryDeviceGroupInfo-pDeviceIndices-parameter,Y,None,implicit,VkBindImageMemoryDeviceGroupInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)"," If deviceIndexCount is not 0, pDeviceIndices must be a valid pointer to an array of deviceIndexCount uint32_t values"
VUID-VkBindImageMemoryDeviceGroupInfo-pSplitInstanceBindRegions-01637,N,None,explicit,VkBindImageMemoryDeviceGroupInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)", Elements of pSplitInstanceBindRegions that correspond to the same instance of an image must not overlap.
VUID-VkBindImageMemoryDeviceGroupInfo-pSplitInstanceBindRegions-parameter,Y,None,implicit,VkBindImageMemoryDeviceGroupInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)"," If splitInstanceBindRegionCount is not 0, pSplitInstanceBindRegions must be a valid pointer to an array of splitInstanceBindRegionCount VkRect2D structures"
VUID-VkBindImageMemoryDeviceGroupInfo-sType-sType,N,None,implicit,VkBindImageMemoryDeviceGroupInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)", sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO
VUID-VkBindImageMemoryDeviceGroupInfo-splitInstanceBindRegionCount-01636,N,None,explicit,VkBindImageMemoryDeviceGroupInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)", splitInstanceBindRegionCount must either be zero or equal to the number of physical devices in the logical device squared
VUID-VkBindImageMemoryInfo-commonparent,Y,None,implicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)"," Both of image, and memory that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkBindImageMemoryInfo-image-01609,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", image must not already be backed by a memory object
VUID-VkBindImageMemoryInfo-image-01610,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", image must not have been created with any sparse memory binding flags
VUID-VkBindImageMemoryInfo-image-01622,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_dedicated_allocation)"," If image requires a dedicated allocation (as reported by vkGetImageMemoryRequirements2 in VkMemoryDedicatedRequirements::requiresDedicatedAllocation for image), memory must have been created with VkMemoryDedicatedAllocateInfo::image equal to image and memoryOffset must be zero"
VUID-VkBindImageMemoryInfo-image-01623,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_NV_dedicated_allocation)"," If image was created with VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must have been created with VkDedicatedAllocationMemoryAllocateInfoNV::image equal to image and memoryOffset must be zero"
VUID-VkBindImageMemoryInfo-image-01624,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_NV_dedicated_allocation)+!(VK_VERSION_1_1,VK_KHR_dedicated_allocation)"," If image was not created with VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must not have been allocated dedicated for a specific buffer or image"
VUID-VkBindImageMemoryInfo-image-01630,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)+(VK_KHR_swapchain)"," If image was created with a valid swapchain handle in VkImageSwapchainCreateInfoKHR::swapchain, then the pNext chain must include a valid instance of VkBindImageMemorySwapchainInfoKHR"
VUID-VkBindImageMemoryInfo-image-parameter,Y,None,implicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", image must be a valid VkImage handle
VUID-VkBindImageMemoryInfo-memory-01612,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with image
VUID-VkBindImageMemoryInfo-memory-01614,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", The difference of the size of memory and memoryOffset must be greater than or equal to the size member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with the same image
VUID-VkBindImageMemoryInfo-memory-01625,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+!(VK_VERSION_1_1+VK_KHR_swapchain)+!(VK_KHR_device_group+VK_KHR_swapchain)", memory must be a valid VkDeviceMemory handle
VUID-VkBindImageMemoryInfo-memory-01903,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_dedicated_allocation)"," If the VkMemoryAllocateInfo provided when memory was allocated included an instance of VkMemoryDedicatedAllocateInfo in its pNext chain, and VkMemoryDedicatedAllocateInfo::image was not VK_NULL_HANDLE, then image must equal VkMemoryDedicatedAllocateInfo::image and memoryOffset must be zero."
VUID-VkBindImageMemoryInfo-memoryOffset-01611,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", memoryOffset must be less than the size of memory
VUID-VkBindImageMemoryInfo-memoryOffset-01613,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with image
VUID-VkBindImageMemoryInfo-pNext-01615,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the pNext chain does not include an instance of the VkBindImagePlaneMemoryInfo structure, memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with image"
VUID-VkBindImageMemoryInfo-pNext-01616,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the pNext chain does not include an instance of the VkBindImagePlaneMemoryInfo structure, memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with image"
VUID-VkBindImageMemoryInfo-pNext-01617,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the pNext chain does not include an instance of the VkBindImagePlaneMemoryInfo structure, the difference of the size of memory and memoryOffset must be greater than or equal to the size member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with the same image"
VUID-VkBindImageMemoryInfo-pNext-01618,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the pNext chain includes an instance of the VkBindImagePlaneMemoryInfo structure, image must have been created with the VK_IMAGE_CREATE_DISJOINT_BIT bit set."
VUID-VkBindImageMemoryInfo-pNext-01619,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the pNext chain includes an instance of the VkBindImagePlaneMemoryInfo structure, memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with image and the correct planeAspect for this plane in the VkImagePlaneMemoryRequirementsInfo structure attached to the VkImageMemoryRequirementsInfo2's pNext chain"
VUID-VkBindImageMemoryInfo-pNext-01620,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the pNext chain includes an instance of the VkBindImagePlaneMemoryInfo structure, memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with image and the correct planeAspect for this plane in the VkImagePlaneMemoryRequirementsInfo structure attached to the VkImageMemoryRequirementsInfo2's pNext chain"
VUID-VkBindImageMemoryInfo-pNext-01621,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the pNext chain includes an instance of the VkBindImagePlaneMemoryInfo structure, the difference of the size of memory and memoryOffset must be greater than or equal to the size member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with the same image and the correct planeAspect for this plane in the VkImagePlaneMemoryRequirementsInfo structure attached to the VkImageMemoryRequirementsInfo2's pNext chain"
VUID-VkBindImageMemoryInfo-pNext-01626,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)"," If the pNext chain includes VkBindImageMemoryDeviceGroupInfo, all instances of memory specified by VkBindImageMemoryDeviceGroupInfo::pDeviceIndices must have been allocated"
VUID-VkBindImageMemoryInfo-pNext-01627,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)"," If the pNext chain includes VkBindImageMemoryDeviceGroupInfo, and VkBindImageMemoryDeviceGroupInfo::splitInstanceBindRegionCount is not zero, then image must have been created with the VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT bit set"
VUID-VkBindImageMemoryInfo-pNext-01628,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)"," If the pNext chain includes VkBindImageMemoryDeviceGroupInfo, all elements of VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions must be valid rectangles contained within the dimensions of image"
VUID-VkBindImageMemoryInfo-pNext-01629,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)"," If the pNext chain includes VkBindImageMemoryDeviceGroupInfo, the union of the areas of all elements of VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions that correspond to the same instance of image must cover the entire image."
VUID-VkBindImageMemoryInfo-pNext-01631,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)+(VK_KHR_swapchain)"," If the pNext chain includes an instance of VkBindImageMemorySwapchainInfoKHR, memory must be VK_NULL_HANDLE"
VUID-VkBindImageMemoryInfo-pNext-01632,N,None,explicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)+(VK_KHR_swapchain)"," If the pNext chain does not include an instance of VkBindImageMemorySwapchainInfoKHR, memory must be a valid VkDeviceMemory handle"
VUID-VkBindImageMemoryInfo-pNext-pNext,Y,None,implicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)"," Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkBindImageMemoryDeviceGroupInfo, VkBindImageMemorySwapchainInfoKHR, or VkBindImagePlaneMemoryInfo"
VUID-VkBindImageMemoryInfo-sType-sType,Y,None,implicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO
VUID-VkBindImageMemoryInfo-sType-unique,N,None,implicit,VkBindImageMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", Each sType member in the pNext chain must be unique
VUID-VkBindImageMemorySwapchainInfoKHR-imageIndex-01644,N,None,explicit,VkBindImageMemorySwapchainInfoKHR,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)+(VK_KHR_swapchain)", imageIndex must be less than the number of images in swapchain
VUID-VkBindImageMemorySwapchainInfoKHR-sType-sType,N,None,implicit,VkBindImageMemorySwapchainInfoKHR,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)+(VK_KHR_swapchain)", sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR
VUID-VkBindImageMemorySwapchainInfoKHR-swapchain-parameter,N,None,implicit,VkBindImageMemorySwapchainInfoKHR,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_device_group)+(VK_KHR_swapchain)", swapchain must be a valid VkSwapchainKHR handle
VUID-VkBindImagePlaneMemoryInfo-None-01643,N,None,explicit,VkBindImagePlaneMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," A single call to vkBindImageMemory2 must bind all or none of the planes of an image (i.e. bindings to all planes of an image must be made in a single vkBindImageMemory2 call), as separate bindings"
VUID-VkBindImagePlaneMemoryInfo-planeAspect-01642,N,None,explicit,VkBindImagePlaneMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," planeAspect must be a single valid plane aspect for the image format (that is, planeAspect must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT for '_2PLANE' formats and planeAspect must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT for '_3PLANE' formats)"
VUID-VkBindImagePlaneMemoryInfo-planeAspect-parameter,Y,None,implicit,VkBindImagePlaneMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", planeAspect must be a valid VkImageAspectFlagBits value
VUID-VkBindImagePlaneMemoryInfo-sType-sType,N,None,implicit,VkBindImagePlaneMemoryInfo,"(VK_VERSION_1_1,VK_KHR_bind_memory2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO
VUID-VkBindSparseInfo-commonparent,Y,None,implicit,VkBindSparseInfo,core," Both of the elements of pSignalSemaphores, and the elements of pWaitSemaphores that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkBindSparseInfo-pBufferBinds-parameter,Y,None,implicit,VkBindSparseInfo,core," If bufferBindCount is not 0, pBufferBinds must be a valid pointer to an array of bufferBindCount valid VkSparseBufferMemoryBindInfo structures"
VUID-VkBindSparseInfo-pImageBinds-parameter,Y,None,implicit,VkBindSparseInfo,core," If imageBindCount is not 0, pImageBinds must be a valid pointer to an array of imageBindCount valid VkSparseImageMemoryBindInfo structures"
VUID-VkBindSparseInfo-pImageOpaqueBinds-parameter,Y,None,implicit,VkBindSparseInfo,core," If imageOpaqueBindCount is not 0, pImageOpaqueBinds must be a valid pointer to an array of imageOpaqueBindCount valid VkSparseImageOpaqueMemoryBindInfo structures"
VUID-VkBindSparseInfo-pNext-pNext,Y,None,implicit,VkBindSparseInfo,core, pNext must be NULL or a pointer to a valid instance of VkDeviceGroupBindSparseInfo
VUID-VkBindSparseInfo-pSignalSemaphores-parameter,Y,None,implicit,VkBindSparseInfo,core," If signalSemaphoreCount is not 0, pSignalSemaphores must be a valid pointer to an array of signalSemaphoreCount valid VkSemaphore handles"
VUID-VkBindSparseInfo-pWaitSemaphores-parameter,Y,None,implicit,VkBindSparseInfo,core," If waitSemaphoreCount is not 0, pWaitSemaphores must be a valid pointer to an array of waitSemaphoreCount valid VkSemaphore handles"
VUID-VkBindSparseInfo-sType-sType,Y,None,implicit,VkBindSparseInfo,core, sType must be VK_STRUCTURE_TYPE_BIND_SPARSE_INFO
VUID-VkBufferCopy-size-01988,N,None,explicit,VkBufferCopy,core, The size must be greater than 0
VUID-VkBufferCreateInfo-None-01888,N,None,explicit,VkBufferCreateInfo,(VK_VERSION_1_1)," If any of the bits VK_BUFFER_CREATE_SPARSE_BINDING_BIT, VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, or VK_BUFFER_CREATE_SPARSE_ALIASED_BIT are set, VK_BUFFER_CREATE_PROTECTED_BIT must not also be set"
VUID-VkBufferCreateInfo-flags-00915,Y,None,explicit,VkBufferCreateInfo,core," If the sparse bindings feature is not enabled, flags must not contain VK_BUFFER_CREATE_SPARSE_BINDING_BIT"
VUID-VkBufferCreateInfo-flags-00916,Y,None,explicit,VkBufferCreateInfo,core," If the sparse buffer residency feature is not enabled, flags must not contain VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT"
VUID-VkBufferCreateInfo-flags-00917,Y,None,explicit,VkBufferCreateInfo,core," If the sparse aliased residency feature is not enabled, flags must not contain VK_BUFFER_CREATE_SPARSE_ALIASED_BIT"
VUID-VkBufferCreateInfo-flags-00918,Y,SparseBindingImageBufferCreate,explicit,VkBufferCreateInfo,core," If flags contains VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT or VK_BUFFER_CREATE_SPARSE_ALIASED_BIT, it must also contain VK_BUFFER_CREATE_SPARSE_BINDING_BIT"
VUID-VkBufferCreateInfo-flags-01887,N,None,explicit,VkBufferCreateInfo,(VK_VERSION_1_1)," If the protected memory feature is not enabled, flags must not contain VK_BUFFER_CREATE_PROTECTED_BIT"
VUID-VkBufferCreateInfo-flags-parameter,Y,None,implicit,VkBufferCreateInfo,core, flags must be a valid combination of VkBufferCreateFlagBits values
VUID-VkBufferCreateInfo-pNext-00920,N,None,explicit,VkBufferCreateInfo,"(VK_VERSION_1_1,VK_KHR_external_memory)"," If the pNext chain contains an instance of VkExternalMemoryBufferCreateInfo, its handleTypes member must only contain bits that are also in VkExternalBufferProperties::externalMemoryProperties.compatibleHandleTypes, as returned by vkGetPhysicalDeviceExternalBufferProperties with pExternalBufferInfo->handleType equal to any one of the handle types specified in VkExternalMemoryBufferCreateInfo::handleTypes"
VUID-VkBufferCreateInfo-pNext-01571,N,None,explicit,VkBufferCreateInfo,(VK_NV_dedicated_allocation)," If the pNext chain contains an instance of VkDedicatedAllocationBufferCreateInfoNV, and the dedicatedAllocation member of the chained structure is VK_TRUE, then flags must not include VK_BUFFER_CREATE_SPARSE_BINDING_BIT, VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, or VK_BUFFER_CREATE_SPARSE_ALIASED_BIT"
VUID-VkBufferCreateInfo-pNext-pNext,Y,None,implicit,VkBufferCreateInfo,core, Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDedicatedAllocationBufferCreateInfoNV or VkExternalMemoryBufferCreateInfo
VUID-VkBufferCreateInfo-sType-sType,Y,None,implicit,VkBufferCreateInfo,core, sType must be VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
VUID-VkBufferCreateInfo-sType-unique,N,None,implicit,VkBufferCreateInfo,core, Each sType member in the pNext chain must be unique
VUID-VkBufferCreateInfo-sharingMode-00913,Y,None,explicit,VkBufferCreateInfo,core," If sharingMode is VK_SHARING_MODE_CONCURRENT, pQueueFamilyIndices must be a valid pointer to an array of queueFamilyIndexCount uint32_t values"
VUID-VkBufferCreateInfo-sharingMode-00914,Y,None,explicit,VkBufferCreateInfo,core," If sharingMode is VK_SHARING_MODE_CONCURRENT, queueFamilyIndexCount must be greater than 1"
VUID-VkBufferCreateInfo-sharingMode-01391,N,None,explicit,VkBufferCreateInfo,"!(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)"," If sharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the physicalDevice that was used to create device"
VUID-VkBufferCreateInfo-sharingMode-01419,N,None,explicit,VkBufferCreateInfo,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)"," If sharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by either vkGetPhysicalDeviceQueueFamilyProperties or vkGetPhysicalDeviceQueueFamilyProperties2 for the physicalDevice that was used to create device"
VUID-VkBufferCreateInfo-sharingMode-parameter,Y,None,implicit,VkBufferCreateInfo,core, sharingMode must be a valid VkSharingMode value
VUID-VkBufferCreateInfo-size-00912,Y,InvalidCreateBufferSize,explicit,VkBufferCreateInfo,core, size must be greater than 0
VUID-VkBufferCreateInfo-usage-parameter,N,None,implicit,VkBufferCreateInfo,core, usage must be a valid combination of VkBufferUsageFlagBits values
VUID-VkBufferCreateInfo-usage-requiredbitmask,Y,None,implicit,VkBufferCreateInfo,core, usage must not be 0
VUID-VkBufferImageCopy-None-00214,N,None,explicit,VkBufferImageCopy,core," When copying to the depth aspect of an image subresource, the data in the source buffer must be in the range [0,1]"
VUID-VkBufferImageCopy-None-01735,N,None,explicit,VkBufferImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's VkImage parameter is a compressed image, or a single-plane, '_422' image format, bufferRowLength must be a multiple of the compressed texel block width"
VUID-VkBufferImageCopy-None-01736,N,None,explicit,VkBufferImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's VkImage parameter is a compressed image, or a single-plane, '_422' image format, bufferImageHeight must be a multiple of the compressed texel block height"
VUID-VkBufferImageCopy-None-01737,N,None,explicit,VkBufferImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's VkImage parameter is a compressed image, or a single-plane, '_422' image format, all members of imageOffset must be a multiple of the corresponding dimensions of the compressed texel block"
VUID-VkBufferImageCopy-None-01738,N,None,explicit,VkBufferImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's VkImage parameter is a compressed image, or a single-plane, '_422' image format, bufferOffset must be a multiple of the compressed texel block size in bytes"
VUID-VkBufferImageCopy-None-01739,N,None,explicit,VkBufferImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's VkImage parameter is a compressed image, or a single-plane, '_422' image format, imageExtent.width must be a multiple of the compressed texel block width or (imageExtent.width + imageOffset.x) must equal the image subresource width"
VUID-VkBufferImageCopy-None-01740,N,None,explicit,VkBufferImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's VkImage parameter is a compressed image, or a single-plane, '_422' image format, imageExtent.height must be a multiple of the compressed texel block height or (imageExtent.height + imageOffset.y) must equal the image subresource height"
VUID-VkBufferImageCopy-None-01741,N,None,explicit,VkBufferImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's VkImage parameter is a compressed image, or a single-plane, '_422' image format, imageExtent.depth must be a multiple of the compressed texel block depth or (imageExtent.depth + imageOffset.z) must equal the image subresource depth"
VUID-VkBufferImageCopy-aspectMask-00211,Y,ImageBufferCopyTests,explicit,VkBufferImageCopy,core, The aspectMask member of imageSubresource must specify aspects present in the calling command's VkImage parameter
VUID-VkBufferImageCopy-aspectMask-00212,Y,ImageBufferCopyTests,explicit,VkBufferImageCopy,core, The aspectMask member of imageSubresource must only have a single bit set
VUID-VkBufferImageCopy-aspectMask-01560,N,None,explicit,VkBufferImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's VkImage parameter's format is a multi-planar format, then the aspectMask member of imageSubresource must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT (with VK_IMAGE_ASPECT_PLANE_2_BIT valid only for image formats with three planes)"
VUID-VkBufferImageCopy-baseArrayLayer-00213,Y,None,explicit,VkBufferImageCopy,core," If the calling command's VkImage parameter is of VkImageType VK_IMAGE_TYPE_3D, the baseArrayLayer and layerCount members of imageSubresource must be 0 and 1, respectively"
VUID-VkBufferImageCopy-bufferImageHeight-00196,Y,MiscImageLayerTests,explicit,VkBufferImageCopy,core," bufferImageHeight must be 0, or greater than or equal to the height member of imageExtent"
VUID-VkBufferImageCopy-bufferImageHeight-00204,Y,ImageBufferCopyTests,explicit,VkBufferImageCopy,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's VkImage parameter is a compressed image, bufferImageHeight must be a multiple of the compressed texel block height"
VUID-VkBufferImageCopy-bufferOffset-00193,Y,"ImageBufferCopyTests, MiscImageLayerTests",explicit,VkBufferImageCopy,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's VkImage parameter's format is not a depth/stencil format, then bufferOffset must be a multiple of the format's element size"
VUID-VkBufferImageCopy-bufferOffset-00194,Y,MiscImageLayerTests,explicit,VkBufferImageCopy,core, bufferOffset must be a multiple of 4
VUID-VkBufferImageCopy-bufferOffset-00206,Y,ImageBufferCopyTests,explicit,VkBufferImageCopy,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's VkImage parameter is a compressed image, bufferOffset must be a multiple of the compressed texel block size in bytes"
VUID-VkBufferImageCopy-bufferOffset-01558,N,None,explicit,VkBufferImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's VkImage parameter's format is not a depth/stencil format or a multi-planar format, then bufferOffset must be a multiple of the format's element size"
VUID-VkBufferImageCopy-bufferOffset-01559,N,None,explicit,VkBufferImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's VkImage parameter's format is a multi-planar format, then bufferOffset must be a multiple of the element size of the compatible format for the format and the aspectMask of the imageSubresource as defined in Compatible formats of planes of multi-planar formats"
VUID-VkBufferImageCopy-bufferRowLength-00195,Y,MiscImageLayerTests,explicit,VkBufferImageCopy,core," bufferRowLength must be 0, or greater than or equal to the width member of imageExtent"
VUID-VkBufferImageCopy-bufferRowLength-00203,Y,ImageBufferCopyTests,explicit,VkBufferImageCopy,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's VkImage parameter is a compressed image, bufferRowLength must be a multiple of the compressed texel block width"
VUID-VkBufferImageCopy-imageExtent-00207,Y,"ImageBufferCopyTests, CompressedImageMipCopyTests",explicit,VkBufferImageCopy,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's VkImage parameter is a compressed image, imageExtent.width must be a multiple of the compressed texel block width or (imageExtent.width + imageOffset.x) must equal the image subresource width"
VUID-VkBufferImageCopy-imageExtent-00208,Y,"ImageBufferCopyTests, CompressedImageMipCopyTests",explicit,VkBufferImageCopy,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's VkImage parameter is a compressed image, imageExtent.height must be a multiple of the compressed texel block height or (imageExtent.height + imageOffset.y) must equal the image subresource height"
VUID-VkBufferImageCopy-imageExtent-00209,Y,None,explicit,VkBufferImageCopy,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's VkImage parameter is a compressed image, imageExtent.depth must be a multiple of the compressed texel block depth or (imageExtent.depth + imageOffset.z) must equal the image subresource depth"
VUID-VkBufferImageCopy-imageOffset-00197,N,None,explicit,VkBufferImageCopy,core, imageOffset.x and (imageExtent.width + imageOffset.x) must both be greater than or equal to 0 and less than or equal to the image subresource width
VUID-VkBufferImageCopy-imageOffset-00198,N,None,explicit,VkBufferImageCopy,core, imageOffset.y and (imageExtent.height + imageOffset.y) must both be greater than or equal to 0 and less than or equal to the image subresource height
VUID-VkBufferImageCopy-imageOffset-00200,N,None,explicit,VkBufferImageCopy,core, imageOffset.z and (imageExtent.depth + imageOffset.z) must both be greater than or equal to 0 and less than or equal to the image subresource depth
VUID-VkBufferImageCopy-imageOffset-00205,Y,CompressedImageMipCopyTests,explicit,VkBufferImageCopy,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's VkImage parameter is a compressed image, all members of imageOffset must be a multiple of the corresponding dimensions of the compressed texel block"
VUID-VkBufferImageCopy-imageSubresource-parameter,N,None,implicit,VkBufferImageCopy,core, imageSubresource must be a valid VkImageSubresourceLayers structure
VUID-VkBufferImageCopy-srcImage-00199,Y,None,explicit,VkBufferImageCopy,core," If the calling command's srcImage (vkCmdCopyImageToBuffer) or dstImage (vkCmdCopyBufferToImage) is of type VK_IMAGE_TYPE_1D, then imageOffset.y must be 0 and imageExtent.height must be 1."
VUID-VkBufferImageCopy-srcImage-00201,Y,MiscImageLayerTests,explicit,VkBufferImageCopy,core," If the calling command's srcImage (vkCmdCopyImageToBuffer) or dstImage (vkCmdCopyBufferToImage) is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then imageOffset.z must be 0 and imageExtent.depth must be 1"
VUID-VkBufferMemoryBarrier-buffer-01190,Y,InvalidBarrierQueueFamily,explicit,VkBufferMemoryBarrier,"!(VK_VERSION_1_1,VK_KHR_external_memory)"," If buffer was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, srcQueueFamilyIndex and dstQueueFamilyIndex must both be VK_QUEUE_FAMILY_IGNORED"
VUID-VkBufferMemoryBarrier-buffer-01191,Y,InvalidBarrierQueueFamilyWithMemExt,explicit,VkBufferMemoryBarrier,"(VK_VERSION_1_1,VK_KHR_external_memory)"," If buffer was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, at least one of srcQueueFamilyIndex and dstQueueFamilyIndex must be VK_QUEUE_FAMILY_IGNORED"
VUID-VkBufferMemoryBarrier-buffer-01192,Y,InvalidBarrierQueueFamily,explicit,VkBufferMemoryBarrier,"!(VK_VERSION_1_1,VK_KHR_external_memory)"," If buffer was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE, srcQueueFamilyIndex and dstQueueFamilyIndex must either both be VK_QUEUE_FAMILY_IGNORED, or both be a valid queue family (see Queue Family Properties)"
VUID-VkBufferMemoryBarrier-buffer-01193,Y,InvalidBarrierQueueFamilyWithMemExt,explicit,VkBufferMemoryBarrier,"(VK_VERSION_1_1,VK_KHR_external_memory)"," If buffer was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE and srcQueueFamilyIndex is VK_QUEUE_FAMILY_IGNORED, dstQueueFamilyIndex must also be VK_QUEUE_FAMILY_IGNORED"
VUID-VkBufferMemoryBarrier-buffer-01196,Y,InvalidBarrierQueueFamily,explicit,VkBufferMemoryBarrier,core," If buffer was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE, and srcQueueFamilyIndex and dstQueueFamilyIndex are not VK_QUEUE_FAMILY_IGNORED, at least one of them must be the same as the family of the queue that will execute this barrier"
VUID-VkBufferMemoryBarrier-buffer-01763,Y,InvalidBarrierQueueFamilyWithMemExt,explicit,VkBufferMemoryBarrier,"(VK_VERSION_1_1,VK_KHR_external_memory)"," If buffer was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, and one of srcQueueFamilyIndex and dstQueueFamilyIndex is VK_QUEUE_FAMILY_IGNORED, the other must be VK_QUEUE_FAMILY_IGNORED or a special queue family reserved for external memory ownership transfers, as described in Queue Family Ownership Transfer."
VUID-VkBufferMemoryBarrier-buffer-01764,Y,InvalidBarrierQueueFamilyWithMemExt,explicit,VkBufferMemoryBarrier,"(VK_VERSION_1_1,VK_KHR_external_memory)"," If buffer was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE and srcQueueFamilyIndex is not VK_QUEUE_FAMILY_IGNORED, it must be a valid queue family or a special queue family reserved for external memory transfers, as described in Queue Family Ownership Transfer."
VUID-VkBufferMemoryBarrier-buffer-01765,Y,InvalidBarrierQueueFamilyWithMemExt,explicit,VkBufferMemoryBarrier,"(VK_VERSION_1_1,VK_KHR_external_memory)"," If buffer was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE and dstQueueFamilyIndex is not VK_QUEUE_FAMILY_IGNORED, it must be a valid queue family or a special queue family reserved for external memory transfers, as described in Queue Family Ownership Transfer."
VUID-VkBufferMemoryBarrier-buffer-01931,N,None,explicit,VkBufferMemoryBarrier,core, If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-VkBufferMemoryBarrier-buffer-parameter,Y,None,implicit,VkBufferMemoryBarrier,core, buffer must be a valid VkBuffer handle
VUID-VkBufferMemoryBarrier-dstAccessMask-parameter,Y,None,implicit,VkBufferMemoryBarrier,core, dstAccessMask must be a valid combination of VkAccessFlagBits values
VUID-VkBufferMemoryBarrier-offset-01187,Y,InvalidBarriers,explicit,VkBufferMemoryBarrier,core, offset must be less than the size of buffer
VUID-VkBufferMemoryBarrier-pNext-pNext,Y,None,implicit,VkBufferMemoryBarrier,core, pNext must be NULL
VUID-VkBufferMemoryBarrier-sType-sType,Y,None,implicit,VkBufferMemoryBarrier,core, sType must be VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER
VUID-VkBufferMemoryBarrier-size-01188,N,None,explicit,VkBufferMemoryBarrier,core," If size is not equal to VK_WHOLE_SIZE, size must be greater than 0"
VUID-VkBufferMemoryBarrier-size-01189,Y,InvalidBarriers,explicit,VkBufferMemoryBarrier,core," If size is not equal to VK_WHOLE_SIZE, size must be less than or equal to than the size of buffer minus offset"
VUID-VkBufferMemoryBarrier-srcAccessMask-parameter,Y,None,implicit,VkBufferMemoryBarrier,core, srcAccessMask must be a valid combination of VkAccessFlagBits values
VUID-VkBufferMemoryRequirementsInfo2-buffer-parameter,Y,None,implicit,VkBufferMemoryRequirementsInfo2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", buffer must be a valid VkBuffer handle
VUID-VkBufferMemoryRequirementsInfo2-pNext-pNext,Y,None,implicit,VkBufferMemoryRequirementsInfo2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", pNext must be NULL
VUID-VkBufferMemoryRequirementsInfo2-sType-sType,Y,None,implicit,VkBufferMemoryRequirementsInfo2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", sType must be VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2
VUID-VkBufferViewCreateInfo-buffer-00932,Y,InvalidBufferViewCreateInfoEntries,explicit,VkBufferViewCreateInfo,core, buffer must have been created with a usage value containing at least one of VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT
VUID-VkBufferViewCreateInfo-buffer-00933,Y,InvalidBufferViewCreateInfoEntries,explicit,VkBufferViewCreateInfo,core," If buffer was created with usage containing VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT, format must be supported for uniform texel buffers, as specified by the VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT flag in VkFormatProperties::bufferFeatures returned by vkGetPhysicalDeviceFormatProperties"
VUID-VkBufferViewCreateInfo-buffer-00934,Y,InvalidBufferViewCreateInfoEntries,explicit,VkBufferViewCreateInfo,core," If buffer was created with usage containing VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT, format must be supported for storage texel buffers, as specified by the VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT flag in VkFormatProperties::bufferFeatures returned by vkGetPhysicalDeviceFormatProperties"
VUID-VkBufferViewCreateInfo-buffer-00935,Y,None,explicit,VkBufferViewCreateInfo,core, If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-VkBufferViewCreateInfo-buffer-parameter,Y,None,implicit,VkBufferViewCreateInfo,core, buffer must be a valid VkBuffer handle
VUID-VkBufferViewCreateInfo-flags-zerobitmask,Y,None,implicit,VkBufferViewCreateInfo,core, flags must be 0
VUID-VkBufferViewCreateInfo-format-parameter,Y,None,implicit,VkBufferViewCreateInfo,core, format must be a valid VkFormat value
VUID-VkBufferViewCreateInfo-offset-00925,Y,InvalidBufferViewCreateInfoEntries,explicit,VkBufferViewCreateInfo,core, offset must be less than the size of buffer
VUID-VkBufferViewCreateInfo-offset-00926,Y,InvalidBufferViewCreateInfoEntries,explicit,VkBufferViewCreateInfo,core, offset must be a multiple of VkPhysicalDeviceLimits::minTexelBufferOffsetAlignment
VUID-VkBufferViewCreateInfo-offset-00931,Y,InvalidBufferViewCreateInfoEntries,explicit,VkBufferViewCreateInfo,core," If range is not equal to VK_WHOLE_SIZE, the sum of offset and range must be less than or equal to the size of buffer"
VUID-VkBufferViewCreateInfo-pNext-pNext,Y,None,implicit,VkBufferViewCreateInfo,core, pNext must be NULL
VUID-VkBufferViewCreateInfo-range-00928,Y,InvalidBufferViewCreateInfoEntries,explicit,VkBufferViewCreateInfo,core," If range is not equal to VK_WHOLE_SIZE, range must be greater than 0"
VUID-VkBufferViewCreateInfo-range-00929,Y,InvalidBufferViewCreateInfoEntries,explicit,VkBufferViewCreateInfo,core," If range is not equal to VK_WHOLE_SIZE, range must be a multiple of the element size of format"
VUID-VkBufferViewCreateInfo-range-00930,Y,InvalidBufferViewCreateInfoEntries,explicit,VkBufferViewCreateInfo,core," If range is not equal to VK_WHOLE_SIZE, range divided by the element size of format must be less than or equal to VkPhysicalDeviceLimits::maxTexelBufferElements"
VUID-VkBufferViewCreateInfo-sType-sType,Y,None,implicit,VkBufferViewCreateInfo,core, sType must be VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO
VUID-VkCheckpointDataNV-pNext-pNext,Y,None,implicit,VkCheckpointDataNV,(VK_NV_device_diagnostic_checkpoints), pNext must be NULL
VUID-VkCheckpointDataNV-sType-sType,Y,None,implicit,VkCheckpointDataNV,(VK_NV_device_diagnostic_checkpoints), sType must be VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV
VUID-VkClearAttachment-aspectMask-00019,Y,None,explicit,VkClearAttachment,core," If aspectMask includes VK_IMAGE_ASPECT_COLOR_BIT, it must not include VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT"
VUID-VkClearAttachment-aspectMask-00020,Y,None,explicit,VkClearAttachment,core, aspectMask must not include VK_IMAGE_ASPECT_METADATA_BIT
VUID-VkClearAttachment-aspectMask-parameter,Y,None,implicit,VkClearAttachment,core, aspectMask must be a valid combination of VkImageAspectFlagBits values
VUID-VkClearAttachment-aspectMask-requiredbitmask,Y,None,implicit,VkClearAttachment,core, aspectMask must not be 0
VUID-VkClearAttachment-clearValue-00021,N,None,explicit,VkClearAttachment,core, clearValue must be a valid VkClearValue union
VUID-VkClearAttachment-commandBuffer-01809,N,None,explicit,VkClearAttachment,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, then the attachment to be cleared must not be a protected image."
VUID-VkClearAttachment-commandBuffer-01810,N,None,explicit,VkClearAttachment,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, then the attachment to be cleared must not be an unprotected image."
VUID-VkClearDepthStencilValue-depth-00022,N,None,explicit,VkClearDepthStencilValue,(VK_EXT_depth_range_unrestricted)," Unless the VK_EXT_depth_range_unrestricted extension is enabled depth must be between 0.0 and 1.0, inclusive"
VUID-VkClearDepthStencilValue-depth-00022,N,None,explicit,VkClearDepthStencilValue,!(VK_EXT_depth_range_unrestricted)," depth must be between 0.0 and 1.0, inclusive"
VUID-VkCmdProcessCommandsInfoNVX-commonparent,Y,None,implicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands)," Each of indirectCommandsLayout, objectTable, sequencesCountBuffer, sequencesIndexBuffer, and targetCommandBuffer that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkCmdProcessCommandsInfoNVX-indirectCommandsLayout-parameter,Y,None,implicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands), indirectCommandsLayout must be a valid VkIndirectCommandsLayoutNVX handle
VUID-VkCmdProcessCommandsInfoNVX-indirectCommandsTokenCount-01332,N,None,explicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands), indirectCommandsTokenCount must match the indirectCommandsLayout's tokenCount.
VUID-VkCmdProcessCommandsInfoNVX-indirectCommandsTokenCount-arraylength,Y,None,implicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands), indirectCommandsTokenCount must be greater than 0
VUID-VkCmdProcessCommandsInfoNVX-objectTable-01331,N,None,explicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands), The provided objectTable must include all objects referenced by the generation process.
VUID-VkCmdProcessCommandsInfoNVX-objectTable-parameter,Y,None,implicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands), objectTable must be a valid VkObjectTableNVX handle
VUID-VkCmdProcessCommandsInfoNVX-pIndirectCommandsTokens-parameter,Y,None,implicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands), pIndirectCommandsTokens must be a valid pointer to an array of indirectCommandsTokenCount valid VkIndirectCommandsTokenNVX structures
VUID-VkCmdProcessCommandsInfoNVX-pNext-pNext,Y,None,implicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands), pNext must be NULL
VUID-VkCmdProcessCommandsInfoNVX-sType-sType,Y,None,implicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands), sType must be VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX
VUID-VkCmdProcessCommandsInfoNVX-sequencesCountBuffer-01338,N,None,explicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands)," If sequencesCountBuffer is used, its usage flag must have VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set."
VUID-VkCmdProcessCommandsInfoNVX-sequencesCountBuffer-01339,N,None,explicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands)," If sequencesCountBuffer is used, sequencesCountOffset must be aligned to VkDeviceGeneratedCommandsLimitsNVX::minSequenceCountBufferOffsetAlignment."
VUID-VkCmdProcessCommandsInfoNVX-sequencesCountBuffer-parameter,Y,None,implicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands)," If sequencesCountBuffer is not VK_NULL_HANDLE, sequencesCountBuffer must be a valid VkBuffer handle"
VUID-VkCmdProcessCommandsInfoNVX-sequencesIndexBuffer-01340,N,None,explicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands)," If sequencesIndexBuffer is used, its usage flag must have VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set."
VUID-VkCmdProcessCommandsInfoNVX-sequencesIndexBuffer-01341,N,None,explicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands)," If sequencesIndexBuffer is used, sequencesIndexOffset must be aligned to VkDeviceGeneratedCommandsLimitsNVX::minSequenceIndexBufferOffsetAlignment."
VUID-VkCmdProcessCommandsInfoNVX-sequencesIndexBuffer-parameter,Y,None,implicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands)," If sequencesIndexBuffer is not VK_NULL_HANDLE, sequencesIndexBuffer must be a valid VkBuffer handle"
VUID-VkCmdProcessCommandsInfoNVX-targetCommandBuffer-01334,N,None,explicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands)," If targetCommandBuffer is provided, it must have reserved command space."
VUID-VkCmdProcessCommandsInfoNVX-targetCommandBuffer-01335,N,None,explicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands)," If targetCommandBuffer is provided, the objectTable must match the reservation's objectTable and must have had all referenced objects registered at reservation time."
VUID-VkCmdProcessCommandsInfoNVX-targetCommandBuffer-01336,N,None,explicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands)," If targetCommandBuffer is provided, the indirectCommandsLayout must match the reservation's indirectCommandsLayout."
VUID-VkCmdProcessCommandsInfoNVX-targetCommandBuffer-01337,N,None,explicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands)," If targetCommandBuffer is provided, the maxSequencesCount must not exceed the reservation's maxSequencesCount."
VUID-VkCmdProcessCommandsInfoNVX-targetCommandBuffer-parameter,Y,None,implicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands)," If targetCommandBuffer is not NULL, targetCommandBuffer must be a valid VkCommandBuffer handle"
VUID-VkCmdProcessCommandsInfoNVX-tokenType-01333,N,None,explicit,VkCmdProcessCommandsInfoNVX,(VK_NVX_device_generated_commands), The tokenType member of each entry in the pIndirectCommandsTokens array must match the values used at creation time of indirectCommandsLayout
VUID-VkCmdReserveSpaceForCommandsInfoNVX-commonparent,Y,None,implicit,VkCmdReserveSpaceForCommandsInfoNVX,(VK_NVX_device_generated_commands)," Both of indirectCommandsLayout, and objectTable must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkCmdReserveSpaceForCommandsInfoNVX-indirectCommandsLayout-parameter,Y,None,implicit,VkCmdReserveSpaceForCommandsInfoNVX,(VK_NVX_device_generated_commands), indirectCommandsLayout must be a valid VkIndirectCommandsLayoutNVX handle
VUID-VkCmdReserveSpaceForCommandsInfoNVX-objectTable-parameter,Y,None,implicit,VkCmdReserveSpaceForCommandsInfoNVX,(VK_NVX_device_generated_commands), objectTable must be a valid VkObjectTableNVX handle
VUID-VkCmdReserveSpaceForCommandsInfoNVX-pNext-pNext,Y,None,implicit,VkCmdReserveSpaceForCommandsInfoNVX,(VK_NVX_device_generated_commands), pNext must be NULL
VUID-VkCmdReserveSpaceForCommandsInfoNVX-sType-sType,Y,None,implicit,VkCmdReserveSpaceForCommandsInfoNVX,(VK_NVX_device_generated_commands), sType must be VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX
VUID-VkCoarseSampleLocationNV-pixelX-02078,Y,ShadingRateImageNV,explicit,VkCoarseSampleLocationNV,(VK_NV_shading_rate_image), pixelX must be less than the width (in pixels) of the fragment.
VUID-VkCoarseSampleLocationNV-pixelY-02079,Y,ShadingRateImageNV,explicit,VkCoarseSampleLocationNV,(VK_NV_shading_rate_image), pixelY must be less than the height (in pixels) of the fragment.
VUID-VkCoarseSampleLocationNV-sample-02080,Y,ShadingRateImageNV,explicit,VkCoarseSampleLocationNV,(VK_NV_shading_rate_image), sample must be less than the number of coverage samples in each pixel belonging to the fragment.
VUID-VkCoarseSampleOrderCustomNV-pSampleLocations-02077,Y,ShadingRateImageNV,explicit,VkCoarseSampleOrderCustomNV,(VK_NV_shading_rate_image)," The array pSampleLocations must contain exactly one entry for every combination of valid values for pixelX, pixelY, and sample in the structure VkCoarseSampleOrderCustomNV."
VUID-VkCoarseSampleOrderCustomNV-pSampleLocations-parameter,Y,None,implicit,VkCoarseSampleOrderCustomNV,(VK_NV_shading_rate_image), pSampleLocations must be a valid pointer to an array of sampleLocationCount VkCoarseSampleLocationNV structures
VUID-VkCoarseSampleOrderCustomNV-sampleCount-02074,Y,ShadingRateImageNV,explicit,VkCoarseSampleOrderCustomNV,(VK_NV_shading_rate_image), sampleCount must correspond to a sample count enumerated in VkSampleCountFlags whose corresponding bit is set in VkPhysicalDeviceLimits::framebufferNoAttachmentsSampleCounts.
VUID-VkCoarseSampleOrderCustomNV-sampleLocationCount-02075,Y,ShadingRateImageNV,explicit,VkCoarseSampleOrderCustomNV,(VK_NV_shading_rate_image)," sampleLocationCount must be equal to the product of sampleCount, the fragment width for shadingRate, and the fragment height for shadingRate."
VUID-VkCoarseSampleOrderCustomNV-sampleLocationCount-02076,Y,ShadingRateImageNV,explicit,VkCoarseSampleOrderCustomNV,(VK_NV_shading_rate_image), sampleLocationCount must be less than or equal to the value of VkPhysicalDeviceShadingRateImagePropertiesNV::shadingRateMaxCoarseSamples.
VUID-VkCoarseSampleOrderCustomNV-sampleLocationCount-arraylength,Y,None,implicit,VkCoarseSampleOrderCustomNV,(VK_NV_shading_rate_image), sampleLocationCount must be greater than 0
VUID-VkCoarseSampleOrderCustomNV-shadingRate-02073,Y,ShadingRateImageNV,explicit,VkCoarseSampleOrderCustomNV,(VK_NV_shading_rate_image), shadingRate must be a shading rate that generates fragments with more than one pixel.
VUID-VkCoarseSampleOrderCustomNV-shadingRate-parameter,Y,None,implicit,VkCoarseSampleOrderCustomNV,(VK_NV_shading_rate_image), shadingRate must be a valid VkShadingRatePaletteEntryNV value
VUID-VkCommandBufferAllocateInfo-commandBufferCount-00044,N,None,explicit,VkCommandBufferAllocateInfo,core, commandBufferCount must be greater than 0
VUID-VkCommandBufferAllocateInfo-commandPool-parameter,Y,None,implicit,VkCommandBufferAllocateInfo,core, commandPool must be a valid VkCommandPool handle
VUID-VkCommandBufferAllocateInfo-level-parameter,Y,None,implicit,VkCommandBufferAllocateInfo,core, level must be a valid VkCommandBufferLevel value
VUID-VkCommandBufferAllocateInfo-pNext-pNext,Y,None,implicit,VkCommandBufferAllocateInfo,core, pNext must be NULL
VUID-VkCommandBufferAllocateInfo-sType-sType,Y,None,implicit,VkCommandBufferAllocateInfo,core, sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
VUID-VkCommandBufferBeginInfo-flags-00053,Y,SecondaryCommandBufferNullRenderpass,explicit,VkCommandBufferBeginInfo,core," If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the renderPass member of pInheritanceInfo must be a valid VkRenderPass"
VUID-VkCommandBufferBeginInfo-flags-00054,Y,None,explicit,VkCommandBufferBeginInfo,core," If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the subpass member of pInheritanceInfo must be a valid subpass index within the renderPass member of pInheritanceInfo"
VUID-VkCommandBufferBeginInfo-flags-00055,Y,None,explicit,VkCommandBufferBeginInfo,core," If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the framebuffer member of pInheritanceInfo must be either VK_NULL_HANDLE, or a valid VkFramebuffer that is compatible with the renderPass member of pInheritanceInfo"
VUID-VkCommandBufferBeginInfo-flags-parameter,Y,None,implicit,VkCommandBufferBeginInfo,core, flags must be a valid combination of VkCommandBufferUsageFlagBits values
VUID-VkCommandBufferBeginInfo-pNext-pNext,Y,None,implicit,VkCommandBufferBeginInfo,core, pNext must be NULL or a pointer to a valid instance of VkDeviceGroupCommandBufferBeginInfo
VUID-VkCommandBufferBeginInfo-sType-sType,Y,None,implicit,VkCommandBufferBeginInfo,core, sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
VUID-VkCommandBufferInheritanceConditionalRenderingInfoEXT-conditionalRenderingEnable-01977,N,None,explicit,VkCommandBufferInheritanceConditionalRenderingInfoEXT,(VK_EXT_conditional_rendering)," If the inherited conditional rendering feature is not enabled, conditionalRenderingEnable must be VK_FALSE"
VUID-VkCommandBufferInheritanceConditionalRenderingInfoEXT-sType-sType,N,None,implicit,VkCommandBufferInheritanceConditionalRenderingInfoEXT,(VK_EXT_conditional_rendering), sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT
VUID-VkCommandBufferInheritanceInfo-commonparent,Y,None,implicit,VkCommandBufferInheritanceInfo,core," Both of framebuffer, and renderPass that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkCommandBufferInheritanceInfo-occlusionQueryEnable-00056,Y,None,explicit,VkCommandBufferInheritanceInfo,core," If the inherited queries feature is not enabled, occlusionQueryEnable must be VK_FALSE"
VUID-VkCommandBufferInheritanceInfo-pNext-pNext,N,None,implicit,VkCommandBufferInheritanceInfo,core, pNext must be NULL or a pointer to a valid instance of VkCommandBufferInheritanceConditionalRenderingInfoEXT
VUID-VkCommandBufferInheritanceInfo-pipelineStatistics-00058,N,None,explicit,VkCommandBufferInheritanceInfo,core," If the pipeline statistics queries feature is not enabled, pipelineStatistics must be 0"
VUID-VkCommandBufferInheritanceInfo-queryFlags-00057,Y,None,explicit,VkCommandBufferInheritanceInfo,core," If the inherited queries feature is enabled, queryFlags must be a valid combination of VkQueryControlFlagBits values"
VUID-VkCommandBufferInheritanceInfo-sType-sType,N,None,implicit,VkCommandBufferInheritanceInfo,core, sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO
VUID-VkCommandPoolCreateInfo-flags-parameter,Y,None,implicit,VkCommandPoolCreateInfo,core, flags must be a valid combination of VkCommandPoolCreateFlagBits values
VUID-VkCommandPoolCreateInfo-pNext-pNext,Y,None,implicit,VkCommandPoolCreateInfo,core, pNext must be NULL
VUID-VkCommandPoolCreateInfo-sType-sType,Y,None,implicit,VkCommandPoolCreateInfo,core, sType must be VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO
VUID-VkComponentMapping-a-parameter,Y,None,implicit,VkComponentMapping,core, a must be a valid VkComponentSwizzle value
VUID-VkComponentMapping-b-parameter,Y,None,implicit,VkComponentMapping,core, b must be a valid VkComponentSwizzle value
VUID-VkComponentMapping-g-parameter,Y,None,implicit,VkComponentMapping,core, g must be a valid VkComponentSwizzle value
VUID-VkComponentMapping-r-parameter,Y,None,implicit,VkComponentMapping,core, r must be a valid VkComponentSwizzle value
VUID-VkComputePipelineCreateInfo-commonparent,Y,None,implicit,VkComputePipelineCreateInfo,core," Both of basePipelineHandle, and layout that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkComputePipelineCreateInfo-flags-00697,Y,None,explicit,VkComputePipelineCreateInfo,core," If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is -1, basePipelineHandle must be a valid handle to a compute VkPipeline"
VUID-VkComputePipelineCreateInfo-flags-00698,N,None,explicit,VkComputePipelineCreateInfo,core," If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is VK_NULL_HANDLE, basePipelineIndex must be a valid index into the calling command's pCreateInfos parameter"
VUID-VkComputePipelineCreateInfo-flags-00699,N,None,explicit,VkComputePipelineCreateInfo,core," If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is not -1, basePipelineHandle must be VK_NULL_HANDLE"
VUID-VkComputePipelineCreateInfo-flags-00700,N,None,explicit,VkComputePipelineCreateInfo,core," If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is not VK_NULL_HANDLE, basePipelineIndex must be -1"
VUID-VkComputePipelineCreateInfo-flags-parameter,Y,None,implicit,VkComputePipelineCreateInfo,core, flags must be a valid combination of VkPipelineCreateFlagBits values
VUID-VkComputePipelineCreateInfo-layout-00703,N,None,explicit,VkComputePipelineCreateInfo,core, layout must be consistent with the layout of the compute shader specified in stage
VUID-VkComputePipelineCreateInfo-layout-01687,N,None,explicit,VkComputePipelineCreateInfo,core, The number of resources in layout accessible to the compute shader stage must be less than or equal to VkPhysicalDeviceLimits::maxPerStageResources
VUID-VkComputePipelineCreateInfo-layout-parameter,Y,None,implicit,VkComputePipelineCreateInfo,core, layout must be a valid VkPipelineLayout handle
VUID-VkComputePipelineCreateInfo-pNext-pNext,Y,None,implicit,VkComputePipelineCreateInfo,core, pNext must be NULL
VUID-VkComputePipelineCreateInfo-sType-sType,Y,None,implicit,VkComputePipelineCreateInfo,core, sType must be VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO
VUID-VkComputePipelineCreateInfo-stage-00701,N,None,explicit,VkComputePipelineCreateInfo,core, The stage member of stage must be VK_SHADER_STAGE_COMPUTE_BIT
VUID-VkComputePipelineCreateInfo-stage-00702,N,None,explicit,VkComputePipelineCreateInfo,core, The shader code for the entry point identified by stage and the rest of the state identified by this structure must adhere to the pipeline linking rules described in the Shader Interfaces chapter
VUID-VkComputePipelineCreateInfo-stage-parameter,N,None,implicit,VkComputePipelineCreateInfo,core, stage must be a valid VkPipelineShaderStageCreateInfo structure
VUID-VkConditionalRenderingBeginInfoEXT-buffer-01981,N,None,explicit,VkConditionalRenderingBeginInfoEXT,(VK_EXT_conditional_rendering), If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-VkConditionalRenderingBeginInfoEXT-buffer-01982,N,None,explicit,VkConditionalRenderingBeginInfoEXT,(VK_EXT_conditional_rendering), buffer must have been created with the VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT bit set
VUID-VkConditionalRenderingBeginInfoEXT-offset-01983,N,None,explicit,VkConditionalRenderingBeginInfoEXT,(VK_EXT_conditional_rendering), offset must be less than the size of buffer by at least 32 bits.
VUID-VkConditionalRenderingBeginInfoEXT-offset-01984,N,None,explicit,VkConditionalRenderingBeginInfoEXT,(VK_EXT_conditional_rendering), offset must be a multiple of 4
VUID-VkCopyDescriptorSet-commonparent,Y,None,implicit,VkCopyDescriptorSet,core," Both of dstSet, and srcSet must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkCopyDescriptorSet-dstArrayElement-00348,Y,None,explicit,VkCopyDescriptorSet,core," The sum of dstArrayElement and descriptorCount must be less than or equal to the number of array elements in the descriptor set binding specified by dstBinding, and all applicable consecutive bindings, as described by consecutive binding updates"
VUID-VkCopyDescriptorSet-dstBinding-00347,Y,None,explicit,VkCopyDescriptorSet,core, dstBinding must be a valid binding within dstSet
VUID-VkCopyDescriptorSet-dstBinding-02224,Y,InlineUniformBlockEXT,explicit,VkCopyDescriptorSet,(VK_EXT_inline_uniform_block)," If the descriptor type of the descriptor set binding specified by dstBinding is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, dstArrayElement must be an integer multiple of 4"
VUID-VkCopyDescriptorSet-dstSet-parameter,Y,UpdateDestroyDescriptorSetLayout,implicit,VkCopyDescriptorSet,core, dstSet must be a valid VkDescriptorSet handle
VUID-VkCopyDescriptorSet-pNext-pNext,Y,None,implicit,VkCopyDescriptorSet,core, pNext must be NULL
VUID-VkCopyDescriptorSet-sType-sType,Y,None,implicit,VkCopyDescriptorSet,core, sType must be VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET
VUID-VkCopyDescriptorSet-srcArrayElement-00346,Y,None,explicit,VkCopyDescriptorSet,core," The sum of srcArrayElement and descriptorCount must be less than or equal to the number of array elements in the descriptor set binding specified by srcBinding, and all applicable consecutive bindings, as described by consecutive binding updates"
VUID-VkCopyDescriptorSet-srcBinding-00345,Y,None,explicit,VkCopyDescriptorSet,core, srcBinding must be a valid binding within srcSet
VUID-VkCopyDescriptorSet-srcBinding-02223,Y,InlineUniformBlockEXT,explicit,VkCopyDescriptorSet,(VK_EXT_inline_uniform_block)," If the descriptor type of the descriptor set binding specified by srcBinding is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, srcArrayElement must be an integer multiple of 4"
VUID-VkCopyDescriptorSet-srcBinding-02225,Y,InlineUniformBlockEXT,explicit,VkCopyDescriptorSet,(VK_EXT_inline_uniform_block)," If the descriptor type of the descriptor set binding specified by either srcBinding or dstBinding is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, descriptorCount must be an integer multiple of 4"
VUID-VkCopyDescriptorSet-srcSet-00349,Y,None,explicit,VkCopyDescriptorSet,core," If srcSet is equal to dstSet, then the source and destination ranges of descriptors must not overlap, where the ranges may include array elements from consecutive bindings as described by consecutive binding updates"
VUID-VkCopyDescriptorSet-srcSet-01918,Y,None,explicit,VkCopyDescriptorSet,(VK_EXT_descriptor_indexing)," If srcSet's layout was created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT flag set, then dstSet's layout must also have been created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT flag set"
VUID-VkCopyDescriptorSet-srcSet-01919,Y,None,explicit,VkCopyDescriptorSet,(VK_EXT_descriptor_indexing)," If srcSet's layout was created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT flag set, then dstSet's layout must also have been created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT flag set"
VUID-VkCopyDescriptorSet-srcSet-01920,Y,None,explicit,VkCopyDescriptorSet,(VK_EXT_descriptor_indexing)," If the descriptor pool from which srcSet was allocated was created with the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT flag set, then the descriptor pool from which dstSet was allocated must also have been created with the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT flag set"
VUID-VkCopyDescriptorSet-srcSet-01921,Y,None,explicit,VkCopyDescriptorSet,(VK_EXT_descriptor_indexing)," If the descriptor pool from which srcSet was allocated was created without the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT flag set, then the descriptor pool from which dstSet was allocated must also have been created without the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT flag set"
VUID-VkCopyDescriptorSet-srcSet-parameter,Y,UpdateDestroyDescriptorSetLayout,implicit,VkCopyDescriptorSet,core, srcSet must be a valid VkDescriptorSet handle
VUID-VkD3D12FenceSubmitInfoKHR-pSignalSemaphoreValues-parameter,N,None,implicit,VkD3D12FenceSubmitInfoKHR,(VK_KHR_external_semaphore_win32)," If signalSemaphoreValuesCount is not 0, and pSignalSemaphoreValues is not NULL, pSignalSemaphoreValues must be a valid pointer to an array of signalSemaphoreValuesCount uint64_t values"
VUID-VkD3D12FenceSubmitInfoKHR-pWaitSemaphoreValues-parameter,N,None,implicit,VkD3D12FenceSubmitInfoKHR,(VK_KHR_external_semaphore_win32)," If waitSemaphoreValuesCount is not 0, and pWaitSemaphoreValues is not NULL, pWaitSemaphoreValues must be a valid pointer to an array of waitSemaphoreValuesCount uint64_t values"
VUID-VkD3D12FenceSubmitInfoKHR-sType-sType,N,None,implicit,VkD3D12FenceSubmitInfoKHR,(VK_KHR_external_semaphore_win32), sType must be VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR
VUID-VkD3D12FenceSubmitInfoKHR-signalSemaphoreValuesCount-00080,N,None,explicit,VkD3D12FenceSubmitInfoKHR,(VK_KHR_external_semaphore_win32)," signalSemaphoreValuesCount must be the same value as VkSubmitInfo::signalSemaphoreCount, where VkSubmitInfo is in the pNext chain of this VkD3D12FenceSubmitInfoKHR structure."
VUID-VkD3D12FenceSubmitInfoKHR-waitSemaphoreValuesCount-00079,N,None,explicit,VkD3D12FenceSubmitInfoKHR,(VK_KHR_external_semaphore_win32)," waitSemaphoreValuesCount must be the same value as VkSubmitInfo::waitSemaphoreCount, where VkSubmitInfo is in the pNext chain of this VkD3D12FenceSubmitInfoKHR structure."
VUID-VkDebugMarkerMarkerInfoEXT-pMarkerName-parameter,Y,None,implicit,VkDebugMarkerMarkerInfoEXT,(VK_EXT_debug_marker), pMarkerName must be a null-terminated UTF-8 string
VUID-VkDebugMarkerMarkerInfoEXT-pNext-pNext,Y,None,implicit,VkDebugMarkerMarkerInfoEXT,(VK_EXT_debug_marker), pNext must be NULL
VUID-VkDebugMarkerMarkerInfoEXT-sType-sType,Y,None,implicit,VkDebugMarkerMarkerInfoEXT,(VK_EXT_debug_marker), sType must be VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT
VUID-VkDebugMarkerObjectNameInfoEXT-object-01491,N,None,explicit,VkDebugMarkerObjectNameInfoEXT,(VK_EXT_debug_marker), object must not be VK_NULL_HANDLE
VUID-VkDebugMarkerObjectNameInfoEXT-object-01492,N,None,explicit,VkDebugMarkerObjectNameInfoEXT,(VK_EXT_debug_marker), object must be a Vulkan object of the type associated with objectType as defined in VkDebugReportObjectTypeEXT and Vulkan Handle Relationship.
VUID-VkDebugMarkerObjectNameInfoEXT-objectType-01490,N,None,explicit,VkDebugMarkerObjectNameInfoEXT,(VK_EXT_debug_marker), objectType must not be VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT
VUID-VkDebugMarkerObjectNameInfoEXT-objectType-parameter,Y,None,implicit,VkDebugMarkerObjectNameInfoEXT,(VK_EXT_debug_marker), objectType must be a valid VkDebugReportObjectTypeEXT value
VUID-VkDebugMarkerObjectNameInfoEXT-pNext-pNext,Y,None,implicit,VkDebugMarkerObjectNameInfoEXT,(VK_EXT_debug_marker), pNext must be NULL
VUID-VkDebugMarkerObjectNameInfoEXT-pObjectName-parameter,Y,None,implicit,VkDebugMarkerObjectNameInfoEXT,(VK_EXT_debug_marker), pObjectName must be a null-terminated UTF-8 string
VUID-VkDebugMarkerObjectNameInfoEXT-sType-sType,Y,None,implicit,VkDebugMarkerObjectNameInfoEXT,(VK_EXT_debug_marker), sType must be VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT
VUID-VkDebugMarkerObjectTagInfoEXT-object-01494,N,None,explicit,VkDebugMarkerObjectTagInfoEXT,(VK_EXT_debug_marker), object must not be VK_NULL_HANDLE
VUID-VkDebugMarkerObjectTagInfoEXT-object-01495,N,None,explicit,VkDebugMarkerObjectTagInfoEXT,(VK_EXT_debug_marker), object must be a Vulkan object of the type associated with objectType as defined in VkDebugReportObjectTypeEXT and Vulkan Handle Relationship.
VUID-VkDebugMarkerObjectTagInfoEXT-objectType-01493,N,None,explicit,VkDebugMarkerObjectTagInfoEXT,(VK_EXT_debug_marker), objectType must not be VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT
VUID-VkDebugMarkerObjectTagInfoEXT-objectType-parameter,Y,None,implicit,VkDebugMarkerObjectTagInfoEXT,(VK_EXT_debug_marker), objectType must be a valid VkDebugReportObjectTypeEXT value
VUID-VkDebugMarkerObjectTagInfoEXT-pNext-pNext,Y,None,implicit,VkDebugMarkerObjectTagInfoEXT,(VK_EXT_debug_marker), pNext must be NULL
VUID-VkDebugMarkerObjectTagInfoEXT-pTag-parameter,Y,None,implicit,VkDebugMarkerObjectTagInfoEXT,(VK_EXT_debug_marker), pTag must be a valid pointer to an array of tagSize bytes
VUID-VkDebugMarkerObjectTagInfoEXT-sType-sType,Y,None,implicit,VkDebugMarkerObjectTagInfoEXT,(VK_EXT_debug_marker), sType must be VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT
VUID-VkDebugMarkerObjectTagInfoEXT-tagSize-arraylength,Y,None,implicit,VkDebugMarkerObjectTagInfoEXT,(VK_EXT_debug_marker), tagSize must be greater than 0
VUID-VkDebugReportCallbackCreateInfoEXT-flags-parameter,Y,None,implicit,VkDebugReportCallbackCreateInfoEXT,(VK_EXT_debug_report), flags must be a valid combination of VkDebugReportFlagBitsEXT values
VUID-VkDebugReportCallbackCreateInfoEXT-pfnCallback-01385,N,None,explicit,VkDebugReportCallbackCreateInfoEXT,(VK_EXT_debug_report), pfnCallback must be a valid PFN_vkDebugReportCallbackEXT
VUID-VkDebugReportCallbackCreateInfoEXT-sType-sType,Y,None,implicit,VkDebugReportCallbackCreateInfoEXT,(VK_EXT_debug_report), sType must be VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT
VUID-VkDebugUtilsLabelEXT-pLabelName-parameter,Y,None,implicit,VkDebugUtilsLabelEXT,(VK_EXT_debug_utils), pLabelName must be a null-terminated UTF-8 string
VUID-VkDebugUtilsLabelEXT-pNext-pNext,Y,None,implicit,VkDebugUtilsLabelEXT,(VK_EXT_debug_utils), pNext must be NULL
VUID-VkDebugUtilsLabelEXT-sType-sType,Y,None,implicit,VkDebugUtilsLabelEXT,(VK_EXT_debug_utils), sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT
VUID-VkDebugUtilsMessengerCallbackDataEXT-flags-zerobitmask,Y,None,implicit,VkDebugUtilsMessengerCallbackDataEXT,(VK_EXT_debug_utils), flags must be 0
VUID-VkDebugUtilsMessengerCallbackDataEXT-objectCount-arraylength,N,None,implicit,VkDebugUtilsMessengerCallbackDataEXT,(VK_EXT_debug_utils), objectCount must be greater than 0
VUID-VkDebugUtilsMessengerCallbackDataEXT-pMessage-parameter,Y,None,implicit,VkDebugUtilsMessengerCallbackDataEXT,(VK_EXT_debug_utils), pMessage must be a null-terminated UTF-8 string
VUID-VkDebugUtilsMessengerCallbackDataEXT-pMessageIdName-parameter,N,None,implicit,VkDebugUtilsMessengerCallbackDataEXT,(VK_EXT_debug_utils)," If pMessageIdName is not NULL, pMessageIdName must be a null-terminated UTF-8 string"
VUID-VkDebugUtilsMessengerCallbackDataEXT-pNext-pNext,Y,None,implicit,VkDebugUtilsMessengerCallbackDataEXT,(VK_EXT_debug_utils), pNext must be NULL
VUID-VkDebugUtilsMessengerCallbackDataEXT-sType-sType,Y,None,implicit,VkDebugUtilsMessengerCallbackDataEXT,(VK_EXT_debug_utils), sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT
VUID-VkDebugUtilsMessengerCreateInfoEXT-flags-zerobitmask,Y,None,implicit,VkDebugUtilsMessengerCreateInfoEXT,(VK_EXT_debug_utils), flags must be 0
VUID-VkDebugUtilsMessengerCreateInfoEXT-messageSeverity-parameter,N,None,implicit,VkDebugUtilsMessengerCreateInfoEXT,(VK_EXT_debug_utils), messageSeverity must be a valid combination of VkDebugUtilsMessageSeverityFlagBitsEXT values
VUID-VkDebugUtilsMessengerCreateInfoEXT-messageSeverity-requiredbitmask,Y,None,implicit,VkDebugUtilsMessengerCreateInfoEXT,(VK_EXT_debug_utils), messageSeverity must not be 0
VUID-VkDebugUtilsMessengerCreateInfoEXT-messageType-parameter,N,None,implicit,VkDebugUtilsMessengerCreateInfoEXT,(VK_EXT_debug_utils), messageType must be a valid combination of VkDebugUtilsMessageTypeFlagBitsEXT values
VUID-VkDebugUtilsMessengerCreateInfoEXT-messageType-requiredbitmask,Y,None,implicit,VkDebugUtilsMessengerCreateInfoEXT,(VK_EXT_debug_utils), messageType must not be 0
VUID-VkDebugUtilsMessengerCreateInfoEXT-pfnUserCallback-01914,N,None,explicit,VkDebugUtilsMessengerCreateInfoEXT,(VK_EXT_debug_utils), pfnUserCallback must be a valid PFN_vkDebugUtilsMessengerCallbackEXT
VUID-VkDebugUtilsMessengerCreateInfoEXT-sType-sType,Y,None,implicit,VkDebugUtilsMessengerCreateInfoEXT,(VK_EXT_debug_utils), sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT
VUID-VkDebugUtilsObjectNameInfoEXT-objectHandle-01906,N,None,explicit,VkDebugUtilsObjectNameInfoEXT,(VK_EXT_debug_utils), objectHandle must not be VK_NULL_HANDLE
VUID-VkDebugUtilsObjectNameInfoEXT-objectHandle-01907,N,None,explicit,VkDebugUtilsObjectNameInfoEXT,(VK_EXT_debug_utils), objectHandle must be a Vulkan object of the type associated with objectType as defined in VkObjectType and Vulkan Handle Relationship.
VUID-VkDebugUtilsObjectNameInfoEXT-objectType-01905,N,None,explicit,VkDebugUtilsObjectNameInfoEXT,(VK_EXT_debug_utils), objectType must not be VK_OBJECT_TYPE_UNKNOWN
VUID-VkDebugUtilsObjectNameInfoEXT-objectType-parameter,Y,None,implicit,VkDebugUtilsObjectNameInfoEXT,(VK_EXT_debug_utils), objectType must be a valid VkObjectType value
VUID-VkDebugUtilsObjectNameInfoEXT-pNext-pNext,Y,None,implicit,VkDebugUtilsObjectNameInfoEXT,(VK_EXT_debug_utils), pNext must be NULL
VUID-VkDebugUtilsObjectNameInfoEXT-pObjectName-parameter,N,None,implicit,VkDebugUtilsObjectNameInfoEXT,(VK_EXT_debug_utils)," If pObjectName is not NULL, pObjectName must be a null-terminated UTF-8 string"
VUID-VkDebugUtilsObjectNameInfoEXT-sType-sType,Y,None,implicit,VkDebugUtilsObjectNameInfoEXT,(VK_EXT_debug_utils), sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT
VUID-VkDebugUtilsObjectTagInfoEXT-objectHandle-01909,N,None,explicit,VkDebugUtilsObjectTagInfoEXT,(VK_EXT_debug_utils), objectHandle must not be VK_NULL_HANDLE
VUID-VkDebugUtilsObjectTagInfoEXT-objectHandle-01910,N,None,explicit,VkDebugUtilsObjectTagInfoEXT,(VK_EXT_debug_utils), objectHandle must be a Vulkan object of the type associated with objectType as defined in VkObjectType and Vulkan Handle Relationship.
VUID-VkDebugUtilsObjectTagInfoEXT-objectType-01908,N,None,explicit,VkDebugUtilsObjectTagInfoEXT,(VK_EXT_debug_utils), objectType must not be VK_OBJECT_TYPE_UNKNOWN
VUID-VkDebugUtilsObjectTagInfoEXT-objectType-parameter,Y,None,implicit,VkDebugUtilsObjectTagInfoEXT,(VK_EXT_debug_utils), objectType must be a valid VkObjectType value
VUID-VkDebugUtilsObjectTagInfoEXT-pNext-pNext,Y,None,implicit,VkDebugUtilsObjectTagInfoEXT,(VK_EXT_debug_utils), pNext must be NULL
VUID-VkDebugUtilsObjectTagInfoEXT-pTag-parameter,Y,None,implicit,VkDebugUtilsObjectTagInfoEXT,(VK_EXT_debug_utils), pTag must be a valid pointer to an array of tagSize bytes
VUID-VkDebugUtilsObjectTagInfoEXT-sType-sType,Y,None,implicit,VkDebugUtilsObjectTagInfoEXT,(VK_EXT_debug_utils), sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT
VUID-VkDebugUtilsObjectTagInfoEXT-tagSize-arraylength,Y,None,implicit,VkDebugUtilsObjectTagInfoEXT,(VK_EXT_debug_utils), tagSize must be greater than 0
VUID-VkDedicatedAllocationBufferCreateInfoNV-sType-sType,N,None,implicit,VkDedicatedAllocationBufferCreateInfoNV,(VK_NV_dedicated_allocation), sType must be VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV
VUID-VkDedicatedAllocationImageCreateInfoNV-dedicatedAllocation-00994,N,None,explicit,VkDedicatedAllocationImageCreateInfoNV,(VK_NV_dedicated_allocation)," If dedicatedAllocation is VK_TRUE, VkImageCreateInfo::flags must not include VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT"
VUID-VkDedicatedAllocationImageCreateInfoNV-sType-sType,N,None,implicit,VkDedicatedAllocationImageCreateInfoNV,(VK_NV_dedicated_allocation), sType must be VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV
VUID-VkDedicatedAllocationMemoryAllocateInfoNV-buffer-00651,N,None,explicit,VkDedicatedAllocationMemoryAllocateInfoNV,(VK_NV_dedicated_allocation)," If buffer is not VK_NULL_HANDLE, the buffer must have been created with VkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocation equal to VK_TRUE"
VUID-VkDedicatedAllocationMemoryAllocateInfoNV-buffer-00653,N,None,explicit,VkDedicatedAllocationMemoryAllocateInfoNV,(VK_NV_dedicated_allocation)," If buffer is not VK_NULL_HANDLE, VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the buffer"
VUID-VkDedicatedAllocationMemoryAllocateInfoNV-buffer-00655,N,None,explicit,VkDedicatedAllocationMemoryAllocateInfoNV,"(VK_NV_dedicated_allocation)+(VK_KHR_external_memory_win32,VK_KHR_external_memory_fd)"," If buffer is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation, the memory being imported must also be a dedicated buffer allocation and buffer must be identical to the buffer associated with the imported memory."
VUID-VkDedicatedAllocationMemoryAllocateInfoNV-buffer-parameter,N,None,implicit,VkDedicatedAllocationMemoryAllocateInfoNV,(VK_NV_dedicated_allocation)," If buffer is not VK_NULL_HANDLE, buffer must be a valid VkBuffer handle"
VUID-VkDedicatedAllocationMemoryAllocateInfoNV-commonparent,N,None,implicit,VkDedicatedAllocationMemoryAllocateInfoNV,(VK_NV_dedicated_allocation)," Both of buffer, and image that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkDedicatedAllocationMemoryAllocateInfoNV-image-00649,N,None,explicit,VkDedicatedAllocationMemoryAllocateInfoNV,(VK_NV_dedicated_allocation), At least one of image and buffer must be VK_NULL_HANDLE
VUID-VkDedicatedAllocationMemoryAllocateInfoNV-image-00650,N,None,explicit,VkDedicatedAllocationMemoryAllocateInfoNV,(VK_NV_dedicated_allocation)," If image is not VK_NULL_HANDLE, the image must have been created with VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation equal to VK_TRUE"
VUID-VkDedicatedAllocationMemoryAllocateInfoNV-image-00652,N,None,explicit,VkDedicatedAllocationMemoryAllocateInfoNV,(VK_NV_dedicated_allocation)," If image is not VK_NULL_HANDLE, VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the image"
VUID-VkDedicatedAllocationMemoryAllocateInfoNV-image-00654,N,None,explicit,VkDedicatedAllocationMemoryAllocateInfoNV,"(VK_NV_dedicated_allocation)+(VK_KHR_external_memory_win32,VK_KHR_external_memory_fd)"," If image is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation, the memory being imported must also be a dedicated image allocation and image must be identical to the image associated with the imported memory."
VUID-VkDedicatedAllocationMemoryAllocateInfoNV-image-parameter,N,None,implicit,VkDedicatedAllocationMemoryAllocateInfoNV,(VK_NV_dedicated_allocation)," If image is not VK_NULL_HANDLE, image must be a valid VkImage handle"
VUID-VkDedicatedAllocationMemoryAllocateInfoNV-sType-sType,N,None,implicit,VkDedicatedAllocationMemoryAllocateInfoNV,(VK_NV_dedicated_allocation), sType must be VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV
VUID-VkDescriptorAccelerationStructureInfoNVX-accelerationStructureCount-02236,N,None,explicit,VkDescriptorAccelerationStructureInfoNVX,(VK_NVX_raytracing), accelerationStructureCount must be equal to descriptorCount in the extended structure.
VUID-VkDescriptorAccelerationStructureInfoNVX-accelerationStructureCount-arraylength,N,None,implicit,VkDescriptorAccelerationStructureInfoNVX,(VK_NVX_raytracing), accelerationStructureCount must be greater than 0
VUID-VkDescriptorAccelerationStructureInfoNVX-pAccelerationStructures-parameter,N,None,implicit,VkDescriptorAccelerationStructureInfoNVX,(VK_NVX_raytracing), pAccelerationStructures must be a valid pointer to an array of accelerationStructureCount valid VkAccelerationStructureNVX handles
VUID-VkDescriptorAccelerationStructureInfoNVX-sType-sType,N,None,implicit,VkDescriptorAccelerationStructureInfoNVX,(VK_NVX_raytracing), sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_ACCELERATION_STRUCTURE_INFO_NVX
VUID-VkDescriptorBufferInfo-buffer-parameter,Y,None,implicit,VkDescriptorBufferInfo,core, buffer must be a valid VkBuffer handle
VUID-VkDescriptorBufferInfo-offset-00340,Y,DSBufferInfoErrors,explicit,VkDescriptorBufferInfo,core, offset must be less than the size of buffer
VUID-VkDescriptorBufferInfo-range-00341,Y,DSBufferInfoErrors,explicit,VkDescriptorBufferInfo,core," If range is not equal to VK_WHOLE_SIZE, range must be greater than 0"
VUID-VkDescriptorBufferInfo-range-00342,Y,DSBufferInfoErrors,explicit,VkDescriptorBufferInfo,core," If range is not equal to VK_WHOLE_SIZE, range must be less than or equal to the size of buffer minus offset"
VUID-VkDescriptorImageInfo-commonparent,Y,None,implicit,VkDescriptorImageInfo,core," Both of imageView, and sampler that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkDescriptorImageInfo-imageLayout-00344,Y,ImageDescriptorLayoutMismatchInternal,explicit,VkDescriptorImageInfo,core, imageLayout must match the actual VkImageLayout of each subresource accessible from imageView at the time this descriptor is accessed as defined by the image layout matching rules
VUID-VkDescriptorImageInfo-imageView-00343,Y,Maint1BindingSliceOf3DImage,explicit,VkDescriptorImageInfo,"(VK_VERSION_1_1,VK_KHR_maintenance1)", imageView must not be 2D or 2D array image view created from a 3D image
VUID-VkDescriptorImageInfo-imageView-01976,N,None,explicit,VkDescriptorImageInfo,core," If imageView is created from a depth/stencil image, the aspectMask used to create the imageView must include either VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT but not both."
VUID-VkDescriptorImageInfo-sampler-01564,N,None,explicit,VkDescriptorImageInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If sampler is used and the VkFormat of the image is a multi-planar format, the image must have been created with VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, and the aspectMask of the imageView must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT or (for three-plane formats only) VK_IMAGE_ASPECT_PLANE_2_BIT"
VUID-VkDescriptorPoolCreateInfo-flags-parameter,Y,None,implicit,VkDescriptorPoolCreateInfo,core, flags must be a valid combination of VkDescriptorPoolCreateFlagBits values
VUID-VkDescriptorPoolCreateInfo-maxSets-00301,Y,InvalidCreateDescriptorPool,explicit,VkDescriptorPoolCreateInfo,core, maxSets must be greater than 0
VUID-VkDescriptorPoolCreateInfo-pNext-pNext,Y,None,implicit,VkDescriptorPoolCreateInfo,core, pNext must be NULL or a pointer to a valid instance of VkDescriptorPoolInlineUniformBlockCreateInfoEXT
VUID-VkDescriptorPoolCreateInfo-pPoolSizes-parameter,Y,None,implicit,VkDescriptorPoolCreateInfo,core, pPoolSizes must be a valid pointer to an array of poolSizeCount valid VkDescriptorPoolSize structures
VUID-VkDescriptorPoolCreateInfo-poolSizeCount-arraylength,Y,None,implicit,VkDescriptorPoolCreateInfo,core, poolSizeCount must be greater than 0
VUID-VkDescriptorPoolCreateInfo-sType-sType,Y,None,implicit,VkDescriptorPoolCreateInfo,core, sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO
VUID-VkDescriptorPoolInlineUniformBlockCreateInfoEXT-sType-sType,N,None,implicit,VkDescriptorPoolInlineUniformBlockCreateInfoEXT,(VK_EXT_inline_uniform_block), sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT
VUID-VkDescriptorPoolSize-descriptorCount-00302,Y,InvalidCreateDescriptorPool,explicit,VkDescriptorPoolSize,core, descriptorCount must be greater than 0
VUID-VkDescriptorPoolSize-type-02218,Y,InlineUniformBlockEXT,explicit,VkDescriptorPoolSize,(VK_EXT_inline_uniform_block), If type is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then descriptorCount must be a multiple of 4
VUID-VkDescriptorPoolSize-type-parameter,Y,None,implicit,VkDescriptorPoolSize,core, type must be a valid VkDescriptorType value
VUID-VkDescriptorSetAllocateInfo-commonparent,Y,None,implicit,VkDescriptorSetAllocateInfo,core," Both of descriptorPool, and the elements of pSetLayouts must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkDescriptorSetAllocateInfo-descriptorPool-00307,Y,AllocDescriptorFromEmptyPool,explicit,VkDescriptorSetAllocateInfo,"!(VK_VERSION_1_1,VK_KHR_maintenance1)", descriptorPool must have enough free descriptor capacity remaining to allocate the descriptor sets of the specified layouts
VUID-VkDescriptorSetAllocateInfo-descriptorPool-parameter,Y,None,implicit,VkDescriptorSetAllocateInfo,core, descriptorPool must be a valid VkDescriptorPool handle
VUID-VkDescriptorSetAllocateInfo-descriptorSetCount-00306,Y,AllocDescriptorFromEmptyPool,explicit,VkDescriptorSetAllocateInfo,"!(VK_VERSION_1_1,VK_KHR_maintenance1)", descriptorSetCount must not be greater than the number of sets that are currently available for allocation in descriptorPool
VUID-VkDescriptorSetAllocateInfo-descriptorSetCount-arraylength,N,None,implicit,VkDescriptorSetAllocateInfo,core, descriptorSetCount must be greater than 0
VUID-VkDescriptorSetAllocateInfo-pNext-pNext,Y,None,implicit,VkDescriptorSetAllocateInfo,core, pNext must be NULL or a pointer to a valid instance of VkDescriptorSetVariableDescriptorCountAllocateInfoEXT
VUID-VkDescriptorSetAllocateInfo-pSetLayouts-00308,Y,AllocatePushDescriptorSet,explicit,VkDescriptorSetAllocateInfo,(VK_KHR_push_descriptor), Each element of pSetLayouts must not have been created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR set
VUID-VkDescriptorSetAllocateInfo-pSetLayouts-03044,Y,DescriptorIndexingSetLayout,explicit,VkDescriptorSetAllocateInfo,(VK_EXT_descriptor_indexing)," If any element of pSetLayouts was created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set, descriptorPool must have been created with the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT flag set"
VUID-VkDescriptorSetAllocateInfo-pSetLayouts-parameter,Y,None,implicit,VkDescriptorSetAllocateInfo,core, pSetLayouts must be a valid pointer to an array of descriptorSetCount valid VkDescriptorSetLayout handles
VUID-VkDescriptorSetAllocateInfo-sType-sType,Y,None,implicit,VkDescriptorSetAllocateInfo,core, sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO
VUID-VkDescriptorSetLayoutBinding-descriptorCount-00283,Y,None,explicit,VkDescriptorSetLayoutBinding,core," If descriptorCount is not 0, stageFlags must be a valid combination of VkShaderStageFlagBits values"
VUID-VkDescriptorSetLayoutBinding-descriptorType-00282,Y,None,explicit,VkDescriptorSetLayoutBinding,core," If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and descriptorCount is not 0 and pImmutableSamplers is not NULL, pImmutableSamplers must be a valid pointer to an array of descriptorCount valid VkSampler handles"
VUID-VkDescriptorSetLayoutBinding-descriptorType-01510,N,None,explicit,VkDescriptorSetLayoutBinding,core," If descriptorType is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT and descriptorCount is not 0, then stageFlags must be 0 or VK_SHADER_STAGE_FRAGMENT_BIT"
VUID-VkDescriptorSetLayoutBinding-descriptorType-02209,Y,InlineUniformBlockEXT,explicit,VkDescriptorSetLayoutBinding,(VK_EXT_inline_uniform_block), If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then descriptorCount must be a multiple of 4
VUID-VkDescriptorSetLayoutBinding-descriptorType-02210,Y,InlineUniformBlockEXT,explicit,VkDescriptorSetLayoutBinding,(VK_EXT_inline_uniform_block), If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then descriptorCount must be less than or equal to VkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxInlineUniformBlockSize
VUID-VkDescriptorSetLayoutBinding-descriptorType-parameter,Y,None,implicit,VkDescriptorSetLayoutBinding,core, descriptorType must be a valid VkDescriptorType value
VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-None-03011,Y,None,explicit,VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,(VK_EXT_descriptor_indexing)," All bindings with descriptor type VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT"
VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-bindingCount-03002,Y,DescriptorIndexingSetLayout,explicit,VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,(VK_EXT_descriptor_indexing)," If bindingCount is not zero, bindingCount must equal VkDescriptorSetLayoutCreateInfo::bindingCount"
VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingInlineUniformBlockUpdateAfterBind-02211,Y,None,explicit,VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,(VK_EXT_descriptor_indexing)+(VK_EXT_inline_uniform_block)," If VkPhysicalDeviceInlineUniformBlockFeatureEXT::descriptorBindingInlineUniformBlockUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT"
VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingPartiallyBound-03013,Y,None,explicit,VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,(VK_EXT_descriptor_indexing)," If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingPartiallyBound is not enabled, all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT"
VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingSampledImageUpdateAfterBind-03006,Y,None,explicit,VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,(VK_EXT_descriptor_indexing)," If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingSampledImageUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_SAMPLER, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT"
VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingStorageBufferUpdateAfterBind-03008,Y,None,explicit,VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,(VK_EXT_descriptor_indexing)," If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingStorageBufferUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT"
VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingStorageImageUpdateAfterBind-03007,Y,None,explicit,VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,(VK_EXT_descriptor_indexing)," If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingStorageImageUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT"
VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingStorageTexelBufferUpdateAfterBind-03010,Y,None,explicit,VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,(VK_EXT_descriptor_indexing)," If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingStorageTexelBufferUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT"
VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingUniformBufferUpdateAfterBind-03005,Y,DescriptorIndexingSetLayout,explicit,VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,(VK_EXT_descriptor_indexing)," If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingUniformBufferUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT"
VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingUniformTexelBufferUpdateAfterBind-03009,Y,None,explicit,VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,(VK_EXT_descriptor_indexing)," If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingUniformTexelBufferUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT"
VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingUpdateUnusedWhilePending-03012,Y,None,explicit,VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,(VK_EXT_descriptor_indexing)," If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingUpdateUnusedWhilePending is not enabled, all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT"
VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-descriptorBindingVariableDescriptorCount-03014,Y,None,explicit,VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,(VK_EXT_descriptor_indexing)," If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingVariableDescriptorCount is not enabled, all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT"
VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-flags-03003,Y,None,explicit,VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,(VK_EXT_descriptor_indexing)+(VK_KHR_push_descriptor)," If VkDescriptorSetLayoutCreateInfo::flags includes VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT, VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT, or VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT"
VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-pBindingFlags-03004,Y,None,explicit,VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,(VK_EXT_descriptor_indexing)," If an element of pBindingFlags includes VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT, then all other elements of VkDescriptorSetLayoutCreateInfo::pBindings must have a smaller value of binding"
VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-pBindingFlags-03015,Y,None,explicit,VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,(VK_EXT_descriptor_indexing)," If an element of pBindingFlags includes VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT, that element's descriptorType must not be VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC"
VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-pBindingFlags-parameter,N,None,implicit,VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,(VK_EXT_descriptor_indexing)," If bindingCount is not 0, and pBindingFlags is not NULL, pBindingFlags must be a valid pointer to an array of bindingCount valid combinations of VkDescriptorBindingFlagBitsEXT values"
VUID-VkDescriptorSetLayoutBindingFlagsCreateInfoEXT-sType-sType,N,None,implicit,VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,(VK_EXT_descriptor_indexing), sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT
VUID-VkDescriptorSetLayoutCreateInfo-binding-00279,Y,DuplicateDescriptorBinding,explicit,VkDescriptorSetLayoutCreateInfo,core, The VkDescriptorSetLayoutBinding::binding members of the elements of the pBindings array must each have different values.
VUID-VkDescriptorSetLayoutCreateInfo-descriptorType-03001,N,None,explicit,VkDescriptorSetLayoutCreateInfo,(VK_EXT_descriptor_indexing)," If any binding has the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT bit set, then all bindings must not have descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC"
VUID-VkDescriptorSetLayoutCreateInfo-flags-00280,Y,InvalidPushDescriptorSetLayout,explicit,VkDescriptorSetLayoutCreateInfo,(VK_KHR_push_descriptor)," If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then all elements of pBindings must not have a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC"
VUID-VkDescriptorSetLayoutCreateInfo-flags-00281,Y,"PushDescriptorSetLayoutWithoutExtension, InvalidPushDescriptorSetLayout",explicit,VkDescriptorSetLayoutCreateInfo,(VK_KHR_push_descriptor)," If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then the total number of elements of all bindings must be less than or equal to VkPhysicalDevicePushDescriptorPropertiesKHR::maxPushDescriptors"
VUID-VkDescriptorSetLayoutCreateInfo-flags-02208,Y,None,explicit,VkDescriptorSetLayoutCreateInfo,(VK_KHR_push_descriptor)+(VK_EXT_inline_uniform_block)," If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then all elements of pBindings must not have a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT"
VUID-VkDescriptorSetLayoutCreateInfo-flags-03000,Y,DescriptorIndexingSetLayout,explicit,VkDescriptorSetLayoutCreateInfo,(VK_EXT_descriptor_indexing)," If any binding has the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT bit set, flags must include VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT"
VUID-VkDescriptorSetLayoutCreateInfo-flags-parameter,Y,None,implicit,VkDescriptorSetLayoutCreateInfo,core, flags must be a valid combination of VkDescriptorSetLayoutCreateFlagBits values
VUID-VkDescriptorSetLayoutCreateInfo-pBindings-parameter,Y,None,implicit,VkDescriptorSetLayoutCreateInfo,core," If bindingCount is not 0, pBindings must be a valid pointer to an array of bindingCount valid VkDescriptorSetLayoutBinding structures"
VUID-VkDescriptorSetLayoutCreateInfo-pNext-pNext,Y,None,implicit,VkDescriptorSetLayoutCreateInfo,core, pNext must be NULL or a pointer to a valid instance of VkDescriptorSetLayoutBindingFlagsCreateInfoEXT
VUID-VkDescriptorSetLayoutCreateInfo-sType-sType,Y,None,implicit,VkDescriptorSetLayoutCreateInfo,core, sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO
VUID-VkDescriptorSetLayoutSupport-pNext-pNext,Y,None,implicit,VkDescriptorSetLayoutSupport,"(VK_VERSION_1_1,VK_KHR_maintenance3)", pNext must be NULL or a pointer to a valid instance of VkDescriptorSetVariableDescriptorCountLayoutSupportEXT
VUID-VkDescriptorSetLayoutSupport-sType-sType,Y,None,implicit,VkDescriptorSetLayoutSupport,"(VK_VERSION_1_1,VK_KHR_maintenance3)", sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT
VUID-VkDescriptorSetVariableDescriptorCountAllocateInfoEXT-descriptorSetCount-03045,Y,None,explicit,VkDescriptorSetVariableDescriptorCountAllocateInfoEXT,(VK_EXT_descriptor_indexing)," If descriptorSetCount is not zero, descriptorSetCount must equal VkDescriptorSetAllocateInfo::descriptorSetCount"
VUID-VkDescriptorSetVariableDescriptorCountAllocateInfoEXT-pDescriptorCounts-parameter,Y,None,implicit,VkDescriptorSetVariableDescriptorCountAllocateInfoEXT,(VK_EXT_descriptor_indexing)," If descriptorSetCount is not 0, pDescriptorCounts must be a valid pointer to an array of descriptorSetCount uint32_t values"
VUID-VkDescriptorSetVariableDescriptorCountAllocateInfoEXT-pSetLayouts-03046,Y,DescriptorIndexingSetLayout,explicit,VkDescriptorSetVariableDescriptorCountAllocateInfoEXT,(VK_EXT_descriptor_indexing)," If VkDescriptorSetAllocateInfo::pSetLayouts[i] has a variable descriptor count binding, then pDescriptorCounts[i] must be less than or equal to the descriptor count specified for that binding when the descriptor set layout was created."
VUID-VkDescriptorSetVariableDescriptorCountAllocateInfoEXT-sType-sType,N,None,implicit,VkDescriptorSetVariableDescriptorCountAllocateInfoEXT,(VK_EXT_descriptor_indexing), sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT
VUID-VkDescriptorSetVariableDescriptorCountLayoutSupportEXT-sType-sType,N,None,implicit,VkDescriptorSetVariableDescriptorCountLayoutSupportEXT,(VK_EXT_descriptor_indexing), sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT
VUID-VkDescriptorUpdateTemplateCreateInfo-commonparent,Y,None,implicit,VkDescriptorUpdateTemplateCreateInfo,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)"," Both of descriptorSetLayout, and pipelineLayout that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkDescriptorUpdateTemplateCreateInfo-descriptorSetLayout-parameter,Y,None,implicit,VkDescriptorUpdateTemplateCreateInfo,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)"," If descriptorSetLayout is not VK_NULL_HANDLE, descriptorSetLayout must be a valid VkDescriptorSetLayout handle"
VUID-VkDescriptorUpdateTemplateCreateInfo-descriptorUpdateEntryCount-arraylength,Y,None,implicit,VkDescriptorUpdateTemplateCreateInfo,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", descriptorUpdateEntryCount must be greater than 0
VUID-VkDescriptorUpdateTemplateCreateInfo-flags-zerobitmask,Y,None,implicit,VkDescriptorUpdateTemplateCreateInfo,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", flags must be 0
VUID-VkDescriptorUpdateTemplateCreateInfo-pDescriptorUpdateEntries-parameter,Y,None,implicit,VkDescriptorUpdateTemplateCreateInfo,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", pDescriptorUpdateEntries must be a valid pointer to an array of descriptorUpdateEntryCount valid VkDescriptorUpdateTemplateEntry structures
VUID-VkDescriptorUpdateTemplateCreateInfo-pNext-pNext,Y,None,implicit,VkDescriptorUpdateTemplateCreateInfo,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", pNext must be NULL
VUID-VkDescriptorUpdateTemplateCreateInfo-sType-sType,Y,None,implicit,VkDescriptorUpdateTemplateCreateInfo,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO
VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00350,Y,CreateDescriptorUpdateTemplate,explicit,VkDescriptorUpdateTemplateCreateInfo,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)"," If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET, descriptorSetLayout must be a valid VkDescriptorSetLayout handle"
VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00351,Y,CreateDescriptorUpdateTemplate,explicit,VkDescriptorUpdateTemplateCreateInfo,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)+(VK_KHR_push_descriptor)"," If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR, pipelineBindPoint must be a valid VkPipelineBindPoint value"
VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00352,Y,CreateDescriptorUpdateTemplate,explicit,VkDescriptorUpdateTemplateCreateInfo,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)+(VK_KHR_push_descriptor)"," If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR, pipelineLayout must be a valid VkPipelineLayout handle"
VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00353,Y,CreateDescriptorUpdateTemplate,explicit,VkDescriptorUpdateTemplateCreateInfo,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)+(VK_KHR_push_descriptor)"," If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR, set must be the unique set number in the pipeline layout that uses a descriptor set layout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR"
VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-parameter,Y,None,implicit,VkDescriptorUpdateTemplateCreateInfo,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", templateType must be a valid VkDescriptorUpdateTemplateType value
VUID-VkDescriptorUpdateTemplateEntry-descriptor-02226,N,None,explicit,VkDescriptorUpdateTemplateEntry,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)+(VK_EXT_inline_uniform_block)"," If descriptor type is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, dstArrayElement must be an integer multiple of 4"
VUID-VkDescriptorUpdateTemplateEntry-descriptor-02227,N,None,explicit,VkDescriptorUpdateTemplateEntry,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)+(VK_EXT_inline_uniform_block)"," If descriptor type is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, descriptorCount must be an integer multiple of 4"
VUID-VkDescriptorUpdateTemplateEntry-descriptorType-parameter,Y,None,implicit,VkDescriptorUpdateTemplateEntry,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", descriptorType must be a valid VkDescriptorType value
VUID-VkDescriptorUpdateTemplateEntry-dstArrayElement-00355,N,None,explicit,VkDescriptorUpdateTemplateEntry,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)"," dstArrayElement and descriptorCount must be less than or equal to the number of array elements in the descriptor set binding implicitly specified when using a descriptor update template to update descriptors, and all applicable consecutive bindings, as described by consecutive binding updates"
VUID-VkDescriptorUpdateTemplateEntry-dstBinding-00354,N,None,explicit,VkDescriptorUpdateTemplateEntry,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", dstBinding must be a valid binding in the descriptor set layout implicitly specified when using a descriptor update template to update descriptors.
VUID-VkDeviceCreateInfo-flags-zerobitmask,Y,None,implicit,VkDeviceCreateInfo,core, flags must be 0
VUID-VkDeviceCreateInfo-pEnabledFeatures-parameter,N,None,implicit,VkDeviceCreateInfo,core," If pEnabledFeatures is not NULL, pEnabledFeatures must be a valid pointer to a valid VkPhysicalDeviceFeatures structure"
VUID-VkDeviceCreateInfo-pNext-00373,N,None,explicit,VkDeviceCreateInfo,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)"," If the pNext chain includes a VkPhysicalDeviceFeatures2 structure, then pEnabledFeatures must be NULL"
VUID-VkDeviceCreateInfo-pNext-pNext,Y,None,implicit,VkDeviceCreateInfo,core," Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupDeviceCreateInfo, VkPhysicalDevice16BitStorageFeatures, VkPhysicalDevice8BitStorageFeaturesKHR, VkPhysicalDeviceASTCDecodeFeaturesEXT, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, VkPhysicalDeviceConditionalRenderingFeaturesEXT, VkPhysicalDeviceCornerSampledImageFeaturesNV, VkPhysicalDeviceDescriptorIndexingFeaturesEXT, VkPhysicalDeviceExclusiveScissorFeaturesNV, VkPhysicalDeviceFeatures2, VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV, VkPhysicalDeviceInlineUniformBlockFeaturesEXT, VkPhysicalDeviceMeshShaderFeaturesNV, VkPhysicalDeviceMultiviewFeatures, VkPhysicalDeviceProtectedMemoryFeatures, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, VkPhysicalDeviceSamplerYcbcrConversionFeatures, VkPhysicalDeviceShaderDrawParameterFeatures, VkPhysicalDeviceShaderImageFootprintFeaturesNV, VkPhysicalDeviceShadingRateImageFeaturesNV, VkPhysicalDeviceVariablePointerFeatures, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, or VkPhysicalDeviceVulkanMemoryModelFeaturesKHR"
VUID-VkDeviceCreateInfo-pQueueCreateInfos-parameter,Y,None,implicit,VkDeviceCreateInfo,core, pQueueCreateInfos must be a valid pointer to an array of queueCreateInfoCount valid VkDeviceQueueCreateInfo structures
VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-00374,Y,Maintenance1AndNegativeViewport,explicit,VkDeviceCreateInfo,(VK_AMD_negative_viewport_height)+!(VK_VERSION_1_1)+(VK_KHR_maintenance1), ppEnabledExtensionNames must not contain both VK_KHR_maintenance1 and VK_AMD_negative_viewport_height
VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-01840,N,None,explicit,VkDeviceCreateInfo,(VK_AMD_negative_viewport_height)+(VK_VERSION_1_1), ppEnabledExtensionNames must not contain VK_AMD_negative_viewport_height
VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-parameter,Y,None,implicit,VkDeviceCreateInfo,core," If enabledExtensionCount is not 0, ppEnabledExtensionNames must be a valid pointer to an array of enabledExtensionCount null-terminated UTF-8 strings"
VUID-VkDeviceCreateInfo-ppEnabledLayerNames-parameter,Y,None,implicit,VkDeviceCreateInfo,core," If enabledLayerCount is not 0, ppEnabledLayerNames must be a valid pointer to an array of enabledLayerCount null-terminated UTF-8 strings"
VUID-VkDeviceCreateInfo-queueCreateInfoCount-arraylength,N,None,implicit,VkDeviceCreateInfo,core, queueCreateInfoCount must be greater than 0
VUID-VkDeviceCreateInfo-queueFamilyIndex-00372,Y,None,explicit,VkDeviceCreateInfo,core,
VUID-VkDeviceCreateInfo-sType-sType,Y,None,implicit,VkDeviceCreateInfo,core, sType must be VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO
VUID-VkDeviceCreateInfo-sType-unique,N,None,implicit,VkDeviceCreateInfo,core, Each sType member in the pNext chain must be unique
VUID-VkDeviceEventInfoEXT-deviceEvent-parameter,Y,None,implicit,VkDeviceEventInfoEXT,(VK_EXT_display_control), deviceEvent must be a valid VkDeviceEventTypeEXT value
VUID-VkDeviceEventInfoEXT-pNext-pNext,Y,None,implicit,VkDeviceEventInfoEXT,(VK_EXT_display_control), pNext must be NULL
VUID-VkDeviceEventInfoEXT-sType-sType,Y,None,implicit,VkDeviceEventInfoEXT,(VK_EXT_display_control), sType must be VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT
VUID-VkDeviceGeneratedCommandsFeaturesNVX-pNext-pNext,N,None,implicit,VkDeviceGeneratedCommandsFeaturesNVX,(VK_NVX_device_generated_commands), pNext must be NULL
VUID-VkDeviceGeneratedCommandsFeaturesNVX-sType-sType,Y,None,implicit,VkDeviceGeneratedCommandsFeaturesNVX,(VK_NVX_device_generated_commands), sType must be VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX
VUID-VkDeviceGeneratedCommandsLimitsNVX-pNext-pNext,N,None,implicit,VkDeviceGeneratedCommandsLimitsNVX,(VK_NVX_device_generated_commands), pNext must be NULL
VUID-VkDeviceGeneratedCommandsLimitsNVX-sType-sType,Y,None,implicit,VkDeviceGeneratedCommandsLimitsNVX,(VK_NVX_device_generated_commands), sType must be VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX
VUID-VkDeviceGroupBindSparseInfo-memoryDeviceIndex-01119,N,None,explicit,VkDeviceGroupBindSparseInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", Each memory allocation bound in this batch must have allocated an instance for memoryDeviceIndex.
VUID-VkDeviceGroupBindSparseInfo-resourceDeviceIndex-01118,N,None,explicit,VkDeviceGroupBindSparseInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", resourceDeviceIndex and memoryDeviceIndex must both be valid device indices.
VUID-VkDeviceGroupBindSparseInfo-sType-sType,N,None,implicit,VkDeviceGroupBindSparseInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO
VUID-VkDeviceGroupCommandBufferBeginInfo-deviceMask-00106,N,None,explicit,VkDeviceGroupCommandBufferBeginInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", deviceMask must be a valid device mask value
VUID-VkDeviceGroupCommandBufferBeginInfo-deviceMask-00107,N,None,explicit,VkDeviceGroupCommandBufferBeginInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", deviceMask must not be zero
VUID-VkDeviceGroupCommandBufferBeginInfo-sType-sType,N,None,implicit,VkDeviceGroupCommandBufferBeginInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO
VUID-VkDeviceGroupDeviceCreateInfo-pPhysicalDevices-00375,N,None,explicit,VkDeviceGroupDeviceCreateInfo,"(VK_VERSION_1_1,VK_KHR_device_group_creation)", Each element of pPhysicalDevices must be unique
VUID-VkDeviceGroupDeviceCreateInfo-pPhysicalDevices-00376,N,None,explicit,VkDeviceGroupDeviceCreateInfo,"(VK_VERSION_1_1,VK_KHR_device_group_creation)", All elements of pPhysicalDevices must be in the same device group as enumerated by vkEnumeratePhysicalDeviceGroups
VUID-VkDeviceGroupDeviceCreateInfo-pPhysicalDevices-parameter,Y,None,implicit,VkDeviceGroupDeviceCreateInfo,"(VK_VERSION_1_1,VK_KHR_device_group_creation)"," If physicalDeviceCount is not 0, pPhysicalDevices must be a valid pointer to an array of physicalDeviceCount valid VkPhysicalDevice handles"
VUID-VkDeviceGroupDeviceCreateInfo-physicalDeviceCount-00377,N,None,explicit,VkDeviceGroupDeviceCreateInfo,"(VK_VERSION_1_1,VK_KHR_device_group_creation)"," If physicalDeviceCount is not 0, the physicalDevice parameter of vkCreateDevice must be an element of pPhysicalDevices."
VUID-VkDeviceGroupDeviceCreateInfo-sType-sType,N,None,implicit,VkDeviceGroupDeviceCreateInfo,"(VK_VERSION_1_1,VK_KHR_device_group_creation)", sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO
VUID-VkDeviceGroupPresentCapabilitiesKHR-pNext-pNext,Y,None,implicit,VkDeviceGroupPresentCapabilitiesKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", pNext must be NULL
VUID-VkDeviceGroupPresentCapabilitiesKHR-sType-sType,Y,None,implicit,VkDeviceGroupPresentCapabilitiesKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR
VUID-VkDeviceGroupPresentInfoKHR-mode-01298,N,None,explicit,VkDeviceGroupPresentInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)"," If mode is VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR, then each element of pDeviceMasks must have exactly one bit set, and the corresponding element of VkDeviceGroupPresentCapabilitiesKHR::presentMask must be non-zero"
VUID-VkDeviceGroupPresentInfoKHR-mode-01299,N,None,explicit,VkDeviceGroupPresentInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)"," If mode is VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR, then each element of pDeviceMasks must have exactly one bit set, and some physical device in the logical device must include that bit in its VkDeviceGroupPresentCapabilitiesKHR::presentMask."
VUID-VkDeviceGroupPresentInfoKHR-mode-01300,N,None,explicit,VkDeviceGroupPresentInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)"," If mode is VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR, then each element of pDeviceMasks must have a value for which all set bits are set in one of the elements of VkDeviceGroupPresentCapabilitiesKHR::presentMask"
VUID-VkDeviceGroupPresentInfoKHR-mode-01301,N,None,explicit,VkDeviceGroupPresentInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)"," If mode is VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR, then for each bit set in each element of pDeviceMasks, the corresponding element of VkDeviceGroupPresentCapabilitiesKHR::presentMask must be non-zero"
VUID-VkDeviceGroupPresentInfoKHR-mode-01303,N,None,explicit,VkDeviceGroupPresentInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)"," mode must have exactly one bit set, and that bit must have been included in VkDeviceGroupSwapchainCreateInfoKHR::modes"
VUID-VkDeviceGroupPresentInfoKHR-mode-parameter,Y,None,implicit,VkDeviceGroupPresentInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", mode must be a valid VkDeviceGroupPresentModeFlagBitsKHR value
VUID-VkDeviceGroupPresentInfoKHR-pDeviceMasks-01302,N,None,explicit,VkDeviceGroupPresentInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", The value of each element of pDeviceMasks must be equal to the device mask passed in VkAcquireNextImageInfoKHR::deviceMask when the image index was last acquired
VUID-VkDeviceGroupPresentInfoKHR-pDeviceMasks-parameter,Y,None,implicit,VkDeviceGroupPresentInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)"," If swapchainCount is not 0, pDeviceMasks must be a valid pointer to an array of swapchainCount uint32_t values"
VUID-VkDeviceGroupPresentInfoKHR-sType-sType,N,None,implicit,VkDeviceGroupPresentInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR
VUID-VkDeviceGroupPresentInfoKHR-swapchainCount-01297,N,None,explicit,VkDeviceGroupPresentInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", swapchainCount must equal 0 or VkPresentInfoKHR::swapchainCount
VUID-VkDeviceGroupRenderPassBeginInfo-deviceMask-00905,N,None,explicit,VkDeviceGroupRenderPassBeginInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", deviceMask must be a valid device mask value
VUID-VkDeviceGroupRenderPassBeginInfo-deviceMask-00906,N,None,explicit,VkDeviceGroupRenderPassBeginInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", deviceMask must not be zero
VUID-VkDeviceGroupRenderPassBeginInfo-deviceMask-00907,N,None,explicit,VkDeviceGroupRenderPassBeginInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", deviceMask must be a subset of the command buffer's initial device mask
VUID-VkDeviceGroupRenderPassBeginInfo-deviceRenderAreaCount-00908,N,None,explicit,VkDeviceGroupRenderPassBeginInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", deviceRenderAreaCount must either be zero or equal to the number of physical devices in the logical device.
VUID-VkDeviceGroupRenderPassBeginInfo-pDeviceRenderAreas-parameter,Y,None,implicit,VkDeviceGroupRenderPassBeginInfo,"(VK_VERSION_1_1,VK_KHR_device_group)"," If deviceRenderAreaCount is not 0, pDeviceRenderAreas must be a valid pointer to an array of deviceRenderAreaCount VkRect2D structures"
VUID-VkDeviceGroupRenderPassBeginInfo-sType-sType,N,None,implicit,VkDeviceGroupRenderPassBeginInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO
VUID-VkDeviceGroupSubmitInfo-commandBufferCount-00083,N,None,explicit,VkDeviceGroupSubmitInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", commandBufferCount must equal VkSubmitInfo::commandBufferCount
VUID-VkDeviceGroupSubmitInfo-pCommandBufferDeviceMasks-00086,N,None,explicit,VkDeviceGroupSubmitInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", All elements of pCommandBufferDeviceMasks must be valid device masks
VUID-VkDeviceGroupSubmitInfo-pCommandBufferDeviceMasks-parameter,Y,None,implicit,VkDeviceGroupSubmitInfo,"(VK_VERSION_1_1,VK_KHR_device_group)"," If commandBufferCount is not 0, pCommandBufferDeviceMasks must be a valid pointer to an array of commandBufferCount uint32_t values"
VUID-VkDeviceGroupSubmitInfo-pSignalSemaphoreDeviceIndices-parameter,Y,None,implicit,VkDeviceGroupSubmitInfo,"(VK_VERSION_1_1,VK_KHR_device_group)"," If signalSemaphoreCount is not 0, pSignalSemaphoreDeviceIndices must be a valid pointer to an array of signalSemaphoreCount uint32_t values"
VUID-VkDeviceGroupSubmitInfo-pWaitSemaphoreDeviceIndices-00085,N,None,explicit,VkDeviceGroupSubmitInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", All elements of pWaitSemaphoreDeviceIndices and pSignalSemaphoreDeviceIndices must be valid device indices
VUID-VkDeviceGroupSubmitInfo-pWaitSemaphoreDeviceIndices-parameter,Y,None,implicit,VkDeviceGroupSubmitInfo,"(VK_VERSION_1_1,VK_KHR_device_group)"," If waitSemaphoreCount is not 0, pWaitSemaphoreDeviceIndices must be a valid pointer to an array of waitSemaphoreCount uint32_t values"
VUID-VkDeviceGroupSubmitInfo-sType-sType,N,None,implicit,VkDeviceGroupSubmitInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO
VUID-VkDeviceGroupSubmitInfo-signalSemaphoreCount-00084,N,None,explicit,VkDeviceGroupSubmitInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", signalSemaphoreCount must equal VkSubmitInfo::signalSemaphoreCount
VUID-VkDeviceGroupSubmitInfo-waitSemaphoreCount-00082,N,None,explicit,VkDeviceGroupSubmitInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", waitSemaphoreCount must equal VkSubmitInfo::waitSemaphoreCount
VUID-VkDeviceGroupSwapchainCreateInfoKHR-modes-parameter,N,None,implicit,VkDeviceGroupSwapchainCreateInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", modes must be a valid combination of VkDeviceGroupPresentModeFlagBitsKHR values
VUID-VkDeviceGroupSwapchainCreateInfoKHR-modes-requiredbitmask,Y,None,implicit,VkDeviceGroupSwapchainCreateInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", modes must not be 0
VUID-VkDeviceGroupSwapchainCreateInfoKHR-sType-sType,N,None,implicit,VkDeviceGroupSwapchainCreateInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR
VUID-VkDeviceQueueCreateInfo-flags-parameter,Y,None,implicit,VkDeviceQueueCreateInfo,core, flags must be a valid combination of VkDeviceQueueCreateFlagBits values
VUID-VkDeviceQueueCreateInfo-pNext-pNext,Y,None,implicit,VkDeviceQueueCreateInfo,core, pNext must be NULL or a pointer to a valid instance of VkDeviceQueueGlobalPriorityCreateInfoEXT
VUID-VkDeviceQueueCreateInfo-pQueuePriorities-00383,Y,None,explicit,VkDeviceQueueCreateInfo,core, Each element of pQueuePriorities must be between 0.0 and 1.0 inclusive
VUID-VkDeviceQueueCreateInfo-pQueuePriorities-parameter,Y,None,implicit,VkDeviceQueueCreateInfo,core, pQueuePriorities must be a valid pointer to an array of queueCount float values
VUID-VkDeviceQueueCreateInfo-queueCount-00382,Y,None,explicit,VkDeviceQueueCreateInfo,core," queueCount must be less than or equal to the queueCount member of the VkQueueFamilyProperties structure, as returned by vkGetPhysicalDeviceQueueFamilyProperties in the pQueueFamilyProperties[queueFamilyIndex]"
VUID-VkDeviceQueueCreateInfo-queueCount-arraylength,Y,None,implicit,VkDeviceQueueCreateInfo,core, queueCount must be greater than 0
VUID-VkDeviceQueueCreateInfo-queueFamilyIndex-00381,Y,None,explicit,VkDeviceQueueCreateInfo,core, queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties
VUID-VkDeviceQueueCreateInfo-sType-sType,Y,None,implicit,VkDeviceQueueCreateInfo,core, sType must be VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
VUID-VkDeviceQueueGlobalPriorityCreateInfoEXT-globalPriority-parameter,Y,None,implicit,VkDeviceQueueGlobalPriorityCreateInfoEXT,(VK_EXT_global_priority), globalPriority must be a valid VkQueueGlobalPriorityEXT value
VUID-VkDeviceQueueGlobalPriorityCreateInfoEXT-sType-sType,N,None,implicit,VkDeviceQueueGlobalPriorityCreateInfoEXT,(VK_EXT_global_priority), sType must be VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT
VUID-VkDeviceQueueInfo2-flags-parameter,N,None,implicit,VkDeviceQueueInfo2,(VK_VERSION_1_1), flags must be a valid combination of VkDeviceQueueCreateFlagBits values
VUID-VkDeviceQueueInfo2-flags-requiredbitmask,Y,None,implicit,VkDeviceQueueInfo2,(VK_VERSION_1_1), flags must not be 0
VUID-VkDeviceQueueInfo2-pNext-pNext,Y,None,implicit,VkDeviceQueueInfo2,(VK_VERSION_1_1), pNext must be NULL
VUID-VkDeviceQueueInfo2-queueFamilyIndex-01842,N,None,explicit,VkDeviceQueueInfo2,(VK_VERSION_1_1)," queueFamilyIndex must be one of the queue family indices specified when device was created, via the VkDeviceQueueCreateInfo structure"
VUID-VkDeviceQueueInfo2-queueIndex-01843,N,None,explicit,VkDeviceQueueInfo2,(VK_VERSION_1_1)," queueIndex must be less than the number of queues created for the specified queue family index and VkDeviceQueueCreateFlags member flags equal to this flags value when device was created, via the queueCount member of the VkDeviceQueueCreateInfo structure"
VUID-VkDeviceQueueInfo2-sType-sType,Y,None,implicit,VkDeviceQueueInfo2,(VK_VERSION_1_1), sType must be VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2
VUID-VkDispatchIndirectCommand-x-00417,N,None,explicit,VkDispatchIndirectCommand,core, x must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0]
VUID-VkDispatchIndirectCommand-y-00418,N,None,explicit,VkDispatchIndirectCommand,core, y must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1]
VUID-VkDispatchIndirectCommand-z-00419,N,None,explicit,VkDispatchIndirectCommand,core, z must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2]
VUID-VkDisplayEventInfoEXT-displayEvent-parameter,Y,None,implicit,VkDisplayEventInfoEXT,(VK_EXT_display_control), displayEvent must be a valid VkDisplayEventTypeEXT value
VUID-VkDisplayEventInfoEXT-pNext-pNext,Y,None,implicit,VkDisplayEventInfoEXT,(VK_EXT_display_control), pNext must be NULL
VUID-VkDisplayEventInfoEXT-sType-sType,Y,None,implicit,VkDisplayEventInfoEXT,(VK_EXT_display_control), sType must be VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT
VUID-VkDisplayModeCreateInfoKHR-flags-zerobitmask,Y,None,implicit,VkDisplayModeCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_display), flags must be 0
VUID-VkDisplayModeCreateInfoKHR-pNext-pNext,Y,None,implicit,VkDisplayModeCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_display), pNext must be NULL
VUID-VkDisplayModeCreateInfoKHR-parameters-parameter,N,None,implicit,VkDisplayModeCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_display), parameters must be a valid VkDisplayModeParametersKHR structure
VUID-VkDisplayModeCreateInfoKHR-sType-sType,Y,None,implicit,VkDisplayModeCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_display), sType must be VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR
VUID-VkDisplayModeParametersKHR-height-01991,N,None,explicit,VkDisplayModeParametersKHR,(VK_KHR_surface)+(VK_KHR_display), The height member of visibleRegion must be greater than 0
VUID-VkDisplayModeParametersKHR-refreshRate-01992,N,None,explicit,VkDisplayModeParametersKHR,(VK_KHR_surface)+(VK_KHR_display), refreshRate must be greater than 0
VUID-VkDisplayModeParametersKHR-width-01990,N,None,explicit,VkDisplayModeParametersKHR,(VK_KHR_surface)+(VK_KHR_display), The width member of visibleRegion must be greater than 0
VUID-VkDisplayModeProperties2KHR-pNext-pNext,Y,None,implicit,VkDisplayModeProperties2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), pNext must be NULL
VUID-VkDisplayModeProperties2KHR-sType-sType,Y,None,implicit,VkDisplayModeProperties2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), sType must be VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR
VUID-VkDisplayPlaneCapabilities2KHR-pNext-pNext,Y,None,implicit,VkDisplayPlaneCapabilities2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), pNext must be NULL
VUID-VkDisplayPlaneCapabilities2KHR-sType-sType,Y,None,implicit,VkDisplayPlaneCapabilities2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), sType must be VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR
VUID-VkDisplayPlaneInfo2KHR-mode-parameter,Y,None,implicit,VkDisplayPlaneInfo2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), mode must be a valid VkDisplayModeKHR handle
VUID-VkDisplayPlaneInfo2KHR-pNext-pNext,Y,None,implicit,VkDisplayPlaneInfo2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), pNext must be NULL
VUID-VkDisplayPlaneInfo2KHR-sType-sType,Y,None,implicit,VkDisplayPlaneInfo2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), sType must be VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR
VUID-VkDisplayPlaneProperties2KHR-pNext-pNext,Y,None,implicit,VkDisplayPlaneProperties2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), pNext must be NULL
VUID-VkDisplayPlaneProperties2KHR-sType-sType,Y,None,implicit,VkDisplayPlaneProperties2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), sType must be VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR
VUID-VkDisplayPowerInfoEXT-pNext-pNext,Y,None,implicit,VkDisplayPowerInfoEXT,(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_display_control), pNext must be NULL
VUID-VkDisplayPowerInfoEXT-powerState-parameter,Y,None,implicit,VkDisplayPowerInfoEXT,(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_display_control), powerState must be a valid VkDisplayPowerStateEXT value
VUID-VkDisplayPowerInfoEXT-sType-sType,Y,None,implicit,VkDisplayPowerInfoEXT,(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_display_control), sType must be VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT
VUID-VkDisplayPresentInfoKHR-dstRect-01258,N,None,explicit,VkDisplayPresentInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain), dstRect must specify a rectangular region that is a subset of the visibleRegion parameter of the display mode the swapchain being presented uses
VUID-VkDisplayPresentInfoKHR-persistentContent-01259,N,None,explicit,VkDisplayPresentInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain), If the persistentContent member of the VkDisplayPropertiesKHR structure returned by vkGetPhysicalDeviceDisplayPropertiesKHR for the display the present operation targets then persistent must be VK_FALSE
VUID-VkDisplayPresentInfoKHR-sType-sType,N,None,implicit,VkDisplayPresentInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain), sType must be VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR
VUID-VkDisplayPresentInfoKHR-srcRect-01257,N,None,explicit,VkDisplayPresentInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain), srcRect must specify a rectangular region that is a subset of the image being presented
VUID-VkDisplayProperties2KHR-pNext-pNext,Y,None,implicit,VkDisplayProperties2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), pNext must be NULL
VUID-VkDisplayProperties2KHR-sType-sType,Y,None,implicit,VkDisplayProperties2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), sType must be VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR
VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-01254,N,None,explicit,VkDisplaySurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_display)," If alphaMode is VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR then globalAlpha must be between 0 and 1, inclusive"
VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-01255,N,None,explicit,VkDisplaySurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_display), alphaMode must be 0 or one of the bits present in the supportedAlpha member of VkDisplayPlaneCapabilitiesKHR returned by vkGetDisplayPlaneCapabilitiesKHR for the display plane corresponding to displayMode
VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-parameter,Y,None,implicit,VkDisplaySurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_display), alphaMode must be a valid VkDisplayPlaneAlphaFlagBitsKHR value
VUID-VkDisplaySurfaceCreateInfoKHR-displayMode-parameter,Y,None,implicit,VkDisplaySurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_display), displayMode must be a valid VkDisplayModeKHR handle
VUID-VkDisplaySurfaceCreateInfoKHR-flags-zerobitmask,Y,None,implicit,VkDisplaySurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_display), flags must be 0
VUID-VkDisplaySurfaceCreateInfoKHR-pNext-pNext,Y,None,implicit,VkDisplaySurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_display), pNext must be NULL
VUID-VkDisplaySurfaceCreateInfoKHR-planeIndex-01252,N,None,explicit,VkDisplaySurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_display), planeIndex must be less than the number of display planes supported by the device as determined by calling vkGetPhysicalDeviceDisplayPlanePropertiesKHR
VUID-VkDisplaySurfaceCreateInfoKHR-planeReorderPossible-01253,N,None,explicit,VkDisplaySurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_display), If the planeReorderPossible member of the VkDisplayPropertiesKHR structure returned by vkGetPhysicalDeviceDisplayPropertiesKHR for the display corresponding to displayMode is VK_TRUE then planeStackIndex must be less than the number of display planes supported by the device as determined by calling vkGetPhysicalDeviceDisplayPlanePropertiesKHR; otherwise planeStackIndex must equal the currentStackIndex member of VkDisplayPlanePropertiesKHR returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR for the display plane corresponding to displayMode
VUID-VkDisplaySurfaceCreateInfoKHR-sType-sType,Y,None,implicit,VkDisplaySurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_display), sType must be VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR
VUID-VkDisplaySurfaceCreateInfoKHR-transform-parameter,Y,None,implicit,VkDisplaySurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_display), transform must be a valid VkSurfaceTransformFlagBitsKHR value
VUID-VkDisplaySurfaceCreateInfoKHR-width-01256,N,None,explicit,VkDisplaySurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_display), The width and height members of imageExtent must be less than the maxImageDimensions2D member of VkPhysicalDeviceLimits
VUID-VkDrawIndexedIndirectCommand-None-00552,N,None,explicit,VkDrawIndexedIndirectCommand,core," For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description"
VUID-VkDrawIndexedIndirectCommand-firstInstance-00554,N,None,explicit,VkDrawIndexedIndirectCommand,core," If the drawIndirectFirstInstance feature is not enabled, firstInstance must be 0"
VUID-VkDrawIndexedIndirectCommand-indexSize-00553,N,None,explicit,VkDrawIndexedIndirectCommand,core," (indexSize * (firstIndex + indexCount) + offset) must be less than or equal to the size of the bound index buffer, with indexSize being based on the type specified by indexType, where the index buffer, indexType, and offset are specified via vkCmdBindIndexBuffer"
VUID-VkDrawIndirectCommand-None-00500,N,None,explicit,VkDrawIndirectCommand,core," For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description"
VUID-VkDrawIndirectCommand-firstInstance-00501,N,None,explicit,VkDrawIndirectCommand,core," If the drawIndirectFirstInstance feature is not enabled, firstInstance must be 0"
VUID-VkDrawMeshTasksIndirectCommandNV-taskCount-02175,N,None,explicit,VkDrawMeshTasksIndirectCommandNV,(VK_NV_mesh_shader), taskCount must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesNV::maxDrawMeshTasksCount
VUID-VkEventCreateInfo-flags-zerobitmask,Y,None,implicit,VkEventCreateInfo,core, flags must be 0
VUID-VkEventCreateInfo-pNext-pNext,Y,None,implicit,VkEventCreateInfo,core, pNext must be NULL
VUID-VkEventCreateInfo-sType-sType,Y,None,implicit,VkEventCreateInfo,core, sType must be VK_STRUCTURE_TYPE_EVENT_CREATE_INFO
VUID-VkExportFenceCreateInfo-handleTypes-01446,N,None,explicit,VkExportFenceCreateInfo,"(VK_VERSION_1_1,VK_KHR_external_fence)"," The bits in handleTypes must be supported and compatible, as reported by VkExternalFenceProperties."
VUID-VkExportFenceCreateInfo-handleTypes-parameter,Y,None,implicit,VkExportFenceCreateInfo,"(VK_VERSION_1_1,VK_KHR_external_fence)", handleTypes must be a valid combination of VkExternalFenceHandleTypeFlagBits values
VUID-VkExportFenceCreateInfo-sType-sType,N,None,implicit,VkExportFenceCreateInfo,"(VK_VERSION_1_1,VK_KHR_external_fence)", sType must be VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO
VUID-VkExportFenceWin32HandleInfoKHR-handleTypes-01447,N,None,explicit,VkExportFenceWin32HandleInfoKHR,(VK_KHR_external_fence_win32)," If VkExportFenceCreateInfo::handleTypes does not include VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT, VkExportFenceWin32HandleInfoKHR must not be in the pNext chain of VkFenceCreateInfo."
VUID-VkExportFenceWin32HandleInfoKHR-pAttributes-parameter,N,None,implicit,VkExportFenceWin32HandleInfoKHR,(VK_KHR_external_fence_win32)," If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value"
VUID-VkExportFenceWin32HandleInfoKHR-sType-sType,N,None,implicit,VkExportFenceWin32HandleInfoKHR,(VK_KHR_external_fence_win32), sType must be VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR
VUID-VkExportMemoryAllocateInfo-handleTypes-00656,N,None,explicit,VkExportMemoryAllocateInfo,"(VK_VERSION_1_1,VK_KHR_external_memory)"," The bits in handleTypes must be supported and compatible, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties."
VUID-VkExportMemoryAllocateInfo-handleTypes-parameter,Y,None,implicit,VkExportMemoryAllocateInfo,"(VK_VERSION_1_1,VK_KHR_external_memory)", handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBits values
VUID-VkExportMemoryAllocateInfo-sType-sType,N,None,implicit,VkExportMemoryAllocateInfo,"(VK_VERSION_1_1,VK_KHR_external_memory)", sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO
VUID-VkExportMemoryAllocateInfoNV-handleTypes-parameter,Y,None,implicit,VkExportMemoryAllocateInfoNV,(VK_NV_external_memory), handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values
VUID-VkExportMemoryAllocateInfoNV-sType-sType,N,None,implicit,VkExportMemoryAllocateInfoNV,(VK_NV_external_memory), sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV
VUID-VkExportMemoryWin32HandleInfoKHR-handleTypes-00657,N,None,explicit,VkExportMemoryWin32HandleInfoKHR,(VK_KHR_external_memory_win32)," If VkExportMemoryAllocateInfo::handleTypes does not include VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, VkExportMemoryWin32HandleInfoKHR must not be in the pNext chain of VkMemoryAllocateInfo."
VUID-VkExportMemoryWin32HandleInfoKHR-pAttributes-parameter,N,None,implicit,VkExportMemoryWin32HandleInfoKHR,(VK_KHR_external_memory_win32)," If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value"
VUID-VkExportMemoryWin32HandleInfoKHR-sType-sType,N,None,implicit,VkExportMemoryWin32HandleInfoKHR,(VK_KHR_external_memory_win32), sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR
VUID-VkExportMemoryWin32HandleInfoNV-pAttributes-parameter,N,None,implicit,VkExportMemoryWin32HandleInfoNV,(VK_NV_external_memory_win32)," If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value"
VUID-VkExportMemoryWin32HandleInfoNV-sType-sType,N,None,implicit,VkExportMemoryWin32HandleInfoNV,(VK_NV_external_memory_win32), sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV
VUID-VkExportSemaphoreCreateInfo-handleTypes-01124,N,None,explicit,VkExportSemaphoreCreateInfo,"(VK_VERSION_1_1,VK_KHR_external_semaphore)"," The bits in handleTypes must be supported and compatible, as reported by VkExternalSemaphoreProperties."
VUID-VkExportSemaphoreCreateInfo-handleTypes-parameter,Y,None,implicit,VkExportSemaphoreCreateInfo,"(VK_VERSION_1_1,VK_KHR_external_semaphore)", handleTypes must be a valid combination of VkExternalSemaphoreHandleTypeFlagBits values
VUID-VkExportSemaphoreCreateInfo-sType-sType,N,None,implicit,VkExportSemaphoreCreateInfo,"(VK_VERSION_1_1,VK_KHR_external_semaphore)", sType must be VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO
VUID-VkExportSemaphoreWin32HandleInfoKHR-handleTypes-01125,N,None,explicit,VkExportSemaphoreWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32)," If VkExportSemaphoreCreateInfo::handleTypes does not include VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT or VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT, VkExportSemaphoreWin32HandleInfoKHR must not be in the pNext chain of VkSemaphoreCreateInfo."
VUID-VkExportSemaphoreWin32HandleInfoKHR-pAttributes-parameter,N,None,implicit,VkExportSemaphoreWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32)," If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value"
VUID-VkExportSemaphoreWin32HandleInfoKHR-sType-sType,N,None,implicit,VkExportSemaphoreWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32), sType must be VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR
VUID-VkExternalBufferProperties-pNext-pNext,Y,None,implicit,VkExternalBufferProperties,"(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)", pNext must be NULL
VUID-VkExternalBufferProperties-sType-sType,Y,None,implicit,VkExternalBufferProperties,"(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)", sType must be VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES
VUID-VkExternalFenceProperties-pNext-pNext,Y,None,implicit,VkExternalFenceProperties,"(VK_VERSION_1_1,VK_KHR_external_fence_capabilities)", pNext must be NULL
VUID-VkExternalFenceProperties-sType-sType,Y,None,implicit,VkExternalFenceProperties,"(VK_VERSION_1_1,VK_KHR_external_fence_capabilities)", sType must be VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES
VUID-VkExternalFormatANDROID-externalFormat-01894,N,None,explicit,VkExternalFormatANDROID,(VK_ANDROID_external_memory_android_hardware_buffer), externalFormat must be 0 or a value returned in the externalFormat member of VkAndroidHardwareBufferFormatPropertiesANDROID by an earlier call to vkGetAndroidHardwareBufferPropertiesANDROID
VUID-VkExternalFormatANDROID-sType-sType,N,None,implicit,VkExternalFormatANDROID,(VK_ANDROID_external_memory_android_hardware_buffer), sType must be VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID
VUID-VkExternalImageFormatProperties-sType-sType,N,None,implicit,VkExternalImageFormatProperties,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)", sType must be VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES
VUID-VkExternalMemoryBufferCreateInfo-handleTypes-parameter,Y,None,implicit,VkExternalMemoryBufferCreateInfo,"(VK_VERSION_1_1,VK_KHR_external_memory)", handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBits values
VUID-VkExternalMemoryBufferCreateInfo-sType-sType,N,None,implicit,VkExternalMemoryBufferCreateInfo,"(VK_VERSION_1_1,VK_KHR_external_memory)", sType must be VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO
VUID-VkExternalMemoryImageCreateInfo-handleTypes-parameter,N,None,implicit,VkExternalMemoryImageCreateInfo,"(VK_VERSION_1_1,VK_KHR_external_memory)", handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBits values
VUID-VkExternalMemoryImageCreateInfo-handleTypes-requiredbitmask,Y,None,implicit,VkExternalMemoryImageCreateInfo,"(VK_VERSION_1_1,VK_KHR_external_memory)", handleTypes must not be 0
VUID-VkExternalMemoryImageCreateInfo-sType-sType,N,None,implicit,VkExternalMemoryImageCreateInfo,"(VK_VERSION_1_1,VK_KHR_external_memory)", sType must be VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO
VUID-VkExternalMemoryImageCreateInfoNV-handleTypes-parameter,Y,None,implicit,VkExternalMemoryImageCreateInfoNV,(VK_NV_external_memory), handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values
VUID-VkExternalMemoryImageCreateInfoNV-sType-sType,N,None,implicit,VkExternalMemoryImageCreateInfoNV,(VK_NV_external_memory), sType must be VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV
VUID-VkExternalSemaphoreProperties-pNext-pNext,Y,None,implicit,VkExternalSemaphoreProperties,"(VK_VERSION_1_1,VK_KHR_external_semaphore_capabilities)", pNext must be NULL
VUID-VkExternalSemaphoreProperties-sType-sType,Y,None,implicit,VkExternalSemaphoreProperties,"(VK_VERSION_1_1,VK_KHR_external_semaphore_capabilities)", sType must be VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES
VUID-VkFenceCreateInfo-flags-parameter,Y,None,implicit,VkFenceCreateInfo,core, flags must be a valid combination of VkFenceCreateFlagBits values
VUID-VkFenceCreateInfo-pNext-pNext,Y,None,implicit,VkFenceCreateInfo,core, Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkExportFenceCreateInfo or VkExportFenceWin32HandleInfoKHR
VUID-VkFenceCreateInfo-sType-sType,Y,None,implicit,VkFenceCreateInfo,core, sType must be VK_STRUCTURE_TYPE_FENCE_CREATE_INFO
VUID-VkFenceCreateInfo-sType-unique,N,None,implicit,VkFenceCreateInfo,core, Each sType member in the pNext chain must be unique
VUID-VkFenceGetFdInfoKHR-fence-01455,N,None,explicit,VkFenceGetFdInfoKHR,(VK_KHR_external_fence_fd), fence must not currently have its payload replaced by an imported payload as described below in Importing Fence Payloads unless that imported payload's handle type was included in VkExternalFenceProperties::exportFromImportedHandleTypes for handleType.
VUID-VkFenceGetFdInfoKHR-fence-parameter,Y,None,implicit,VkFenceGetFdInfoKHR,(VK_KHR_external_fence_fd), fence must be a valid VkFence handle
VUID-VkFenceGetFdInfoKHR-handleType-01453,N,None,explicit,VkFenceGetFdInfoKHR,(VK_KHR_external_fence_fd), handleType must have been included in VkExportFenceCreateInfo::handleTypes when fence's current payload was created.
VUID-VkFenceGetFdInfoKHR-handleType-01454,N,None,explicit,VkFenceGetFdInfoKHR,(VK_KHR_external_fence_fd)," If handleType refers to a handle type with copy payload transference semantics, fence must be signaled, or have an associated fence signal operation pending execution."
VUID-VkFenceGetFdInfoKHR-handleType-01456,N,None,explicit,VkFenceGetFdInfoKHR,(VK_KHR_external_fence_fd), handleType must be defined as a POSIX file descriptor handle.
VUID-VkFenceGetFdInfoKHR-handleType-parameter,Y,None,implicit,VkFenceGetFdInfoKHR,(VK_KHR_external_fence_fd), handleType must be a valid VkExternalFenceHandleTypeFlagBits value
VUID-VkFenceGetFdInfoKHR-pNext-pNext,Y,None,implicit,VkFenceGetFdInfoKHR,(VK_KHR_external_fence_fd), pNext must be NULL
VUID-VkFenceGetFdInfoKHR-sType-sType,Y,None,implicit,VkFenceGetFdInfoKHR,(VK_KHR_external_fence_fd), sType must be VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR
VUID-VkFenceGetWin32HandleInfoKHR-fence-01450,N,None,explicit,VkFenceGetWin32HandleInfoKHR,(VK_KHR_external_fence_win32), fence must not currently have its payload replaced by an imported payload as described below in Importing Fence Payloads unless that imported payload's handle type was included in VkExternalFenceProperties::exportFromImportedHandleTypes for handleType.
VUID-VkFenceGetWin32HandleInfoKHR-fence-parameter,Y,None,implicit,VkFenceGetWin32HandleInfoKHR,(VK_KHR_external_fence_win32), fence must be a valid VkFence handle
VUID-VkFenceGetWin32HandleInfoKHR-handleType-01448,N,None,explicit,VkFenceGetWin32HandleInfoKHR,(VK_KHR_external_fence_win32), handleType must have been included in VkExportFenceCreateInfo::handleTypes when the fence's current payload was created.
VUID-VkFenceGetWin32HandleInfoKHR-handleType-01449,N,None,explicit,VkFenceGetWin32HandleInfoKHR,(VK_KHR_external_fence_win32)," If handleType is defined as an NT handle, vkGetFenceWin32HandleKHR must be called no more than once for each valid unique combination of fence and handleType."
VUID-VkFenceGetWin32HandleInfoKHR-handleType-01451,N,None,explicit,VkFenceGetWin32HandleInfoKHR,(VK_KHR_external_fence_win32)," If handleType refers to a handle type with copy payload transference semantics, fence must be signaled, or have an associated fence signal operation pending execution."
VUID-VkFenceGetWin32HandleInfoKHR-handleType-01452,N,None,explicit,VkFenceGetWin32HandleInfoKHR,(VK_KHR_external_fence_win32), handleType must be defined as an NT handle or a global share handle.
VUID-VkFenceGetWin32HandleInfoKHR-handleType-parameter,Y,None,implicit,VkFenceGetWin32HandleInfoKHR,(VK_KHR_external_fence_win32), handleType must be a valid VkExternalFenceHandleTypeFlagBits value
VUID-VkFenceGetWin32HandleInfoKHR-pNext-pNext,Y,None,implicit,VkFenceGetWin32HandleInfoKHR,(VK_KHR_external_fence_win32), pNext must be NULL
VUID-VkFenceGetWin32HandleInfoKHR-sType-sType,Y,None,implicit,VkFenceGetWin32HandleInfoKHR,(VK_KHR_external_fence_win32), sType must be VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR
VUID-VkFormatProperties2-pNext-pNext,Y,None,implicit,VkFormatProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", pNext must be NULL
VUID-VkFormatProperties2-sType-sType,Y,None,implicit,VkFormatProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", sType must be VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2
VUID-VkFramebufferCreateInfo-attachmentCount-00876,Y,FramebufferCreateErrors,explicit,VkFramebufferCreateInfo,core, attachmentCount must be equal to the attachment count specified in renderPass
VUID-VkFramebufferCreateInfo-commonparent,Y,None,implicit,VkFramebufferCreateInfo,core," Both of renderPass, and the elements of pAttachments that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkFramebufferCreateInfo-flags-zerobitmask,Y,None,implicit,VkFramebufferCreateInfo,core, flags must be 0
VUID-VkFramebufferCreateInfo-height-00887,Y,FramebufferCreateErrors,explicit,VkFramebufferCreateInfo,core, height must be greater than 0.
VUID-VkFramebufferCreateInfo-height-00888,Y,FramebufferCreateErrors,explicit,VkFramebufferCreateInfo,core, height must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferHeight
VUID-VkFramebufferCreateInfo-layers-00889,Y,FramebufferCreateErrors,explicit,VkFramebufferCreateInfo,core, layers must be greater than 0.
VUID-VkFramebufferCreateInfo-layers-00890,Y,FramebufferCreateErrors,explicit,VkFramebufferCreateInfo,core, layers must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferLayers
VUID-VkFramebufferCreateInfo-pAttachments-00877,Y,None,explicit,VkFramebufferCreateInfo,core, Each element of pAttachments that is used as a color attachment or resolve attachment by renderPass must have been created with a usage value including VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
VUID-VkFramebufferCreateInfo-pAttachments-00878,Y,FramebufferCreateErrors,explicit,VkFramebufferCreateInfo,core, Each element of pAttachments that is used as a depth/stencil attachment by renderPass must have been created with a usage value including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
VUID-VkFramebufferCreateInfo-pAttachments-00879,Y,None,explicit,VkFramebufferCreateInfo,core, Each element of pAttachments that is used as an input attachment by renderPass must have been created with a usage value including VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT
VUID-VkFramebufferCreateInfo-pAttachments-00880,Y,FramebufferCreateErrors,explicit,VkFramebufferCreateInfo,core, Each element of pAttachments must have been created with an VkFormat value that matches the VkFormat specified by the corresponding VkAttachmentDescription in renderPass
VUID-VkFramebufferCreateInfo-pAttachments-00881,Y,FramebufferCreateErrors,explicit,VkFramebufferCreateInfo,core, Each element of pAttachments must have been created with a samples value that matches the samples value specified by the corresponding VkAttachmentDescription in renderPass
VUID-VkFramebufferCreateInfo-pAttachments-00882,Y,FramebufferCreateErrors,explicit,VkFramebufferCreateInfo,core, Each element of pAttachments must have dimensions at least as large as the corresponding framebuffer dimension
VUID-VkFramebufferCreateInfo-pAttachments-00883,Y,FramebufferCreateErrors,explicit,VkFramebufferCreateInfo,core, Each element of pAttachments must only specify a single mip level
VUID-VkFramebufferCreateInfo-pAttachments-00884,Y,FramebufferCreateErrors,explicit,VkFramebufferCreateInfo,core, Each element of pAttachments must have been created with the identity swizzle
VUID-VkFramebufferCreateInfo-pAttachments-00891,N,None,explicit,VkFramebufferCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance1)", Each element of pAttachments that is a 2D or 2D array image view taken from a 3D image must not be a depth/stencil format
VUID-VkFramebufferCreateInfo-pAttachments-parameter,Y,None,implicit,VkFramebufferCreateInfo,core," If attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkImageView handles"
VUID-VkFramebufferCreateInfo-pNext-pNext,Y,None,implicit,VkFramebufferCreateInfo,core, pNext must be NULL
VUID-VkFramebufferCreateInfo-renderPass-parameter,Y,None,implicit,VkFramebufferCreateInfo,core, renderPass must be a valid VkRenderPass handle
VUID-VkFramebufferCreateInfo-sType-sType,Y,None,implicit,VkFramebufferCreateInfo,core, sType must be VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO
VUID-VkFramebufferCreateInfo-width-00885,Y,FramebufferCreateErrors,explicit,VkFramebufferCreateInfo,core, width must be greater than 0.
VUID-VkFramebufferCreateInfo-width-00886,Y,FramebufferCreateErrors,explicit,VkFramebufferCreateInfo,core, width must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferWidth
VUID-VkGeometryAABBNVX-aabbData-parameter,Y,None,implicit,VkGeometryAABBNVX,(VK_NVX_raytracing)," If aabbData is not VK_NULL_HANDLE, aabbData must be a valid VkBuffer handle"
VUID-VkGeometryAABBNVX-pNext-pNext,Y,None,implicit,VkGeometryAABBNVX,(VK_NVX_raytracing), pNext must be NULL
VUID-VkGeometryAABBNVX-sType-sType,Y,None,implicit,VkGeometryAABBNVX,(VK_NVX_raytracing), sType must be VK_STRUCTURE_TYPE_GEOMETRY_AABB_NVX
VUID-VkGeometryDataNVX-aabbs-parameter,N,None,implicit,VkGeometryDataNVX,(VK_NVX_raytracing), aabbs must be a valid VkGeometryAABBNVX structure
VUID-VkGeometryDataNVX-triangles-parameter,N,None,implicit,VkGeometryDataNVX,(VK_NVX_raytracing), triangles must be a valid VkGeometryTrianglesNVX structure
VUID-VkGeometryNVX-flags-parameter,Y,None,implicit,VkGeometryNVX,(VK_NVX_raytracing), flags must be a valid combination of VkGeometryFlagBitsNVX values
VUID-VkGeometryNVX-geometry-parameter,N,None,implicit,VkGeometryNVX,(VK_NVX_raytracing), geometry must be a valid VkGeometryDataNVX structure
VUID-VkGeometryNVX-geometryType-parameter,Y,None,implicit,VkGeometryNVX,(VK_NVX_raytracing), geometryType must be a valid VkGeometryTypeNVX value
VUID-VkGeometryNVX-pNext-pNext,Y,None,implicit,VkGeometryNVX,(VK_NVX_raytracing), pNext must be NULL
VUID-VkGeometryNVX-sType-sType,Y,None,implicit,VkGeometryNVX,(VK_NVX_raytracing), sType must be VK_STRUCTURE_TYPE_GEOMETRY_NVX
VUID-VkGeometryTrianglesNVX-commonparent,Y,None,implicit,VkGeometryTrianglesNVX,(VK_NVX_raytracing)," Each of indexData, transformData, and vertexData that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkGeometryTrianglesNVX-indexData-parameter,Y,None,implicit,VkGeometryTrianglesNVX,(VK_NVX_raytracing)," If indexData is not VK_NULL_HANDLE, indexData must be a valid VkBuffer handle"
VUID-VkGeometryTrianglesNVX-indexType-parameter,Y,None,implicit,VkGeometryTrianglesNVX,(VK_NVX_raytracing), indexType must be a valid VkIndexType value
VUID-VkGeometryTrianglesNVX-pNext-pNext,Y,None,implicit,VkGeometryTrianglesNVX,(VK_NVX_raytracing), pNext must be NULL
VUID-VkGeometryTrianglesNVX-sType-sType,Y,None,implicit,VkGeometryTrianglesNVX,(VK_NVX_raytracing), sType must be VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NVX
VUID-VkGeometryTrianglesNVX-transformData-parameter,Y,None,implicit,VkGeometryTrianglesNVX,(VK_NVX_raytracing)," If transformData is not VK_NULL_HANDLE, transformData must be a valid VkBuffer handle"
VUID-VkGeometryTrianglesNVX-vertexData-parameter,Y,None,implicit,VkGeometryTrianglesNVX,(VK_NVX_raytracing)," If vertexData is not VK_NULL_HANDLE, vertexData must be a valid VkBuffer handle"
VUID-VkGeometryTrianglesNVX-vertexFormat-parameter,Y,None,implicit,VkGeometryTrianglesNVX,(VK_NVX_raytracing), vertexFormat must be a valid VkFormat value
VUID-VkGraphicsPipelineCreateInfo-attachmentCount-00746,Y,NumBlendAttachMismatch,explicit,VkGraphicsPipelineCreateInfo,core," If rasterization is not disabled and the subpass uses color attachments, the attachmentCount member of pColorBlendState must be equal to the colorAttachmentCount used to create subpass"
VUID-VkGraphicsPipelineCreateInfo-blendEnable-02023,N,None,explicit,VkGraphicsPipelineCreateInfo,core," If rasterization is not disabled and the subpass uses color attachments, then for each color attachment in the subpass the blendEnable member of the corresponding element of the pAttachment member of pColorBlendState must be VK_FALSE if the attached image's format features does not contain the VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT."
VUID-VkGraphicsPipelineCreateInfo-commonparent,Y,None,implicit,VkGraphicsPipelineCreateInfo,core," Each of basePipelineHandle, layout, and renderPass that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkGraphicsPipelineCreateInfo-flags-00722,N,None,explicit,VkGraphicsPipelineCreateInfo,core," If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is -1, basePipelineHandle must be a valid handle to a graphics VkPipeline"
VUID-VkGraphicsPipelineCreateInfo-flags-00723,N,None,explicit,VkGraphicsPipelineCreateInfo,core," If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is VK_NULL_HANDLE, basePipelineIndex must be a valid index into the calling command's pCreateInfos parameter"
VUID-VkGraphicsPipelineCreateInfo-flags-00724,Y,None,explicit,VkGraphicsPipelineCreateInfo,core," If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is not -1, basePipelineHandle must be VK_NULL_HANDLE"
VUID-VkGraphicsPipelineCreateInfo-flags-00725,Y,None,explicit,VkGraphicsPipelineCreateInfo,core," If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is not VK_NULL_HANDLE, basePipelineIndex must be -1"
VUID-VkGraphicsPipelineCreateInfo-flags-00764,N,None,explicit,VkGraphicsPipelineCreateInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", flags must not contain the VK_PIPELINE_CREATE_DISPATCH_BASE flag.
VUID-VkGraphicsPipelineCreateInfo-flags-parameter,Y,None,implicit,VkGraphicsPipelineCreateInfo,core, flags must be a valid combination of VkPipelineCreateFlagBits values
VUID-VkGraphicsPipelineCreateInfo-layout-00756,N,None,explicit,VkGraphicsPipelineCreateInfo,core, layout must be consistent with all shaders specified in pStages
VUID-VkGraphicsPipelineCreateInfo-layout-01688,N,None,explicit,VkGraphicsPipelineCreateInfo,core, The number of resources in layout accessible to each shader stage that is used by the pipeline must be less than or equal to VkPhysicalDeviceLimits::maxPerStageResources
VUID-VkGraphicsPipelineCreateInfo-layout-parameter,Y,None,implicit,VkGraphicsPipelineCreateInfo,core, layout must be a valid VkPipelineLayout handle
VUID-VkGraphicsPipelineCreateInfo-pDynamicState-parameter,Y,None,implicit,VkGraphicsPipelineCreateInfo,core," If pDynamicState is not NULL, pDynamicState must be a valid pointer to a valid VkPipelineDynamicStateCreateInfo structure"
VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00747,Y,"PSOViewportStateMultiViewportTests, PSOViewportStateTests",explicit,VkGraphicsPipelineCreateInfo,core," If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_VIEWPORT, the pViewports member of pViewportState must be a valid pointer to an array of pViewportState::viewportCount valid VkViewport structures"
VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00748,Y,"PSOViewportStateMultiViewportTests, PSOViewportStateTests",explicit,VkGraphicsPipelineCreateInfo,core," If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_SCISSOR, the pScissors member of pViewportState must be a valid pointer to an array of pViewportState::scissorCount VkRect2D structures"
VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00749,Y,PSOLineWidthInvalid,explicit,VkGraphicsPipelineCreateInfo,core," If the wide lines feature is not enabled, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_LINE_WIDTH, the lineWidth member of pRasterizationState must be 1.0"
VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00754,N,None,explicit,VkGraphicsPipelineCreateInfo,core," If the depth bias clamping feature is not enabled, no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_DEPTH_BIAS, and the depthBiasEnable member of pRasterizationState is VK_TRUE, the depthBiasClamp member of pRasterizationState must be 0.0"
VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00755,N,None,explicit,VkGraphicsPipelineCreateInfo,!(VK_EXT_depth_range_unrestricted)," If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_DEPTH_BOUNDS, and the depthBoundsTestEnable member of pDepthStencilState is VK_TRUE, the minDepthBounds and maxDepthBounds members of pDepthStencilState must be between 0.0 and 1.0, inclusive"
VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00755,N,None,explicit,VkGraphicsPipelineCreateInfo,(VK_EXT_depth_range_unrestricted)," If the VK_EXT_depth_range_unrestricted extension is not enabled and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_DEPTH_BOUNDS, and the depthBoundsTestEnable member of pDepthStencilState is VK_TRUE, the minDepthBounds and maxDepthBounds members of pDepthStencilState must be between 0.0 and 1.0, inclusive"
VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-01521,N,None,explicit,VkGraphicsPipelineCreateInfo,(VK_EXT_sample_locations)," If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT, and the sampleLocationsEnable member of a VkPipelineSampleLocationsStateCreateInfoEXT structure chained to the pNext chain of pMultisampleState is VK_TRUE, sampleLocationsInfo.sampleLocationGridSize.width must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples"
VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-01522,N,None,explicit,VkGraphicsPipelineCreateInfo,(VK_EXT_sample_locations)," If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT, and the sampleLocationsEnable member of a VkPipelineSampleLocationsStateCreateInfoEXT structure chained to the pNext chain of pMultisampleState is VK_TRUE, sampleLocationsInfo.sampleLocationGridSize.height must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples"
VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-01523,N,None,explicit,VkGraphicsPipelineCreateInfo,(VK_EXT_sample_locations)," If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT, and the sampleLocationsEnable member of a VkPipelineSampleLocationsStateCreateInfoEXT structure chained to the pNext chain of pMultisampleState is VK_TRUE, sampleLocationsInfo.sampleLocationsPerPixel must equal rasterizationSamples"
VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-01715,N,None,explicit,VkGraphicsPipelineCreateInfo,(VK_NV_clip_space_w_scaling)," If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV, and the viewportWScalingEnable member of a VkPipelineViewportWScalingStateCreateInfoNV structure, chained to the pNext chain of pViewportState, is VK_TRUE, the pViewportWScalings member of the VkPipelineViewportWScalingStateCreateInfoNV must be a pointer to an array of VkPipelineViewportWScalingStateCreateInfoNV::viewportCount valid VkViewportWScalingNV structures"
VUID-VkGraphicsPipelineCreateInfo-pNext-pNext,Y,None,implicit,VkGraphicsPipelineCreateInfo,core, Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineDiscardRectangleStateCreateInfoEXT or VkPipelineRepresentativeFragmentTestStateCreateInfoNV
VUID-VkGraphicsPipelineCreateInfo-pRasterizationState-parameter,Y,None,implicit,VkGraphicsPipelineCreateInfo,core, pRasterizationState must be a valid pointer to a valid VkPipelineRasterizationStateCreateInfo structure
VUID-VkGraphicsPipelineCreateInfo-pStages-00729,Y,CreatePipelineTessErrors,explicit,VkGraphicsPipelineCreateInfo,core," If pStages includes a tessellation control shader stage, it must include a tessellation evaluation shader stage"
VUID-VkGraphicsPipelineCreateInfo-pStages-00730,Y,CreatePipelineTessErrors,explicit,VkGraphicsPipelineCreateInfo,core," If pStages includes a tessellation evaluation shader stage, it must include a tessellation control shader stage"
VUID-VkGraphicsPipelineCreateInfo-pStages-00731,Y,CreatePipelineTessErrors,explicit,VkGraphicsPipelineCreateInfo,core," If pStages includes a tessellation control shader stage and a tessellation evaluation shader stage, pTessellationState must be a valid pointer to a valid VkPipelineTessellationStateCreateInfo structure"
VUID-VkGraphicsPipelineCreateInfo-pStages-00732,N,None,explicit,VkGraphicsPipelineCreateInfo,core," If pStages includes tessellation shader stages, the shader code of at least one stage must contain an OpExecutionMode instruction that specifies the type of subdivision in the pipeline"
VUID-VkGraphicsPipelineCreateInfo-pStages-00733,N,None,explicit,VkGraphicsPipelineCreateInfo,core," If pStages includes tessellation shader stages, and the shader code of both stages contain an OpExecutionMode instruction that specifies the type of subdivision in the pipeline, they must both specify the same subdivision mode"
VUID-VkGraphicsPipelineCreateInfo-pStages-00734,N,None,explicit,VkGraphicsPipelineCreateInfo,core," If pStages includes tessellation shader stages, the shader code of at least one stage must contain an OpExecutionMode instruction that specifies the output patch size in the pipeline"
VUID-VkGraphicsPipelineCreateInfo-pStages-00735,N,None,explicit,VkGraphicsPipelineCreateInfo,core," If pStages includes tessellation shader stages, and the shader code of both contain an OpExecutionMode instruction that specifies the out patch size in the pipeline, they must both specify the same patch size"
VUID-VkGraphicsPipelineCreateInfo-pStages-00736,Y,CreatePipelineTessErrors,explicit,VkGraphicsPipelineCreateInfo,core," If pStages includes tessellation shader stages, the topology member of pInputAssembly must be VK_PRIMITIVE_TOPOLOGY_PATCH_LIST"
VUID-VkGraphicsPipelineCreateInfo-pStages-00738,N,None,explicit,VkGraphicsPipelineCreateInfo,core," If pStages includes a geometry shader stage, and does not include any tessellation shader stages, its shader code must contain an OpExecutionMode instruction that specifies an input primitive type that is compatible with the primitive topology specified in pInputAssembly"
VUID-VkGraphicsPipelineCreateInfo-pStages-00739,N,None,explicit,VkGraphicsPipelineCreateInfo,core," If pStages includes a geometry shader stage, and also includes tessellation shader stages, its shader code must contain an OpExecutionMode instruction that specifies an input primitive type that is compatible with the primitive topology that is output by the tessellation stages"
VUID-VkGraphicsPipelineCreateInfo-pStages-00740,N,None,explicit,VkGraphicsPipelineCreateInfo,core," If pStages includes a fragment shader stage and a geometry shader stage, and the fragment shader code reads from an input variable that is decorated with PrimitiveID, then the geometry shader code must write to a matching output variable, decorated with PrimitiveID, in all execution paths"
VUID-VkGraphicsPipelineCreateInfo-pStages-00741,N,None,explicit,VkGraphicsPipelineCreateInfo,core," If pStages includes a fragment shader stage, its shader code must not read from any input attachment that is defined as VK_ATTACHMENT_UNUSED in subpass"
VUID-VkGraphicsPipelineCreateInfo-pStages-00742,N,None,explicit,VkGraphicsPipelineCreateInfo,core," The shader code for the entry points identified by pStages, and the rest of the state identified by this structure must adhere to the pipeline linking rules described in the Shader Interfaces chapter"
VUID-VkGraphicsPipelineCreateInfo-pStages-01565,N,None,explicit,VkGraphicsPipelineCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)"," If pStages includes a fragment shader stage and an input attachment was referenced by the VkRenderPassInputAttachmentAspectCreateInfo at renderPass create time, its shader code must not read from any aspect that was not specified in the aspectMask of the corresponding VkInputAttachmentAspectReference structure."
VUID-VkGraphicsPipelineCreateInfo-pStages-02095,Y,MeshShaderNV,explicit,VkGraphicsPipelineCreateInfo,(VK_NV_mesh_shader)," The geometric shader stages provided in pStages must be either from the mesh shading pipeline (stage is VK_SHADER_STAGE_TASK_BIT_NV or VK_SHADER_STAGE_MESH_BIT_NV) or from the primitive shading pipeline (stage is VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, or VK_SHADER_STAGE_GEOEMETRY_BIT)."
VUID-VkGraphicsPipelineCreateInfo-pStages-02097,Y,MeshShaderNV,explicit,VkGraphicsPipelineCreateInfo,core," If pStages includes a vertex shader stage, pVertexInputState must be a valid pointer to a valid VkPipelineVertexInputStateCreateInfo structure"
VUID-VkGraphicsPipelineCreateInfo-pStages-02098,Y,MeshShaderNV,explicit,VkGraphicsPipelineCreateInfo,core," If pStages includes a vertex shader stage, pInputAssemblyState must be a valid pointer to a valid VkPipelineInputAssemblyStateCreateInfo structure"
VUID-VkGraphicsPipelineCreateInfo-pStages-parameter,Y,None,implicit,VkGraphicsPipelineCreateInfo,core, pStages must be a valid pointer to an array of stageCount valid VkPipelineShaderStageCreateInfo structures
VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-00750,Y,PSOViewportStateTests,explicit,VkGraphicsPipelineCreateInfo,core," If the rasterizerDiscardEnable member of pRasterizationState is VK_FALSE, pViewportState must be a valid pointer to a valid VkPipelineViewportStateCreateInfo structure"
VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-00751,Y,None,explicit,VkGraphicsPipelineCreateInfo,core," If the rasterizerDiscardEnable member of pRasterizationState is VK_FALSE, pMultisampleState must be a valid pointer to a valid VkPipelineMultisampleStateCreateInfo structure"
VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-00752,Y,None,explicit,VkGraphicsPipelineCreateInfo,core," If the rasterizerDiscardEnable member of pRasterizationState is VK_FALSE, and subpass uses a depth/stencil attachment, pDepthStencilState must be a valid pointer to a valid VkPipelineDepthStencilStateCreateInfo structure"
VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-00753,Y,PipelineRenderpassCompatibility,explicit,VkGraphicsPipelineCreateInfo,core," If the rasterizerDiscardEnable member of pRasterizationState is VK_FALSE, and subpass uses color attachments, pColorBlendState must be a valid pointer to a valid VkPipelineColorBlendStateCreateInfo structure"
VUID-VkGraphicsPipelineCreateInfo-renderPass-00760,N,None,explicit,VkGraphicsPipelineCreateInfo,"(VK_VERSION_1_1,VK_KHR_multiview)"," If the renderPass has multiview enabled and subpass has more than one bit set in the view mask and multiviewTessellationShader is not enabled, then pStages must not include tessellation shaders."
VUID-VkGraphicsPipelineCreateInfo-renderPass-00761,N,None,explicit,VkGraphicsPipelineCreateInfo,"(VK_VERSION_1_1,VK_KHR_multiview)"," If the renderPass has multiview enabled and subpass has more than one bit set in the view mask and multiviewGeometryShader is not enabled, then pStages must not include a geometry shader."
VUID-VkGraphicsPipelineCreateInfo-renderPass-00762,N,None,explicit,VkGraphicsPipelineCreateInfo,"(VK_VERSION_1_1,VK_KHR_multiview)"," If the renderPass has multiview enabled and subpass has more than one bit set in the view mask, shaders in the pipeline must not write to the Layer built-in output"
VUID-VkGraphicsPipelineCreateInfo-renderPass-00763,N,None,explicit,VkGraphicsPipelineCreateInfo,"(VK_VERSION_1_1,VK_KHR_multiview)"," If the renderPass has multiview enabled, then all shaders must not include variables decorated with the Layer built-in decoration in their interfaces."
VUID-VkGraphicsPipelineCreateInfo-renderPass-parameter,Y,None,implicit,VkGraphicsPipelineCreateInfo,core, renderPass must be a valid VkRenderPass handle
VUID-VkGraphicsPipelineCreateInfo-sType-sType,Y,None,implicit,VkGraphicsPipelineCreateInfo,core, sType must be VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO
VUID-VkGraphicsPipelineCreateInfo-sType-unique,N,None,implicit,VkGraphicsPipelineCreateInfo,core, Each sType member in the pNext chain must be unique
VUID-VkGraphicsPipelineCreateInfo-sampleLocationsEnable-01524,N,None,explicit,VkGraphicsPipelineCreateInfo,(VK_EXT_sample_locations)," If the sampleLocationsEnable member of a VkPipelineSampleLocationsStateCreateInfoEXT structure chained to the pNext chain of pMultisampleState is VK_TRUE, the fragment shader code must not statically use the extended instruction InterpolateAtSample"
VUID-VkGraphicsPipelineCreateInfo-stage-00726,N,None,explicit,VkGraphicsPipelineCreateInfo,core, The stage member of each element of pStages must be unique
VUID-VkGraphicsPipelineCreateInfo-stage-00727,Y,None,explicit,VkGraphicsPipelineCreateInfo,!(VK_NV_mesh_shader), The stage member of one element of pStages must be VK_SHADER_STAGE_VERTEX_BIT
VUID-VkGraphicsPipelineCreateInfo-stage-00728,Y,None,explicit,VkGraphicsPipelineCreateInfo,core, The stage member of each element of pStages must not be VK_SHADER_STAGE_COMPUTE_BIT
VUID-VkGraphicsPipelineCreateInfo-stage-02096,Y,MeshShaderNV,explicit,VkGraphicsPipelineCreateInfo,(VK_NV_mesh_shader), The stage member of one element of pStages must be either VK_SHADER_STAGE_VERTEX_BIT or VK_SHADER_STAGE_MESH_BIT_NV.
VUID-VkGraphicsPipelineCreateInfo-stageCount-arraylength,N,None,implicit,VkGraphicsPipelineCreateInfo,core, stageCount must be greater than 0
VUID-VkGraphicsPipelineCreateInfo-subpass-00743,N,None,explicit,VkGraphicsPipelineCreateInfo,"!(VK_VERSION_1_1,VK_KHR_maintenance2)"," If rasterization is not disabled and subpass uses a depth/stencil attachment in renderPass that has a layout of VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL in the VkAttachmentReference defined by subpass, the depthWriteEnable member of pDepthStencilState must be VK_FALSE"
VUID-VkGraphicsPipelineCreateInfo-subpass-00744,N,None,explicit,VkGraphicsPipelineCreateInfo,"!(VK_VERSION_1_1,VK_KHR_maintenance2)"," If rasterization is not disabled and subpass uses a depth/stencil attachment in renderPass that has a layout of VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL in the VkAttachmentReference defined by subpass, the failOp, passOp and depthFailOp members of each of the front and back members of pDepthStencilState must be VK_STENCIL_OP_KEEP"
VUID-VkGraphicsPipelineCreateInfo-subpass-00757,N,None,explicit,VkGraphicsPipelineCreateInfo,!(VK_AMD_mixed_attachment_samples)+!(VK_NV_framebuffer_mixed_samples)," If subpass uses color and/or depth/stencil attachments, then the rasterizationSamples member of pMultisampleState must be the same as the sample count for those subpass attachments"
VUID-VkGraphicsPipelineCreateInfo-subpass-00758,N,None,explicit,VkGraphicsPipelineCreateInfo,core," If subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples member of pMultisampleState must follow the rules for a zero-attachment subpass"
VUID-VkGraphicsPipelineCreateInfo-subpass-00759,Y,None,explicit,VkGraphicsPipelineCreateInfo,core, subpass must be a valid subpass within renderPass
VUID-VkGraphicsPipelineCreateInfo-subpass-01411,N,None,explicit,VkGraphicsPipelineCreateInfo,(VK_NV_framebuffer_mixed_samples)," If subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled, then the rasterizationSamples member of pMultisampleState must be the same as the sample count of the depth/stencil attachment"
VUID-VkGraphicsPipelineCreateInfo-subpass-01412,N,None,explicit,VkGraphicsPipelineCreateInfo,(VK_NV_framebuffer_mixed_samples)," If subpass has any color attachments, then the rasterizationSamples member of pMultisampleState must be greater than or equal to the sample count for those subpass attachments"
VUID-VkGraphicsPipelineCreateInfo-subpass-01505,Y,AMDMixedAttachmentSamplesValidateGraphicsPipeline,explicit,VkGraphicsPipelineCreateInfo,(VK_AMD_mixed_attachment_samples)," If subpass uses color and/or depth/stencil attachments, then the rasterizationSamples member of pMultisampleState must equal the maximum of the sample counts of those subpass attachments"
VUID-VkGraphicsPipelineCreateInfo-subpass-01756,N,None,explicit,VkGraphicsPipelineCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)"," If rasterization is not disabled and subpass uses a depth/stencil attachment in renderPass that has a layout of VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL in the VkAttachmentReference defined by subpass, the depthWriteEnable member of pDepthStencilState must be VK_FALSE"
VUID-VkGraphicsPipelineCreateInfo-subpass-01757,N,None,explicit,VkGraphicsPipelineCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)"," If rasterization is not disabled and subpass uses a depth/stencil attachment in renderPass that has a layout of VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL in the VkAttachmentReference defined by subpass, the failOp, passOp and depthFailOp members of each of the front and back members of pDepthStencilState must be VK_STENCIL_OP_KEEP"
VUID-VkGraphicsPipelineCreateInfo-topology-00737,Y,CreatePipelineTessErrors,explicit,VkGraphicsPipelineCreateInfo,core," If the topology member of pInputAssembly is VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, pStages must include tessellation shader stages"
VUID-VkIOSSurfaceCreateInfoMVK-flags-zerobitmask,Y,None,implicit,VkIOSSurfaceCreateInfoMVK,(VK_KHR_surface)+(VK_MVK_ios_surface), flags must be 0
VUID-VkIOSSurfaceCreateInfoMVK-pNext-pNext,Y,None,implicit,VkIOSSurfaceCreateInfoMVK,(VK_KHR_surface)+(VK_MVK_ios_surface), pNext must be NULL
VUID-VkIOSSurfaceCreateInfoMVK-pView-01316,N,None,explicit,VkIOSSurfaceCreateInfoMVK,(VK_KHR_surface)+(VK_MVK_ios_surface), pView must be a valid UIView and must be backed by a CALayer instance of type CAMetalLayer.
VUID-VkIOSSurfaceCreateInfoMVK-sType-sType,Y,None,implicit,VkIOSSurfaceCreateInfoMVK,(VK_KHR_surface)+(VK_MVK_ios_surface), sType must be VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK
VUID-VkImageBlit-aspectMask-00238,Y,None,explicit,VkImageBlit,core, The aspectMask member of srcSubresource and dstSubresource must match
VUID-VkImageBlit-aspectMask-00241,Y,MiscBlitImageTests,explicit,VkImageBlit,core, The aspectMask member of srcSubresource must specify aspects present in the calling command's srcImage
VUID-VkImageBlit-aspectMask-00242,Y,MiscBlitImageTests,explicit,VkImageBlit,core, The aspectMask member of dstSubresource must specify aspects present in the calling command's dstImage
VUID-VkImageBlit-dstImage-00250,Y,BlitImageOffsets,explicit,VkImageBlit,core," If the calling command's dstImage is of type VK_IMAGE_TYPE_1D, then dstOffset[0].y must be 0 and dstOffset[1].y must be 1."
VUID-VkImageBlit-dstImage-00252,Y,BlitImageOffsets,explicit,VkImageBlit,core," If the calling command's dstImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then dstOffset[0].z must be 0 and dstOffset[1].z must be 1."
VUID-VkImageBlit-dstOffset-00248,Y,"MiscBlitImageTests, BlitImageOffsets",explicit,VkImageBlit,core, dstOffset[0].x and dstOffset[1].x must both be greater than or equal to 0 and less than or equal to the destination image subresource width
VUID-VkImageBlit-dstOffset-00249,Y,"MiscBlitImageTests, BlitImageOffsets",explicit,VkImageBlit,core, dstOffset[0].y and dstOffset[1].y must both be greater than or equal to 0 and less than or equal to the destination image subresource height
VUID-VkImageBlit-dstOffset-00251,Y,"MiscBlitImageTests, BlitImageOffsets",explicit,VkImageBlit,core, dstOffset[0].z and dstOffset[1].z must both be greater than or equal to 0 and less than or equal to the destination image subresource depth
VUID-VkImageBlit-dstSubresource-parameter,N,None,implicit,VkImageBlit,core, dstSubresource must be a valid VkImageSubresourceLayers structure
VUID-VkImageBlit-layerCount-00239,Y,MiscBlitImageTests,explicit,VkImageBlit,core, The layerCount member of srcSubresource and dstSubresource must match
VUID-VkImageBlit-srcImage-00240,Y,MiscBlitImageTests,explicit,VkImageBlit,core," If either of the calling command's srcImage or dstImage parameters are of VkImageType VK_IMAGE_TYPE_3D, the baseArrayLayer and layerCount members of both srcSubresource and dstSubresource must be 0 and 1, respectively"
VUID-VkImageBlit-srcImage-00245,Y,BlitImageOffsets,explicit,VkImageBlit,core," If the calling command's srcImage is of type VK_IMAGE_TYPE_1D, then srcOffset[0].y must be 0 and srcOffset[1].y must be 1."
VUID-VkImageBlit-srcImage-00247,Y,BlitImageOffsets,explicit,VkImageBlit,core," If the calling command's srcImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then srcOffset[0].z must be 0 and srcOffset[1].z must be 1."
VUID-VkImageBlit-srcOffset-00243,Y,"MiscBlitImageTests, BlitImageOffsets",explicit,VkImageBlit,core, srcOffset[0].x and srcOffset[1].x must both be greater than or equal to 0 and less than or equal to the source image subresource width
VUID-VkImageBlit-srcOffset-00244,Y,"MiscBlitImageTests, BlitImageOffsets",explicit,VkImageBlit,core, srcOffset[0].y and srcOffset[1].y must both be greater than or equal to 0 and less than or equal to the source image subresource height
VUID-VkImageBlit-srcOffset-00246,Y,"MiscBlitImageTests, BlitImageOffsets",explicit,VkImageBlit,core, srcOffset[0].z and srcOffset[1].z must both be greater than or equal to 0 and less than or equal to the source image subresource depth
VUID-VkImageBlit-srcSubresource-parameter,N,None,implicit,VkImageBlit,core, srcSubresource must be a valid VkImageSubresourceLayers structure
VUID-VkImageCopy-aspectMask-00137,Y,CopyImageAspectMismatch,explicit,VkImageCopy,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", The aspectMask member of srcSubresource and dstSubresource must match
VUID-VkImageCopy-aspectMask-00142,Y,CopyImageAspectMismatch,explicit,VkImageCopy,core, The aspectMask member of srcSubresource must specify aspects present in the calling command's srcImage
VUID-VkImageCopy-aspectMask-00143,Y,CopyImageAspectMismatch,explicit,VkImageCopy,core, The aspectMask member of dstSubresource must specify aspects present in the calling command's dstImage
VUID-VkImageCopy-dstImage-00152,Y,CopyImageTypeExtentMismatch,explicit,VkImageCopy,core," If the calling command's dstImage is of type VK_IMAGE_TYPE_1D, then dstOffset.y must be 0 and extent.height must be 1."
VUID-VkImageCopy-dstImage-01554,Y,CopyImageMultiplaneAspectBits,explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", If the calling command's dstImage has a VkFormat with two planes then the dstSubresource aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT
VUID-VkImageCopy-dstImage-01555,Y,CopyImageMultiplaneAspectBits,explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's dstImage has a VkFormat with three planes then the dstSubresource aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT"
VUID-VkImageCopy-dstImage-01557,Y,CopyImageMultiplaneAspectBits,explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's dstImage has a multi-planar image format and the srcImage does not have a multi-planar image format, the srcSubresource aspectMask must be VK_IMAGE_ASPECT_COLOR_BIT"
VUID-VkImageCopy-dstImage-01731,Y,"CopyImageCompressedBlockAlignment, CopyImageSinglePlane422Alignment",explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's dstImage is a compressed format image, or a single-plane, '_422' image format, all members of dstOffset must be a multiple of the corresponding dimensions of the compressed texel block"
VUID-VkImageCopy-dstImage-01732,Y,"CopyImageCompressedBlockAlignment, CopyImageSinglePlane422Alignment",explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's dstImage is a compressed format image, or a single-plane, '_422' image format, extent.width must be a multiple of the compressed texel block width or (extent.width + dstOffset.x) must equal the destination image subresource width"
VUID-VkImageCopy-dstImage-01733,Y,CopyImageCompressedBlockAlignment,explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's dstImage is a compressed format image, or a single-plane, '_422' image format, extent.height must be a multiple of the compressed texel block height or (extent.height + dstOffset.y) must equal the destination image subresource height"
VUID-VkImageCopy-dstImage-01734,Y,None,explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's dstImage is a compressed format image, or a single-plane, '_422' image format, extent.depth must be a multiple of the compressed texel block depth or (extent.depth + dstOffset.z) must equal the destination image subresource depth"
VUID-VkImageCopy-dstImage-01786,Y,CopyImageTypeExtentMismatch,explicit,VkImageCopy,core," If the calling command's dstImage is of type VK_IMAGE_TYPE_1D, then dstOffset.z must be 0 and extent.depth must be 1."
VUID-VkImageCopy-dstImage-01788,Y,CopyImageTypeExtentMismatch,explicit,VkImageCopy,core," If the calling command's dstImage is of type VK_IMAGE_TYPE_2D, then dstOffset.z must be 0."
VUID-VkImageCopy-dstImage-01792,N,None,explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_maintenance1)"," If the calling command's dstImage is of type VK_IMAGE_TYPE_2D, and the srcImage is of type VK_IMAGE_TYPE_3D, then extent.depth must equal to the layerCount member of dstSubresource."
VUID-VkImageCopy-dstOffset-00150,Y,CopyImageDstSizeExceeded,explicit,VkImageCopy,core, dstOffset.x and (extent.width + dstOffset.x) must both be greater than or equal to 0 and less than or equal to the destination image subresource width
VUID-VkImageCopy-dstOffset-00151,Y,"CopyImageTypeExtentMismatch, CopyImageDstSizeExceeded",explicit,VkImageCopy,core, dstOffset.y and (extent.height + dstOffset.y) must both be greater than or equal to 0 and less than or equal to the destination image subresource height
VUID-VkImageCopy-dstOffset-00153,Y,"CopyImageTypeExtentMismatch, CopyImageDstSizeExceeded",explicit,VkImageCopy,core, dstOffset.z and (extent.depth + dstOffset.z) must both be greater than or equal to 0 and less than or equal to the destination image subresource depth
VUID-VkImageCopy-dstOffset-00162,Y,CopyImageCompressedBlockAlignment,explicit,VkImageCopy,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's dstImage is a compressed format image, all members of dstOffset must be a multiple of the corresponding dimensions of the compressed texel block"
VUID-VkImageCopy-dstSubresource-parameter,N,None,implicit,VkImageCopy,core, dstSubresource must be a valid VkImageSubresourceLayers structure
VUID-VkImageCopy-extent-00140,Y,CopyImageLayerCountMismatch,explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_maintenance1)", The number of slices of the extent (for 3D) or layers of the srcSubresource (for non-3D) must match the number of slices of the extent (for 3D) or layers of the dstSubresource (for non-3D)
VUID-VkImageCopy-extent-00158,Y,CopyImageCompressedBlockAlignment,explicit,VkImageCopy,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's srcImage is a compressed image, extent.width must be a multiple of the compressed texel block width or (extent.width + srcOffset.x) must equal the source image subresource width"
VUID-VkImageCopy-extent-00159,Y,CopyImageCompressedBlockAlignment,explicit,VkImageCopy,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's srcImage is a compressed image, extent.height must be a multiple of the compressed texel block height or (extent.height + srcOffset.y) must equal the source image subresource height"
VUID-VkImageCopy-extent-00160,Y,None,explicit,VkImageCopy,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's srcImage is a compressed image, extent.depth must be a multiple of the compressed texel block depth or (extent.depth + srcOffset.z) must equal the source image subresource depth"
VUID-VkImageCopy-extent-00163,Y,CopyImageCompressedBlockAlignment,explicit,VkImageCopy,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's dstImage is a compressed format image, extent.width must be a multiple of the compressed texel block width or (extent.width + dstOffset.x) must equal the destination image subresource width"
VUID-VkImageCopy-extent-00164,Y,CopyImageCompressedBlockAlignment,explicit,VkImageCopy,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's dstImage is a compressed format image, extent.height must be a multiple of the compressed texel block height or (extent.height + dstOffset.y) must equal the destination image subresource height"
VUID-VkImageCopy-extent-00165,Y,None,explicit,VkImageCopy,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's dstImage is a compressed format image, extent.depth must be a multiple of the compressed texel block depth or (extent.depth + dstOffset.z) must equal the destination image subresource depth"
VUID-VkImageCopy-layerCount-00138,N,None,explicit,VkImageCopy,"!(VK_VERSION_1_1,VK_KHR_maintenance1)", The layerCount member of srcSubresource and dstSubresource must match
VUID-VkImageCopy-srcImage-00139,N,None,explicit,VkImageCopy,"!(VK_VERSION_1_1,VK_KHR_maintenance1)"," If either of the calling command's srcImage or dstImage parameters are of VkImageType VK_IMAGE_TYPE_3D, the baseArrayLayer and layerCount members of both srcSubresource and dstSubresource must be 0 and 1, respectively"
VUID-VkImageCopy-srcImage-00141,Y,CopyImageTypeExtentMismatch,explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_maintenance1)"," If either of the calling command's srcImage or dstImage parameters are of VkImageType VK_IMAGE_TYPE_3D, the baseArrayLayer and layerCount members of the corresponding subresource must be 0 and 1, respectively"
VUID-VkImageCopy-srcImage-00146,Y,CopyImageTypeExtentMismatch,explicit,VkImageCopy,core," If the calling command's srcImage is of type VK_IMAGE_TYPE_1D, then srcOffset.y must be 0 and extent.height must be 1."
VUID-VkImageCopy-srcImage-01551,Y,CopyImageAspectMismatch,explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", If neither the calling command's srcImage nor the calling command's dstImage has a multi-planar image format then the aspectMask member of srcSubresource and dstSubresource must match
VUID-VkImageCopy-srcImage-01552,Y,CopyImageMultiplaneAspectBits,explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", If the calling command's srcImage has a VkFormat with two planes then the srcSubresource aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT
VUID-VkImageCopy-srcImage-01553,Y,CopyImageMultiplaneAspectBits,explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's srcImage has a VkFormat with three planes then the srcSubresource aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT"
VUID-VkImageCopy-srcImage-01556,Y,CopyImageMultiplaneAspectBits,explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's srcImage has a multi-planar image format and the dstImage does not have a multi-planar image format, the dstSubresource aspectMask must be VK_IMAGE_ASPECT_COLOR_BIT"
VUID-VkImageCopy-srcImage-01727,Y,"CopyImageCompressedBlockAlignment, CopyImageSinglePlane422Alignment",explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's srcImage is a compressed image, or a single-plane, '_422' image format, all members of srcOffset must be a multiple of the corresponding dimensions of the compressed texel block"
VUID-VkImageCopy-srcImage-01728,Y,"CopyImageCompressedBlockAlignment, CopyImageSinglePlane422Alignment",explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's srcImage is a compressed image, or a single-plane, '_422' image format, extent.width must be a multiple of the compressed texel block width or (extent.width + srcOffset.x) must equal the source image subresource width"
VUID-VkImageCopy-srcImage-01729,Y,CopyImageCompressedBlockAlignment,explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's srcImage is a compressed image, or a single-plane, '_422' image format, extent.height must be a multiple of the compressed texel block height or (extent.height + srcOffset.y) must equal the source image subresource height"
VUID-VkImageCopy-srcImage-01730,Y,None,explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's srcImage is a compressed image, or a single-plane, '_422' image format, extent.depth must be a multiple of the compressed texel block depth or (extent.depth + srcOffset.z) must equal the source image subresource depth"
VUID-VkImageCopy-srcImage-01785,Y,CopyImageTypeExtentMismatch,explicit,VkImageCopy,core," If the calling command's srcImage is of type VK_IMAGE_TYPE_1D, then srcOffset.z must be 0 and extent.depth must be 1."
VUID-VkImageCopy-srcImage-01787,Y,CopyImageTypeExtentMismatch,explicit,VkImageCopy,core," If the calling command's srcImage is of type VK_IMAGE_TYPE_2D, then srcOffset.z must be 0."
VUID-VkImageCopy-srcImage-01789,N,None,explicit,VkImageCopy,"!(VK_VERSION_1_1,VK_KHR_maintenance1)"," If the calling command's srcImage or dstImage is of type VK_IMAGE_TYPE_2D, then extent.depth must be 1."
VUID-VkImageCopy-srcImage-01790,N,None,explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_maintenance1)", If both srcImage and dstImage are of type VK_IMAGE_TYPE_2D then extent.depth must be 1.
VUID-VkImageCopy-srcImage-01791,N,None,explicit,VkImageCopy,"(VK_VERSION_1_1,VK_KHR_maintenance1)"," If the calling command's srcImage is of type VK_IMAGE_TYPE_2D, and the dstImage is of type VK_IMAGE_TYPE_3D, then extent.depth must equal to the layerCount member of srcSubresource."
VUID-VkImageCopy-srcOffset-00144,Y,CopyImageSrcSizeExceeded,explicit,VkImageCopy,core, srcOffset.x and (extent.width + srcOffset.x) must both be greater than or equal to 0 and less than or equal to the source image subresource width
VUID-VkImageCopy-srcOffset-00145,Y,"CopyImageSrcSizeExceeded, CopyImageTypeExtentMismatch",explicit,VkImageCopy,core, srcOffset.y and (extent.height + srcOffset.y) must both be greater than or equal to 0 and less than or equal to the source image subresource height
VUID-VkImageCopy-srcOffset-00147,Y,"CopyImageSrcSizeExceeded, CopyImageTypeExtentMismatch",explicit,VkImageCopy,core, srcOffset.z and (extent.depth + srcOffset.z) must both be greater than or equal to 0 and less than or equal to the source image subresource depth
VUID-VkImageCopy-srcOffset-00157,Y,CopyImageCompressedBlockAlignment,explicit,VkImageCopy,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the calling command's srcImage is a compressed image, all members of srcOffset must be a multiple of the corresponding dimensions of the compressed texel block"
VUID-VkImageCopy-srcSubresource-parameter,N,None,implicit,VkImageCopy,core, srcSubresource must be a valid VkImageSubresourceLayers structure
VUID-VkImageCreateInfo-None-01891,N,None,explicit,VkImageCreateInfo,(VK_VERSION_1_1)," If any of the bits VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT are set, VK_IMAGE_CREATE_PROTECTED_BIT must not also be set."
VUID-VkImageCreateInfo-None-01925,N,None,explicit,VkImageCreateInfo,core," If any of the bits VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT are set, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT must not also be set"
VUID-VkImageCreateInfo-arrayLayers-00948,Y,CreateImageMinLimitsViolation,explicit,VkImageCreateInfo,core, arrayLayers must be greater than 0
VUID-VkImageCreateInfo-arrayLayers-00960,Y,CreateImageMaxLimitsViolation,explicit,VkImageCreateInfo,core," arrayLayers must be less than or equal to VkImageFormatProperties::maxArrayLayers (as returned by vkGetPhysicalDeviceImageFormatProperties with format, imageType, tiling, usage, and flags equal to those in this structure)"
VUID-VkImageCreateInfo-extent-00944,Y,CreateImageMinLimitsViolation,explicit,VkImageCreateInfo,core, extent::width must be greater than 0.
VUID-VkImageCreateInfo-extent-00945,Y,CreateImageMinLimitsViolation,explicit,VkImageCreateInfo,core, extent::height must be greater than 0.
VUID-VkImageCreateInfo-extent-00946,Y,CreateImageMinLimitsViolation,explicit,VkImageCreateInfo,core, extent::depth must be greater than 0.
VUID-VkImageCreateInfo-extent-00959,Y,CreateImageMaxLimitsViolation,explicit,VkImageCreateInfo,core," mipLevels must be less than or equal to VkImageFormatProperties::maxMipLevels (as returned by vkGetPhysicalDeviceImageFormatProperties with format, imageType, tiling, usage, and flags equal to those in this structure)"
VUID-VkImageCreateInfo-flags-00949,Y,CreateImageMiscErrors,explicit,VkImageCreateInfo,core," If flags contains VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, imageType must be VK_IMAGE_TYPE_2D"
VUID-VkImageCreateInfo-flags-00950,Y,Bad2DArrayImageType,explicit,VkImageCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance1)"," If flags contains VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT, imageType must be VK_IMAGE_TYPE_3D"
VUID-VkImageCreateInfo-flags-00969,Y,CreateImageMiscErrors,explicit,VkImageCreateInfo,core," If the sparse bindings feature is not enabled, flags must not contain VK_IMAGE_CREATE_SPARSE_BINDING_BIT"
VUID-VkImageCreateInfo-flags-00987,Y,SparseBindingImageBufferCreate,explicit,VkImageCreateInfo,core," If flags contains VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT, it must also contain VK_IMAGE_CREATE_SPARSE_BINDING_BIT"
VUID-VkImageCreateInfo-flags-00992,N,None,explicit,VkImageCreateInfo,"(VK_VERSION_1_1,VK_KHR_device_group)"," If flags contains VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT, then mipLevels must be one, arrayLayers must be one, imageType must be VK_IMAGE_TYPE_2D, and tiling must be VK_IMAGE_TILING_OPTIMAL"
VUID-VkImageCreateInfo-flags-01533,N,None,explicit,VkImageCreateInfo,(VK_EXT_sample_locations), If flags contains VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT format must be a depth or depth/stencil format
VUID-VkImageCreateInfo-flags-01572,N,None,explicit,VkImageCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)"," If flags contains VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT, then format must be a block-compressed image format, an ETC compressed image format, or an ASTC compressed image format."
VUID-VkImageCreateInfo-flags-01573,N,None,explicit,VkImageCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)"," If flags contains VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT, then flags must also contain VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT."
VUID-VkImageCreateInfo-flags-01890,N,None,explicit,VkImageCreateInfo,(VK_VERSION_1_1)," If the protected memory feature is not enabled, flags must not contain VK_IMAGE_CREATE_PROTECTED_BIT."
VUID-VkImageCreateInfo-flags-01924,Y,None,explicit,VkImageCreateInfo,core," If the sparse aliased residency feature is not enabled, flags must not contain VK_IMAGE_CREATE_SPARSE_ALIASED_BIT"
VUID-VkImageCreateInfo-flags-02050,Y,CornerSampledImageNV,explicit,VkImageCreateInfo,(VK_NV_corner_sampled_image)," If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV, imageType must be VK_IMAGE_TYPE_2D or VK_IMAGE_TYPE_3D"
VUID-VkImageCreateInfo-flags-02051,Y,CornerSampledImageNV,explicit,VkImageCreateInfo,(VK_NV_corner_sampled_image)," If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV, it must not contain VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT and the format must not be a depth/stencil format"
VUID-VkImageCreateInfo-flags-02052,Y,CornerSampledImageNV,explicit,VkImageCreateInfo,(VK_NV_corner_sampled_image)," If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV and imageType is VK_IMAGE_TYPE_2D, extent::width and extent::height must be greater than 1"
VUID-VkImageCreateInfo-flags-02053,Y,CornerSampledImageNV,explicit,VkImageCreateInfo,(VK_NV_corner_sampled_image)," If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV and imageType is VK_IMAGE_TYPE_3D, extent::width, extent::height, and extent::depth must be greater than 1"
VUID-VkImageCreateInfo-flags-parameter,Y,None,implicit,VkImageCreateInfo,core, flags must be a valid combination of VkImageCreateFlagBits values
VUID-VkImageCreateInfo-format-00940,Y,CreateImageFormatSupportErrors,explicit,VkImageCreateInfo,!(VK_ANDROID_external_memory_android_hardware_buffer)," The combination of format, imageType, tiling, usage, and flags must be supported, as indicated by a VK_SUCCESS return value from vkGetPhysicalDeviceImageFormatProperties invoked with the same values passed to the corresponding parameters."
VUID-VkImageCreateInfo-format-00943,Y,CreateImageMiscErrors,explicit,VkImageCreateInfo,!(VK_ANDROID_external_memory_android_hardware_buffer), format must not be VK_FORMAT_UNDEFINED
VUID-VkImageCreateInfo-format-01574,N,None,explicit,VkImageCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", If the image format is one of those listed in Formats requiring sampler Y'CBCR conversion for VK_IMAGE_ASPECT_COLOR_BIT image views:
VUID-VkImageCreateInfo-format-01577,N,None,explicit,VkImageCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If format is not a multi-planar format, and flags does not include VK_IMAGE_CREATE_ALIAS_BIT, flags must not contain VK_IMAGE_CREATE_DISJOINT_BIT"
VUID-VkImageCreateInfo-format-parameter,Y,None,implicit,VkImageCreateInfo,core, format must be a valid VkFormat value
VUID-VkImageCreateInfo-imageType-00951,Y,CreateImageMaxLimitsViolation,explicit,VkImageCreateInfo,core," If imageType is VK_IMAGE_TYPE_1D, extent.width must be less than or equal to VkPhysicalDeviceLimits::maxImageDimension1D, or VkImageFormatProperties::maxExtent.width (as returned by vkGetPhysicalDeviceImageFormatProperties with format, imageType, tiling, usage, and flags equal to those in this structure) - whichever is higher"
VUID-VkImageCreateInfo-imageType-00952,Y,CreateImageMaxLimitsViolation,explicit,VkImageCreateInfo,core," If imageType is VK_IMAGE_TYPE_2D and flags does not contain VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, extent.width and extent.height must be less than or equal to VkPhysicalDeviceLimits::maxImageDimension2D, or VkImageFormatProperties::maxExtent.width/height (as returned by vkGetPhysicalDeviceImageFormatProperties with format, imageType, tiling, usage, and flags equal to those in this structure) - whichever is higher"
VUID-VkImageCreateInfo-imageType-00953,Y,CreateImageMaxLimitsViolation,explicit,VkImageCreateInfo,core," If imageType is VK_IMAGE_TYPE_2D and flags contains VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, extent.width and extent.height must be less than or equal to VkPhysicalDeviceLimits::maxImageDimensionCube, or VkImageFormatProperties::maxExtent.width/height (as returned by vkGetPhysicalDeviceImageFormatProperties with format, imageType, tiling, usage, and flags equal to those in this structure) - whichever is higher"
VUID-VkImageCreateInfo-imageType-00954,Y,CreateImageMinLimitsViolation,explicit,VkImageCreateInfo,core," If imageType is VK_IMAGE_TYPE_2D and flags contains VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, extent.width and extent.height must be equal and arrayLayers must be greater than or equal to 6"
VUID-VkImageCreateInfo-imageType-00955,Y,CreateImageMaxLimitsViolation,explicit,VkImageCreateInfo,core," If imageType is VK_IMAGE_TYPE_3D, extent.width, extent.height and extent.depth must be less than or equal to VkPhysicalDeviceLimits::maxImageDimension3D, or VkImageFormatProperties::maxExtent.width/height/depth (as returned by vkGetPhysicalDeviceImageFormatProperties with format, imageType, tiling, usage, and flags equal to those in this structure) - whichever is higher"
VUID-VkImageCreateInfo-imageType-00956,Y,CreateImageMinLimitsViolation,explicit,VkImageCreateInfo,core," If imageType is VK_IMAGE_TYPE_1D, both extent.height and extent.depth must be 1"
VUID-VkImageCreateInfo-imageType-00957,Y,CreateImageMinLimitsViolation,explicit,VkImageCreateInfo,core," If imageType is VK_IMAGE_TYPE_2D, extent.depth must be 1"
VUID-VkImageCreateInfo-imageType-00961,Y,CreateImageMinLimitsViolation,explicit,VkImageCreateInfo,core," If imageType is VK_IMAGE_TYPE_3D, arrayLayers must be 1."
VUID-VkImageCreateInfo-imageType-00970,Y,SparseResidencyImageCreateUnsupportedTypes,explicit,VkImageCreateInfo,core," If imageType is VK_IMAGE_TYPE_1D, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"
VUID-VkImageCreateInfo-imageType-00971,Y,SparseResidencyImageCreateUnsupportedTypes,explicit,VkImageCreateInfo,core," If the sparse residency for 2D images feature is not enabled, and imageType is VK_IMAGE_TYPE_2D, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"
VUID-VkImageCreateInfo-imageType-00972,Y,SparseResidencyImageCreateUnsupportedTypes,explicit,VkImageCreateInfo,core," If the sparse residency for 3D images feature is not enabled, and imageType is VK_IMAGE_TYPE_3D, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"
VUID-VkImageCreateInfo-imageType-00973,Y,SparseResidencyImageCreateUnsupportedSamples,explicit,VkImageCreateInfo,core," If the sparse residency for images with 2 samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_2_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"
VUID-VkImageCreateInfo-imageType-00974,Y,SparseResidencyImageCreateUnsupportedSamples,explicit,VkImageCreateInfo,core," If the sparse residency for images with 4 samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_4_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"
VUID-VkImageCreateInfo-imageType-00975,Y,SparseResidencyImageCreateUnsupportedSamples,explicit,VkImageCreateInfo,core," If the sparse residency for images with 8 samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_8_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"
VUID-VkImageCreateInfo-imageType-00976,Y,SparseResidencyImageCreateUnsupportedSamples,explicit,VkImageCreateInfo,core," If the sparse residency for images with 16 samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_16_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"
VUID-VkImageCreateInfo-imageType-02082,Y,ShadingRateImageNV,explicit,VkImageCreateInfo,(VK_NV_shading_rate_image)," If usage includes VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, imageType must be VK_IMAGE_TYPE_2D."
VUID-VkImageCreateInfo-imageType-parameter,Y,None,implicit,VkImageCreateInfo,core, imageType must be a valid VkImageType value
VUID-VkImageCreateInfo-initialLayout-00993,Y,CreateImageMiscErrors,explicit,VkImageCreateInfo,core, initialLayout must be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED.
VUID-VkImageCreateInfo-initialLayout-parameter,Y,None,implicit,VkImageCreateInfo,core, initialLayout must be a valid VkImageLayout value
VUID-VkImageCreateInfo-mipLevels-00947,Y,CreateImageMinLimitsViolation,explicit,VkImageCreateInfo,core, mipLevels must be greater than 0
VUID-VkImageCreateInfo-mipLevels-00958,Y,"CornerSampledImageNV, CreateImageMaxLimitsViolation",explicit,VkImageCreateInfo,core," mipLevels must be less than or equal to the number of levels in the complete mipmap chain based on extent.width, extent.height, and extent.depth."
VUID-VkImageCreateInfo-pNext-00988,N,None,explicit,VkImageCreateInfo,"(VK_VERSION_1_1,VK_KHR_external_memory)+(VK_NV_external_memory)"," If the pNext chain contains an instance of VkExternalMemoryImageCreateInfoNV, it must not contain an instance of VkExternalMemoryImageCreateInfo."
VUID-VkImageCreateInfo-pNext-00990,N,None,explicit,VkImageCreateInfo,"(VK_VERSION_1_1,VK_KHR_external_memory)"," If the pNext chain contains an instance of VkExternalMemoryImageCreateInfo, its handleTypes member must only contain bits that are also in VkExternalImageFormatProperties::externalMemoryProperties.compatibleHandleTypes, as returned by vkGetPhysicalDeviceImageFormatProperties2 with format, imageType, tiling, usage, and flags equal to those in this structure, and with an instance of VkPhysicalDeviceExternalImageFormatInfo in the pNext chain, with a handleType equal to any one of the handle types specified in VkExternalMemoryImageCreateInfo::handleTypes"
VUID-VkImageCreateInfo-pNext-00991,N,None,explicit,VkImageCreateInfo,(VK_NV_external_memory+VK_NV_external_memory_capabilities)," If the pNext chain contains an instance of VkExternalMemoryImageCreateInfoNV, its handleTypes member must only contain bits that are also in VkExternalImageFormatPropertiesNV::externalMemoryProperties.compatibleHandleTypes, as returned by vkGetPhysicalDeviceExternalImageFormatPropertiesNV with format, imageType, tiling, usage, and flags equal to those in this structure, and with externalHandleType equal to any one of the handle types specified in VkExternalMemoryImageCreateInfoNV::handleTypes"
VUID-VkImageCreateInfo-pNext-01443,N,None,explicit,VkImageCreateInfo,"(VK_VERSION_1_1,VK_KHR_external_memory,VK_NV_external_memory)","     If the pNext chain includes a ifdef::VK_VERSION_1_1,VK_KHR_external_memory[VkExternalMemoryImageCreateInfo]"
VUID-VkImageCreateInfo-pNext-01889,N,None,explicit,VkImageCreateInfo,(VK_ANDROID_external_memory_android_hardware_buffer)," If the pNext chain does not contain an instance of VkExternalFormatANDROID, or if format is not VK_FORMAT_UNDEFINED, the combination of format, imageType, tiling, usage, and flags must be supported, as indicated by a VK_SUCCESS return value from vkGetPhysicalDeviceImageFormatProperties invoked with the same values passed to the corresponding parameters."
VUID-VkImageCreateInfo-pNext-01892,N,None,explicit,VkImageCreateInfo,(VK_ANDROID_external_memory_android_hardware_buffer), If the pNext chain includes a VkExternalMemoryImageCreateInfo structure whose handleTypes member includes VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID:
VUID-VkImageCreateInfo-pNext-01893,N,None,explicit,VkImageCreateInfo,(VK_ANDROID_external_memory_android_hardware_buffer), If the pNext chain includes a VkExternalFormatANDROID structure whose externalFormat member is not 0:
VUID-VkImageCreateInfo-pNext-01974,N,None,explicit,VkImageCreateInfo,(VK_ANDROID_external_memory_android_hardware_buffer)," If the pNext chain contains an instance of VkExternalFormatANDROID, and its member externalFormat is non-zero the format must be VK_FORMAT_UNDEFINED."
VUID-VkImageCreateInfo-pNext-01975,N,None,explicit,VkImageCreateInfo,(VK_ANDROID_external_memory_android_hardware_buffer)," If the pNext chain does not contain an instance of VkExternalFormatANDROID, or does and its member externalFormat is 0 the format must not be VK_FORMAT_UNDEFINED."
VUID-VkImageCreateInfo-pNext-pNext,Y,None,implicit,VkImageCreateInfo,core," Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDedicatedAllocationImageCreateInfoNV, VkExternalFormatANDROID, VkExternalMemoryImageCreateInfo, VkExternalMemoryImageCreateInfoNV, VkImageFormatListCreateInfoKHR, or VkImageSwapchainCreateInfoKHR"
VUID-VkImageCreateInfo-physicalDeviceCount-01421,N,None,explicit,VkImageCreateInfo,"(VK_VERSION_1_1,VK_KHR_device_group)"," If the logical device was created with VkDeviceGroupDeviceCreateInfo::physicalDeviceCount equal to 1, flags must not contain VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT"
VUID-VkImageCreateInfo-sType-sType,Y,None,implicit,VkImageCreateInfo,core, sType must be VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO
VUID-VkImageCreateInfo-sType-unique,N,None,implicit,VkImageCreateInfo,core, Each sType member in the pNext chain must be unique
VUID-VkImageCreateInfo-samples-00962,Y,CreateImageMiscErrors,explicit,VkImageCreateInfo,core," If samples is not VK_SAMPLE_COUNT_1_BIT, imageType must be VK_IMAGE_TYPE_2D, flags must not contain VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, tiling must be VK_IMAGE_TILING_OPTIMAL, and mipLevels must be equal to 1"
VUID-VkImageCreateInfo-samples-00967,Y,CreateImageMaxLimitsViolation,explicit,VkImageCreateInfo,core," samples must be a bit value that is set in VkImageFormatProperties::sampleCounts returned by vkGetPhysicalDeviceImageFormatProperties with format, imageType, tiling, usage, and flags equal to those in this structure"
VUID-VkImageCreateInfo-samples-02083,Y,ShadingRateImageNV,explicit,VkImageCreateInfo,(VK_NV_shading_rate_image)," If usage includes VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, samples must be VK_SAMPLE_COUNT_1_BIT."
VUID-VkImageCreateInfo-samples-parameter,Y,None,implicit,VkImageCreateInfo,core, samples must be a valid VkSampleCountFlagBits value
VUID-VkImageCreateInfo-sharingMode-00941,Y,CreateImageMiscErrors,explicit,VkImageCreateInfo,core," If sharingMode is VK_SHARING_MODE_CONCURRENT, pQueueFamilyIndices must be a valid pointer to an array of queueFamilyIndexCount uint32_t values"
VUID-VkImageCreateInfo-sharingMode-00942,Y,CreateImageMiscErrors,explicit,VkImageCreateInfo,core," If sharingMode is VK_SHARING_MODE_CONCURRENT, queueFamilyIndexCount must be greater than 1"
VUID-VkImageCreateInfo-sharingMode-01392,N,None,explicit,VkImageCreateInfo,"!(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)"," If sharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the physicalDevice that was used to create device"
VUID-VkImageCreateInfo-sharingMode-01420,N,None,explicit,VkImageCreateInfo,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)"," If sharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by either vkGetPhysicalDeviceQueueFamilyProperties or vkGetPhysicalDeviceQueueFamilyProperties2 for the physicalDevice that was used to create device"
VUID-VkImageCreateInfo-sharingMode-parameter,Y,None,implicit,VkImageCreateInfo,core, sharingMode must be a valid VkSharingMode value
VUID-VkImageCreateInfo-tiling-01575,N,None,explicit,VkImageCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If tiling is VK_IMAGE_TILING_OPTIMAL, format is a multi-planar format, and VkFormatProperties::optimalTilingFeatures (as returned by vkGetPhysicalDeviceFormatProperties with the same value of format) does not include VK_FORMAT_FEATURE_DISJOINT_BIT, flags must not contain VK_IMAGE_CREATE_DISJOINT_BIT"
VUID-VkImageCreateInfo-tiling-01576,N,None,explicit,VkImageCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If tiling is VK_IMAGE_TILING_LINEAR, format is a multi-planar format, and VkFormatProperties::linearTilingFeatures (as returned by vkGetPhysicalDeviceFormatProperties with the same value of format) does not include VK_FORMAT_FEATURE_DISJOINT_BIT, flags must not contain VK_IMAGE_CREATE_DISJOINT_BIT"
VUID-VkImageCreateInfo-tiling-02084,Y,ShadingRateImageNV,explicit,VkImageCreateInfo,(VK_NV_shading_rate_image)," If usage includes VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, tiling must be VK_IMAGE_TILING_OPTIMAL."
VUID-VkImageCreateInfo-tiling-parameter,Y,None,implicit,VkImageCreateInfo,core, tiling must be a valid VkImageTiling value
VUID-VkImageCreateInfo-usage-00963,Y,CreateImageMiscErrors,explicit,VkImageCreateInfo,core," If usage includes VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, then bits other than VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT must not be set"
VUID-VkImageCreateInfo-usage-00964,Y,CreateImageMaxLimitsViolation,explicit,VkImageCreateInfo,core," If usage includes VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.width must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferWidth"
VUID-VkImageCreateInfo-usage-00965,Y,CreateImageMaxLimitsViolation,explicit,VkImageCreateInfo,core," If usage includes VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.height must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferHeight"
VUID-VkImageCreateInfo-usage-00966,Y,CreateImageMiscErrors,explicit,VkImageCreateInfo,core," If usage includes VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, usage must also contain at least one of VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT."
VUID-VkImageCreateInfo-usage-00968,N,None,explicit,VkImageCreateInfo,core," If the multisampled storage images feature is not enabled, and usage contains VK_IMAGE_USAGE_STORAGE_BIT, samples must be VK_SAMPLE_COUNT_1_BIT"
VUID-VkImageCreateInfo-usage-parameter,N,None,implicit,VkImageCreateInfo,core, usage must be a valid combination of VkImageUsageFlagBits values
VUID-VkImageCreateInfo-usage-requiredbitmask,Y,None,implicit,VkImageCreateInfo,core, usage must not be 0
VUID-VkImageFormatListCreateInfoKHR-flags-01579,N,None,explicit,VkImageFormatListCreateInfoKHR,(VK_KHR_image_format_list)," If VkImageCreateInfo::flags does not contain VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, viewFormatCount must be 0 or 1."
VUID-VkImageFormatListCreateInfoKHR-pViewFormats-parameter,N,None,implicit,VkImageFormatListCreateInfoKHR,(VK_KHR_image_format_list)," If viewFormatCount is not 0, pViewFormats must be a valid pointer to an array of viewFormatCount valid VkFormat values"
VUID-VkImageFormatListCreateInfoKHR-sType-sType,N,None,implicit,VkImageFormatListCreateInfoKHR,(VK_KHR_image_format_list), sType must be VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR
VUID-VkImageFormatListCreateInfoKHR-viewFormatCount-01578,N,None,explicit,VkImageFormatListCreateInfoKHR,(VK_KHR_image_format_list)," If viewFormatCount is not 0, all of the formats in the pViewFormats array must be compatible with the format specified in the format field of VkImageCreateInfo, as described in the compatibility table."
VUID-VkImageFormatListCreateInfoKHR-viewFormatCount-01580,N,None,explicit,VkImageFormatListCreateInfoKHR,(VK_KHR_image_format_list)," If viewFormatCount is not 0, VkImageCreateInfo::format must be in pViewFormats."
VUID-VkImageFormatProperties2-pNext-pNext,Y,None,implicit,VkImageFormatProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)"," Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkAndroidHardwareBufferUsageANDROID, VkExternalImageFormatProperties, VkSamplerYcbcrConversionImageFormatProperties, or VkTextureLODGatherFormatPropertiesAMD"
VUID-VkImageFormatProperties2-sType-sType,Y,None,implicit,VkImageFormatProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", sType must be VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2
VUID-VkImageFormatProperties2-sType-unique,N,None,implicit,VkImageFormatProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", Each sType member in the pNext chain must be unique
VUID-VkImageMemoryBarrier-dstAccessMask-parameter,Y,None,implicit,VkImageMemoryBarrier,core, dstAccessMask must be a valid combination of VkAccessFlagBits values
VUID-VkImageMemoryBarrier-image-01199,Y,InvalidBarrierQueueFamily,explicit,VkImageMemoryBarrier,"!(VK_VERSION_1_1,VK_KHR_external_memory)"," If image was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, srcQueueFamilyIndex and dstQueueFamilyIndex must both be VK_QUEUE_FAMILY_IGNORED"
VUID-VkImageMemoryBarrier-image-01200,Y,InvalidBarrierQueueFamily,explicit,VkImageMemoryBarrier,"!(VK_VERSION_1_1,VK_KHR_external_memory)"," If image was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE, srcQueueFamilyIndex and dstQueueFamilyIndex must either both be VK_QUEUE_FAMILY_IGNORED, or both be a valid queue family (see Queue Family Properties)."
VUID-VkImageMemoryBarrier-image-01201,Y,InvalidBarrierQueueFamilyWithMemExt,explicit,VkImageMemoryBarrier,"(VK_VERSION_1_1,VK_KHR_external_memory)"," If image was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE and srcQueueFamilyIndex is VK_QUEUE_FAMILY_IGNORED, dstQueueFamilyIndex must also be VK_QUEUE_FAMILY_IGNORED."
VUID-VkImageMemoryBarrier-image-01205,Y,InvalidBarrierQueueFamily,explicit,VkImageMemoryBarrier,core," If image was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE, and srcQueueFamilyIndex and dstQueueFamilyIndex are not VK_QUEUE_FAMILY_IGNORED, at least one of them must be the same as the family of the queue that will execute this barrier"
VUID-VkImageMemoryBarrier-image-01207,Y,InvalidBarriers,explicit,VkImageMemoryBarrier,core," If image has a depth/stencil format with both depth and stencil components, then the aspectMask member of subresourceRange must include both VK_IMAGE_ASPECT_DEPTH_BIT and VK_IMAGE_ASPECT_STENCIL_BIT"
VUID-VkImageMemoryBarrier-image-01381,Y,InvalidBarrierQueueFamilyWithMemExt,explicit,VkImageMemoryBarrier,"(VK_VERSION_1_1,VK_KHR_external_memory)"," If image was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, at least one of srcQueueFamilyIndex and dstQueueFamilyIndex must be VK_QUEUE_FAMILY_IGNORED"
VUID-VkImageMemoryBarrier-image-01671,N,None,explicit,VkImageMemoryBarrier,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If image has a single-plane color format or is not disjoint, then the aspectMask member of subresourceRange must be VK_IMAGE_ASPECT_COLOR_BIT"
VUID-VkImageMemoryBarrier-image-01672,N,None,explicit,VkImageMemoryBarrier,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If image has a multi-planar format and the image is disjoint, then the aspectMask member of subresourceRange must include either at least one of VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, and VK_IMAGE_ASPECT_PLANE_2_BIT; or must include VK_IMAGE_ASPECT_COLOR_BIT"
VUID-VkImageMemoryBarrier-image-01673,N,None,explicit,VkImageMemoryBarrier,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If image has a multi-planar format with only two planes, then the aspectMask member of subresourceRange must not include VK_IMAGE_ASPECT_PLANE_2_BIT"
VUID-VkImageMemoryBarrier-image-01766,Y,InvalidBarrierQueueFamilyWithMemExt,explicit,VkImageMemoryBarrier,"(VK_VERSION_1_1,VK_KHR_external_memory)"," If image was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, and one of srcQueueFamilyIndex and dstQueueFamilyIndex is VK_QUEUE_FAMILY_IGNORED, the other must be VK_QUEUE_FAMILY_IGNORED or a special queue family reserved for external memory transfers, as described in Queue Family Ownership Transfer."
VUID-VkImageMemoryBarrier-image-01767,Y,InvalidBarrierQueueFamilyWithMemExt,explicit,VkImageMemoryBarrier,"(VK_VERSION_1_1,VK_KHR_external_memory)"," If image was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE and srcQueueFamilyIndex is not VK_QUEUE_FAMILY_IGNORED, it must be a valid queue family or a special queue family reserved for external memory transfers, as described in Queue Family Ownership Transfer."
VUID-VkImageMemoryBarrier-image-01768,Y,InvalidBarrierQueueFamilyWithMemExt,explicit,VkImageMemoryBarrier,"(VK_VERSION_1_1,VK_KHR_external_memory)"," If image was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE and dstQueueFamilyIndex is not VK_QUEUE_FAMILY_IGNORED, it must be a valid queue family or a special queue family reserved for external memory transfers, as described in Queue Family Ownership Transfer."
VUID-VkImageMemoryBarrier-image-01932,N,None,explicit,VkImageMemoryBarrier,core, If image is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-VkImageMemoryBarrier-image-parameter,Y,None,implicit,VkImageMemoryBarrier,core, image must be a valid VkImage handle
VUID-VkImageMemoryBarrier-newLayout-01198,Y,InvalidBarriers,explicit,VkImageMemoryBarrier,core, newLayout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED
VUID-VkImageMemoryBarrier-newLayout-parameter,Y,None,implicit,VkImageMemoryBarrier,core, newLayout must be a valid VkImageLayout value
VUID-VkImageMemoryBarrier-oldLayout-01197,Y,"InvalidBarriers, InvalidImageLayout",explicit,VkImageMemoryBarrier,core, oldLayout must be VK_IMAGE_LAYOUT_UNDEFINED or the current layout of the image subresources affected by the barrier
VUID-VkImageMemoryBarrier-oldLayout-01208,Y,InvalidBarriers,explicit,VkImageMemoryBarrier,core, If either oldLayout or newLayout is VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then image must have been created with VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT set
VUID-VkImageMemoryBarrier-oldLayout-01209,Y,InvalidBarriers,explicit,VkImageMemoryBarrier,core, If either oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set
VUID-VkImageMemoryBarrier-oldLayout-01210,Y,"InvalidBarriers, InvalidImageLayout",explicit,VkImageMemoryBarrier,core, If either oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set
VUID-VkImageMemoryBarrier-oldLayout-01211,Y,InvalidBarriers,explicit,VkImageMemoryBarrier,core, If either oldLayout or newLayout is VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then image must have been created with VK_IMAGE_USAGE_SAMPLED_BIT or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT set
VUID-VkImageMemoryBarrier-oldLayout-01212,Y,InvalidBarriers,explicit,VkImageMemoryBarrier,core, If either oldLayout or newLayout is VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL then image must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT set
VUID-VkImageMemoryBarrier-oldLayout-01213,Y,InvalidBarriers,explicit,VkImageMemoryBarrier,core, If either oldLayout or newLayout is VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then image must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT set
VUID-VkImageMemoryBarrier-oldLayout-01658,N,None,explicit,VkImageMemoryBarrier,"(VK_VERSION_1_1,VK_KHR_maintenance2)", If either oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set
VUID-VkImageMemoryBarrier-oldLayout-01659,N,None,explicit,VkImageMemoryBarrier,"(VK_VERSION_1_1,VK_KHR_maintenance2)", If either oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set
VUID-VkImageMemoryBarrier-oldLayout-02088,Y,ShadingRateImageNV,explicit,VkImageMemoryBarrier,(VK_NV_shading_rate_image), If either oldLayout or newLayout is VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV then image must have been created with VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV set
VUID-VkImageMemoryBarrier-oldLayout-parameter,Y,None,implicit,VkImageMemoryBarrier,core, oldLayout must be a valid VkImageLayout value
VUID-VkImageMemoryBarrier-pNext-pNext,Y,None,implicit,VkImageMemoryBarrier,core, pNext must be NULL or a pointer to a valid instance of VkSampleLocationsInfoEXT
VUID-VkImageMemoryBarrier-sType-sType,Y,None,implicit,VkImageMemoryBarrier,core, sType must be VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER
VUID-VkImageMemoryBarrier-srcAccessMask-parameter,Y,None,implicit,VkImageMemoryBarrier,core, srcAccessMask must be a valid combination of VkAccessFlagBits values
VUID-VkImageMemoryBarrier-subresourceRange-01486,Y,ImageBarrierWithBadRange,explicit,VkImageMemoryBarrier,core, subresourceRange.baseMipLevel must be less than the mipLevels specified in VkImageCreateInfo when image was created
VUID-VkImageMemoryBarrier-subresourceRange-01488,Y,ImageBarrierWithBadRange,explicit,VkImageMemoryBarrier,core, subresourceRange.baseArrayLayer must be less than the arrayLayers specified in VkImageCreateInfo when image was created
VUID-VkImageMemoryBarrier-subresourceRange-01724,Y,ImageBarrierWithBadRange,explicit,VkImageMemoryBarrier,core," If subresourceRange.levelCount is not VK_REMAINING_MIP_LEVELS, subresourceRange.baseMipLevel + subresourceRange.levelCount must be less than or equal to the mipLevels specified in VkImageCreateInfo when image was created"
VUID-VkImageMemoryBarrier-subresourceRange-01725,Y,ImageBarrierWithBadRange,explicit,VkImageMemoryBarrier,core," If subresourceRange.layerCount is not VK_REMAINING_ARRAY_LAYERS, subresourceRange.baseArrayLayer + subresourceRange.layerCount must be less than or equal to the arrayLayers specified in VkImageCreateInfo when image was created"
VUID-VkImageMemoryBarrier-subresourceRange-parameter,N,None,implicit,VkImageMemoryBarrier,core, subresourceRange must be a valid VkImageSubresourceRange structure
VUID-VkImageMemoryRequirementsInfo2-image-01589,N,None,explicit,VkImageMemoryRequirementsInfo2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If image was created with a multi-planar format and the VK_IMAGE_CREATE_DISJOINT_BIT flag, there must be a VkImagePlaneMemoryRequirementsInfo in the pNext chain of the VkImageMemoryRequirementsInfo2 structure"
VUID-VkImageMemoryRequirementsInfo2-image-01590,N,None,explicit,VkImageMemoryRequirementsInfo2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If image was not created with the VK_IMAGE_CREATE_DISJOINT_BIT flag, there must not be a VkImagePlaneMemoryRequirementsInfo in the pNext chain of the VkImageMemoryRequirementsInfo2 structure"
VUID-VkImageMemoryRequirementsInfo2-image-01591,N,None,explicit,VkImageMemoryRequirementsInfo2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If image was created with a single-plane format, there must not be a VkImagePlaneMemoryRequirementsInfo in the pNext chain of the VkImageMemoryRequirementsInfo2 structure"
VUID-VkImageMemoryRequirementsInfo2-image-01897,N,None,explicit,VkImageMemoryRequirementsInfo2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)+(VK_ANDROID_external_memory_android_hardware_buffer)"," If image was created with the VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID external memory handle type, then image must be bound to memory."
VUID-VkImageMemoryRequirementsInfo2-image-parameter,Y,None,implicit,VkImageMemoryRequirementsInfo2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", image must be a valid VkImage handle
VUID-VkImageMemoryRequirementsInfo2-pNext-pNext,Y,None,implicit,VkImageMemoryRequirementsInfo2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", pNext must be NULL or a pointer to a valid instance of VkImagePlaneMemoryRequirementsInfo
VUID-VkImageMemoryRequirementsInfo2-sType-sType,Y,None,implicit,VkImageMemoryRequirementsInfo2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", sType must be VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2
VUID-VkImagePlaneMemoryRequirementsInfo-planeAspect-01592,N,None,explicit,VkImagePlaneMemoryRequirementsInfo,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," planeAspect must be an aspect that exists in the format; that is, for a two-plane image planeAspect must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT, and for a three-plane image planeAspect must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT or VK_IMAGE_ASPECT_PLANE_2_BIT"
VUID-VkImagePlaneMemoryRequirementsInfo-planeAspect-parameter,Y,None,implicit,VkImagePlaneMemoryRequirementsInfo,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", planeAspect must be a valid VkImageAspectFlagBits value
VUID-VkImagePlaneMemoryRequirementsInfo-sType-sType,N,None,implicit,VkImagePlaneMemoryRequirementsInfo,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", sType must be VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO
VUID-VkImageResolve-aspectMask-00266,Y,None,explicit,VkImageResolve,core, The aspectMask member of srcSubresource and dstSubresource must only contain VK_IMAGE_ASPECT_COLOR_BIT
VUID-VkImageResolve-dstImage-00276,N,None,explicit,VkImageResolve,core," If the calling command's dstImage is of type VK_IMAGE_TYPE_1D, then dstOffset.y must be 0 and extent.height must be 1."
VUID-VkImageResolve-dstImage-00278,N,None,explicit,VkImageResolve,core," If the calling command's dstImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then dstOffset.z must be 0 and extent.depth must be 1."
VUID-VkImageResolve-dstOffset-00274,N,None,explicit,VkImageResolve,core, dstOffset.x and (extent.width + dstOffset.x) must both be greater than or equal to 0 and less than or equal to the destination image subresource width
VUID-VkImageResolve-dstOffset-00275,N,None,explicit,VkImageResolve,core, dstOffset.y and (extent.height + dstOffset.y) must both be greater than or equal to 0 and less than or equal to the destination image subresource height
VUID-VkImageResolve-dstOffset-00277,N,None,explicit,VkImageResolve,core, dstOffset.z and (extent.depth + dstOffset.z) must both be greater than or equal to 0 and less than or equal to the destination image subresource depth
VUID-VkImageResolve-dstSubresource-parameter,N,None,implicit,VkImageResolve,core, dstSubresource must be a valid VkImageSubresourceLayers structure
VUID-VkImageResolve-layerCount-00267,Y,None,explicit,VkImageResolve,core, The layerCount member of srcSubresource and dstSubresource must match
VUID-VkImageResolve-srcImage-00268,N,None,explicit,VkImageResolve,core," If either of the calling command's srcImage or dstImage parameters are of VkImageType VK_IMAGE_TYPE_3D, the baseArrayLayer and layerCount members of both srcSubresource and dstSubresource must be 0 and 1, respectively"
VUID-VkImageResolve-srcImage-00271,N,None,explicit,VkImageResolve,core," If the calling command's srcImage is of type VK_IMAGE_TYPE_1D, then srcOffset.y must be 0 and extent.height must be 1."
VUID-VkImageResolve-srcImage-00273,N,None,explicit,VkImageResolve,core," If the calling command's srcImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then srcOffset.z must be 0 and extent.depth must be 1."
VUID-VkImageResolve-srcOffset-00269,N,None,explicit,VkImageResolve,core, srcOffset.x and (extent.width + srcOffset.x) must both be greater than or equal to 0 and less than or equal to the source image subresource width
VUID-VkImageResolve-srcOffset-00270,N,None,explicit,VkImageResolve,core, srcOffset.y and (extent.height + srcOffset.y) must both be greater than or equal to 0 and less than or equal to the source image subresource height
VUID-VkImageResolve-srcOffset-00272,N,None,explicit,VkImageResolve,core, srcOffset.z and (extent.depth + srcOffset.z) must both be greater than or equal to 0 and less than or equal to the source image subresource depth
VUID-VkImageResolve-srcSubresource-parameter,N,None,implicit,VkImageResolve,core, srcSubresource must be a valid VkImageSubresourceLayers structure
VUID-VkImageSparseMemoryRequirementsInfo2-image-parameter,Y,None,implicit,VkImageSparseMemoryRequirementsInfo2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", image must be a valid VkImage handle
VUID-VkImageSparseMemoryRequirementsInfo2-pNext-pNext,Y,None,implicit,VkImageSparseMemoryRequirementsInfo2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", pNext must be NULL
VUID-VkImageSparseMemoryRequirementsInfo2-sType-sType,Y,None,implicit,VkImageSparseMemoryRequirementsInfo2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", sType must be VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2
VUID-VkImageSubresource-aspectMask-parameter,Y,"InvalidImageViewAspect, ExerciseGetImageSubresourceLayout, InvalidBarriers",implicit,VkImageSubresource,core, aspectMask must be a valid combination of VkImageAspectFlagBits values
VUID-VkImageSubresource-aspectMask-requiredbitmask,Y,None,implicit,VkImageSubresource,core, aspectMask must not be 0
VUID-VkImageSubresourceLayers-aspectMask-00167,Y,CopyImageAspectMismatch,explicit,VkImageSubresourceLayers,core," If aspectMask contains VK_IMAGE_ASPECT_COLOR_BIT, it must not contain either of VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT"
VUID-VkImageSubresourceLayers-aspectMask-00168,Y,CopyImageAspectMismatch,explicit,VkImageSubresourceLayers,core, aspectMask must not contain VK_IMAGE_ASPECT_METADATA_BIT
VUID-VkImageSubresourceLayers-aspectMask-parameter,Y,None,implicit,VkImageSubresourceLayers,core, aspectMask must be a valid combination of VkImageAspectFlagBits values
VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask,Y,None,implicit,VkImageSubresourceLayers,core, aspectMask must not be 0
VUID-VkImageSubresourceLayers-layerCount-01700,Y,MiscBlitImageTests,explicit,VkImageSubresourceLayers,core, layerCount must be greater than 0
VUID-VkImageSubresourceRange-aspectMask-01670,N,None,explicit,VkImageSubresourceRange,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If aspectMask includes VK_IMAGE_ASPECT_COLOR_BIT, then it must not include any of VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT"
VUID-VkImageSubresourceRange-aspectMask-parameter,N,None,implicit,VkImageSubresourceRange,core, aspectMask must be a valid combination of VkImageAspectFlagBits values
VUID-VkImageSubresourceRange-aspectMask-requiredbitmask,Y,None,implicit,VkImageSubresourceRange,core, aspectMask must not be 0
VUID-VkImageSubresourceRange-layerCount-01721,N,None,explicit,VkImageSubresourceRange,core," If layerCount is not VK_REMAINING_ARRAY_LAYERS, it must be greater than 0"
VUID-VkImageSubresourceRange-levelCount-01720,N,None,explicit,VkImageSubresourceRange,core," If levelCount is not VK_REMAINING_MIP_LEVELS, it must be greater than 0"
VUID-VkImageSwapchainCreateInfoKHR-sType-sType,N,None,implicit,VkImageSwapchainCreateInfoKHR,"(VK_VERSION_1_1,VK_KHR_device_group)+(VK_KHR_swapchain)", sType must be VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR
VUID-VkImageSwapchainCreateInfoKHR-swapchain-00995,N,None,explicit,VkImageSwapchainCreateInfoKHR,"(VK_VERSION_1_1,VK_KHR_device_group)+(VK_KHR_swapchain)"," If swapchain is not VK_NULL_HANDLE, the fields of VkImageCreateInfo must match the implied image creation parameters of the swapchain"
VUID-VkImageSwapchainCreateInfoKHR-swapchain-parameter,N,None,implicit,VkImageSwapchainCreateInfoKHR,"(VK_VERSION_1_1,VK_KHR_device_group)+(VK_KHR_swapchain)"," If swapchain is not VK_NULL_HANDLE, swapchain must be a valid VkSwapchainKHR handle"
VUID-VkImageViewASTCDecodeModeEXT-decodeMode-02230,N,None,explicit,VkImageViewASTCDecodeModeEXT,(VK_EXT_astc_decode_mode)," decodeMode must be one of VK_FORMAT_R16G16B16A16_SFLOAT, VK_FORMAT_R8G8B8A8_UNORM, or VK_FORMAT_E5B9G9R9_UFLOAT_PACK32"
VUID-VkImageViewASTCDecodeModeEXT-decodeMode-02231,N,None,explicit,VkImageViewASTCDecodeModeEXT,(VK_EXT_astc_decode_mode)," If the decodeModeSharedExponent feature is not enabled, decodeMode must not be VK_FORMAT_E5B9G9R9_UFLOAT_PACK32"
VUID-VkImageViewASTCDecodeModeEXT-decodeMode-02232,N,None,explicit,VkImageViewASTCDecodeModeEXT,(VK_EXT_astc_decode_mode), If decodeMode is VK_FORMAT_R8G8B8A8_UNORM the image view must not include blocks using any of the ASTC HDR modes
VUID-VkImageViewASTCDecodeModeEXT-decodeMode-parameter,Y,None,implicit,VkImageViewASTCDecodeModeEXT,(VK_EXT_astc_decode_mode), decodeMode must be a valid VkFormat value
VUID-VkImageViewASTCDecodeModeEXT-format-02233,N,None,explicit,VkImageViewASTCDecodeModeEXT,(VK_EXT_astc_decode_mode)," format of the image view must be one of VK_FORMAT_ASTC_4x4_UNORM_BLOCK, VK_FORMAT_ASTC_4x4_SRGB_BLOCK, VK_FORMAT_ASTC_5x4_UNORM_BLOCK, VK_FORMAT_ASTC_5x4_SRGB_BLOCK, VK_FORMAT_ASTC_5x5_UNORM_BLOCK, VK_FORMAT_ASTC_5x5_SRGB_BLOCK, VK_FORMAT_ASTC_6x5_UNORM_BLOCK, VK_FORMAT_ASTC_6x5_SRGB_BLOCK, VK_FORMAT_ASTC_6x6_UNORM_BLOCK, VK_FORMAT_ASTC_6x6_SRGB_BLOCK, VK_FORMAT_ASTC_8x5_UNORM_BLOCK, VK_FORMAT_ASTC_8x5_SRGB_BLOCK, VK_FORMAT_ASTC_8x6_UNORM_BLOCK, VK_FORMAT_ASTC_8x6_SRGB_BLOCK, VK_FORMAT_ASTC_8x8_UNORM_BLOCK, VK_FORMAT_ASTC_8x8_SRGB_BLOCK, VK_FORMAT_ASTC_10x5_UNORM_BLOCK, VK_FORMAT_ASTC_10x5_SRGB_BLOCK, VK_FORMAT_ASTC_10x6_UNORM_BLOCK, VK_FORMAT_ASTC_10x6_SRGB_BLOCK, VK_FORMAT_ASTC_10x8_UNORM_BLOCK, VK_FORMAT_ASTC_10x8_SRGB_BLOCK, VK_FORMAT_ASTC_10x10_UNORM_BLOCK, VK_FORMAT_ASTC_10x10_SRGB_BLOCK, VK_FORMAT_ASTC_12x10_UNORM_BLOCK, VK_FORMAT_ASTC_12x10_SRGB_BLOCK, VK_FORMAT_ASTC_12x12_UNORM_BLOCK, or VK_FORMAT_ASTC_12x12_SRGB_BLOCK"
VUID-VkImageViewASTCDecodeModeEXT-sType-sType,N,None,implicit,VkImageViewASTCDecodeModeEXT,(VK_EXT_astc_decode_mode), sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT
VUID-VkImageViewCreateInfo-components-parameter,N,None,implicit,VkImageViewCreateInfo,core, components must be a valid VkComponentMapping structure
VUID-VkImageViewCreateInfo-flags-zerobitmask,Y,None,implicit,VkImageViewCreateInfo,core, flags must be 0
VUID-VkImageViewCreateInfo-format-parameter,Y,None,implicit,VkImageViewCreateInfo,core, format must be a valid VkFormat value
VUID-VkImageViewCreateInfo-image-01003,Y,"CreateImageViewBreaksParameterCompatibilityRequirements, ShadingRateImageNV",explicit,VkImageViewCreateInfo,core, If image was not created with VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT then viewType must not be VK_IMAGE_VIEW_TYPE_CUBE or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
VUID-VkImageViewCreateInfo-image-01005,Y,CreateImageViewBreaksParameterCompatibilityRequirements,explicit,VkImageViewCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance1)", If image was created with VK_IMAGE_TYPE_3D but without VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set then viewType must not be VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY
VUID-VkImageViewCreateInfo-image-01006,Y,None,explicit,VkImageViewCreateInfo,core," If image was created with VK_IMAGE_TILING_LINEAR, format must be format that has at least one supported feature bit present in the value of VkFormatProperties::linearTilingFeatures returned by vkGetPhysicalDeviceFormatProperties with the same value of format"
VUID-VkImageViewCreateInfo-image-01007,N,None,explicit,VkImageViewCreateInfo,!(VK_NV_shading_rate_image)," image must have been created with a usage value containing at least one of VK_IMAGE_USAGE_SAMPLED_BIT, VK_IMAGE_USAGE_STORAGE_BIT, VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT"
VUID-VkImageViewCreateInfo-image-01008,Y,None,explicit,VkImageViewCreateInfo,core," If image was created with VK_IMAGE_TILING_LINEAR and usage contains VK_IMAGE_USAGE_SAMPLED_BIT, format must be supported for sampled images, as specified by the VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT flag in VkFormatProperties::linearTilingFeatures returned by vkGetPhysicalDeviceFormatProperties with the same value of format"
VUID-VkImageViewCreateInfo-image-01009,Y,None,explicit,VkImageViewCreateInfo,core," If image was created with VK_IMAGE_TILING_LINEAR and usage contains VK_IMAGE_USAGE_STORAGE_BIT, format must be supported for storage images, as specified by the VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT flag in VkFormatProperties::linearTilingFeatures returned by vkGetPhysicalDeviceFormatProperties with the same value of format"
VUID-VkImageViewCreateInfo-image-01010,Y,None,explicit,VkImageViewCreateInfo,core," If image was created with VK_IMAGE_TILING_LINEAR and usage contains VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, format must be supported for color attachments, as specified by the VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT flag in VkFormatProperties::linearTilingFeatures returned by vkGetPhysicalDeviceFormatProperties with the same value of format"
VUID-VkImageViewCreateInfo-image-01011,Y,None,explicit,VkImageViewCreateInfo,core," If image was created with VK_IMAGE_TILING_LINEAR and usage contains VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, format must be supported for depth/stencil attachments, as specified by the VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT flag in VkFormatProperties::linearTilingFeatures returned by vkGetPhysicalDeviceFormatProperties with the same value of format"
VUID-VkImageViewCreateInfo-image-01012,Y,None,explicit,VkImageViewCreateInfo,!(VK_ANDROID_external_memory_android_hardware_buffer)," If image was created with VK_IMAGE_TILING_OPTIMAL, format must be format that has at least one supported feature bit present in the value of VkFormatProperties::optimalTilingFeatures returned by vkGetPhysicalDeviceFormatProperties with the same value of format"
VUID-VkImageViewCreateInfo-image-01013,Y,CreateImageViewFormatFeatureMismatch,explicit,VkImageViewCreateInfo,!(VK_ANDROID_external_memory_android_hardware_buffer)," If image was created with VK_IMAGE_TILING_OPTIMAL and usage contains VK_IMAGE_USAGE_SAMPLED_BIT, format must be supported for sampled images, as specified by the VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT flag in VkFormatProperties::optimalTilingFeatures returned by vkGetPhysicalDeviceFormatProperties with the same value of format"
VUID-VkImageViewCreateInfo-image-01014,Y,"CreateImageViewFormatFeatureMismatch, InvalidImageViewUsageCreateInfo",explicit,VkImageViewCreateInfo,!(VK_ANDROID_external_memory_android_hardware_buffer)," If image was created with VK_IMAGE_TILING_OPTIMAL and usage contains VK_IMAGE_USAGE_STORAGE_BIT, format must be supported for storage images, as specified by the VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT flag in VkFormatProperties::optimalTilingFeatures returned by vkGetPhysicalDeviceFormatProperties with the same value of format"
VUID-VkImageViewCreateInfo-image-01015,Y,CreateImageViewFormatFeatureMismatch,explicit,VkImageViewCreateInfo,!(VK_ANDROID_external_memory_android_hardware_buffer)," If image was created with VK_IMAGE_TILING_OPTIMAL and usage contains VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, format must be supported for color attachments, as specified by the VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT flag in VkFormatProperties::optimalTilingFeatures returned by vkGetPhysicalDeviceFormatProperties with the same value of format"
VUID-VkImageViewCreateInfo-image-01016,Y,CreateImageViewFormatFeatureMismatch,explicit,VkImageViewCreateInfo,!(VK_ANDROID_external_memory_android_hardware_buffer)," If image was created with VK_IMAGE_TILING_OPTIMAL and usage contains VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, format must be supported for depth/stencil attachments, as specified by the VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT flag in VkFormatProperties::optimalTilingFeatures returned by vkGetPhysicalDeviceFormatProperties with the same value of format"
VUID-VkImageViewCreateInfo-image-01018,Y,CreateImageViewDifferentClass,explicit,VkImageViewCreateInfo,core," If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, format must be compatible with the format used to create image, as defined in Format Compatibility Classes"
VUID-VkImageViewCreateInfo-image-01019,Y,CreateImageViewNoMutableFormatBit,explicit,VkImageViewCreateInfo,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If image was not created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, format must be identical to the format used to create image"
VUID-VkImageViewCreateInfo-image-01020,Y,None,explicit,VkImageViewCreateInfo,core, If image is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-VkImageViewCreateInfo-image-01482,Y,None,explicit,VkImageViewCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance1)"," If image is not a 3D image created with VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, or viewType is not VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY, subresourceRange::baseArrayLayer must be less than the arrayLayers specified in VkImageCreateInfo when image was created"
VUID-VkImageViewCreateInfo-image-01484,Y,None,explicit,VkImageViewCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance1)"," If image is a 3D image created with VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, and viewType is VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY, subresourceRange::baseArrayLayer must be less than the extent.depth specified in VkImageCreateInfo when image was created"
VUID-VkImageViewCreateInfo-image-01583,N,None,explicit,VkImageViewCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)"," If image was created with the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, format must be compatible with, or must be an uncompressed format that is size-compatible with, the format used to create image."
VUID-VkImageViewCreateInfo-image-01584,N,None,explicit,VkImageViewCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)"," If image was created with the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, the levelCount and layerCount members of subresourceRange must both be 1."
VUID-VkImageViewCreateInfo-image-01586,Y,MultiplaneIncompatibleViewFormat,explicit,VkImageViewCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, if the format of the image is a multi-planar format, and if subresourceRange.aspectMask is one of VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT, then format must be compatible with the VkFormat for the plane of the image format indicated by subresourceRange.aspectMask, as defined in Compatible formats of planes of multi-planar formats"
VUID-VkImageViewCreateInfo-image-01759,N,None,explicit,VkImageViewCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)+!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, but without the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, format must be compatible with the format used to create image, as defined in Format Compatibility Classes"
VUID-VkImageViewCreateInfo-image-01760,N,None,explicit,VkImageViewCreateInfo,"!(VK_VERSION_1_1,VK_KHR_maintenance2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, and if the format of the image is not a multi-planar format, format must be compatible with the format used to create image, as defined in Format Compatibility Classes"
VUID-VkImageViewCreateInfo-image-01761,N,None,explicit,VkImageViewCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, but without the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, and if the format of the image is not a multi-planar format, format must be compatible with the format used to create image, as defined in Format Compatibility Classes"
VUID-VkImageViewCreateInfo-image-01762,N,None,explicit,VkImageViewCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If image was not created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, or if the format of the image is a multi-planar format and if subresourceRange.aspectMask is VK_IMAGE_ASPECT_COLOR_BIT, format must be identical to the format used to create image"
VUID-VkImageViewCreateInfo-image-01896,N,None,explicit,VkImageViewCreateInfo,(VK_ANDROID_external_memory_android_hardware_buffer), If image has an external format:
VUID-VkImageViewCreateInfo-image-01965,N,None,explicit,VkImageViewCreateInfo,(VK_ANDROID_external_memory_android_hardware_buffer)," If image was created with VK_IMAGE_TILING_OPTIMAL and format is not VK_FORMAT_UNDEFINED, format must be format that has at least one supported feature bit present in the value of VkFormatProperties::optimalTilingFeatures returned by vkGetPhysicalDeviceFormatProperties with the same value of format"
VUID-VkImageViewCreateInfo-image-01966,N,None,explicit,VkImageViewCreateInfo,(VK_ANDROID_external_memory_android_hardware_buffer)," If image was created with VK_IMAGE_TILING_OPTIMAL, and format is not VK_FORMAT_UNDEFINED, and usage contains VK_IMAGE_USAGE_SAMPLED_BIT, format must be supported for sampled images, as specified by the VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT flag in VkFormatProperties::optimalTilingFeatures returned by vkGetPhysicalDeviceFormatProperties with the same value of format"
VUID-VkImageViewCreateInfo-image-01967,N,None,explicit,VkImageViewCreateInfo,(VK_ANDROID_external_memory_android_hardware_buffer)," If image was created with VK_IMAGE_TILING_OPTIMAL, and format is not VK_FORMAT_UNDEFINED, and usage contains VK_IMAGE_USAGE_STORAGE_BIT, format must be supported for storage images, as specified by the VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT flag in VkFormatProperties::optimalTilingFeatures returned by vkGetPhysicalDeviceFormatProperties with the same value of format"
VUID-VkImageViewCreateInfo-image-01968,N,None,explicit,VkImageViewCreateInfo,(VK_ANDROID_external_memory_android_hardware_buffer)," If image was created with VK_IMAGE_TILING_OPTIMAL, and format is not VK_FORMAT_UNDEFINED, and usage contains VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, format must be supported for color attachments, as specified by the VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT flag in VkFormatProperties::optimalTilingFeatures returned by vkGetPhysicalDeviceFormatProperties with the same value of format"
VUID-VkImageViewCreateInfo-image-01969,N,None,explicit,VkImageViewCreateInfo,(VK_ANDROID_external_memory_android_hardware_buffer)," If image was created with VK_IMAGE_TILING_OPTIMAL, and format is not VK_FORMAT_UNDEFINED, and usage contains VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, format must be supported for depth/stencil attachments, as specified by the VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT flag in VkFormatProperties::optimalTilingFeatures returned by vkGetPhysicalDeviceFormatProperties with the same value of format"
VUID-VkImageViewCreateInfo-image-02085,N,None,explicit,VkImageViewCreateInfo,(VK_NV_shading_rate_image)," image must have been created with a usage value containing at least one of VK_IMAGE_USAGE_SAMPLED_BIT, VK_IMAGE_USAGE_STORAGE_BIT, VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, or VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV"
VUID-VkImageViewCreateInfo-image-02086,Y,ShadingRateImageNV,explicit,VkImageViewCreateInfo,(VK_NV_shading_rate_image)," If image was created with usage containing VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, viewType must be VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY"
VUID-VkImageViewCreateInfo-image-02087,Y,ShadingRateImageNV,explicit,VkImageViewCreateInfo,(VK_NV_shading_rate_image)," If image was created with usage containing VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, format must be VK_FORMAT_R8_UINT"
VUID-VkImageViewCreateInfo-image-parameter,Y,None,implicit,VkImageViewCreateInfo,core, image must be a valid VkImage handle
VUID-VkImageViewCreateInfo-pNext-01585,N,None,explicit,VkImageViewCreateInfo,(VK_KHR_image_format_list), If a VkImageFormatListCreateInfoKHR structure was included in the pNext chain of the VkImageCreateInfo struct used when creating image and the viewFormatCount field of VkImageFormatListCreateInfoKHR is not zero then format must be one of the formats in VkImageFormatListCreateInfoKHR::pViewFormats.
VUID-VkImageViewCreateInfo-pNext-01970,N,None,explicit,VkImageViewCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the pNext chain contains an instance of VkSamplerYcbcrConversionInfo with a conversion value other than VK_NULL_HANDLE, all members of components must have the value VK_COMPONENT_SWIZZLE_IDENTITY."
VUID-VkImageViewCreateInfo-pNext-pNext,Y,None,implicit,VkImageViewCreateInfo,core," Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkImageViewASTCDecodeModeEXT, VkImageViewUsageCreateInfo, or VkSamplerYcbcrConversionInfo"
VUID-VkImageViewCreateInfo-sType-sType,Y,None,implicit,VkImageViewCreateInfo,core, sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
VUID-VkImageViewCreateInfo-sType-unique,N,None,implicit,VkImageViewCreateInfo,core, Each sType member in the pNext chain must be unique
VUID-VkImageViewCreateInfo-subResourceRange-01021,Y,CreateImageViewBreaksParameterCompatibilityRequirements,explicit,VkImageViewCreateInfo,core," subresourceRange and viewType must be compatible with the image, as described in the compatibility table"
VUID-VkImageViewCreateInfo-subresourceRange-01478,Y,CreateImageViewInvalidSubresourceRange,explicit,VkImageViewCreateInfo,core, subresourceRange.baseMipLevel must be less than the mipLevels specified in VkImageCreateInfo when image was created
VUID-VkImageViewCreateInfo-subresourceRange-01480,Y,CreateImageViewInvalidSubresourceRange,explicit,VkImageViewCreateInfo,"!(VK_VERSION_1_1,VK_KHR_maintenance1)", subresourceRange.baseArrayLayer must be less than the arrayLayers specified in VkImageCreateInfo when image was created
VUID-VkImageViewCreateInfo-subresourceRange-01483,Y,None,explicit,VkImageViewCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance1)"," If subresourceRange::layerCount is not VK_REMAINING_ARRAY_LAYERS, image is not a 3D image created with VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, or viewType is not VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY, subresourceRange::layerCount must be non-zero and subresourceRange::baseArrayLayer + subresourceRange::layerCount must be less than or equal to the arrayLayers specified in VkImageCreateInfo when image was created"
VUID-VkImageViewCreateInfo-subresourceRange-01485,Y,None,explicit,VkImageViewCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance1)"," If subresourceRange::layerCount is not VK_REMAINING_ARRAY_LAYERS, image is a 3D image created with VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, and viewType is VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY, subresourceRange::layerCount must be non-zero and subresourceRange::baseArrayLayer + subresourceRange::layerCount must be less than or equal to the extent.depth specified in VkImageCreateInfo when image was created"
VUID-VkImageViewCreateInfo-subresourceRange-01718,Y,CreateImageViewInvalidSubresourceRange,explicit,VkImageViewCreateInfo,core," If subresourceRange.levelCount is not VK_REMAINING_MIP_LEVELS, subresourceRange.baseMipLevel + subresourceRange.levelCount must be less than or equal to the mipLevels specified in VkImageCreateInfo when image was created"
VUID-VkImageViewCreateInfo-subresourceRange-01719,Y,CreateImageViewInvalidSubresourceRange,explicit,VkImageViewCreateInfo,"!(VK_VERSION_1_1,VK_KHR_maintenance1)"," If subresourceRange.layerCount is not VK_REMAINING_ARRAY_LAYERS, subresourceRange.baseArrayLayer + subresourceRange.layerCount must be less than or equal to the arrayLayers specified in VkImageCreateInfo when image was created"
VUID-VkImageViewCreateInfo-subresourceRange-parameter,N,None,implicit,VkImageViewCreateInfo,core, subresourceRange must be a valid VkImageSubresourceRange structure
VUID-VkImageViewCreateInfo-viewType-01004,N,None,explicit,VkImageViewCreateInfo,core," If the image cubemap arrays feature is not enabled, viewType must not be VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"
VUID-VkImageViewCreateInfo-viewType-parameter,Y,None,implicit,VkImageViewCreateInfo,core, viewType must be a valid VkImageViewType value
VUID-VkImageViewUsageCreateInfo-sType-sType,N,None,implicit,VkImageViewUsageCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)", sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO
VUID-VkImageViewUsageCreateInfo-usage-01587,Y,InvalidImageViewUsageCreateInfo,explicit,VkImageViewUsageCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)", usage must not include any set bits that were not set in the usage member of the VkImageCreateInfo structure used to create the image this image view is created from.
VUID-VkImageViewUsageCreateInfo-usage-parameter,Y,InvalidImageViewUsageCreateInfo,implicit,VkImageViewUsageCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)", usage must be a valid combination of VkImageUsageFlagBits values
VUID-VkImageViewUsageCreateInfo-usage-requiredbitmask,Y,InvalidImageViewUsageCreateInfo,implicit,VkImageViewUsageCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)", usage must not be 0
VUID-VkImportAndroidHardwareBufferInfoANDROID-buffer-01880,N,None,explicit,VkImportAndroidHardwareBufferInfoANDROID,(VK_ANDROID_external_memory_android_hardware_buffer)," If buffer is not NULL, Android hardware buffers must be supported for import, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties."
VUID-VkImportAndroidHardwareBufferInfoANDROID-buffer-01881,N,None,explicit,VkImportAndroidHardwareBufferInfoANDROID,(VK_ANDROID_external_memory_android_hardware_buffer)," If buffer is not NULL, it must be a valid Android hardware buffer object with format and usage compatible with Vulkan as described by VkExternalMemoryHandleTypeFlagBits."
VUID-VkImportAndroidHardwareBufferInfoANDROID-buffer-parameter,Y,None,implicit,VkImportAndroidHardwareBufferInfoANDROID,(VK_ANDROID_external_memory_android_hardware_buffer), buffer must be a valid pointer to a AHardwareBuffer value
VUID-VkImportAndroidHardwareBufferInfoANDROID-sType-sType,N,None,implicit,VkImportAndroidHardwareBufferInfoANDROID,(VK_ANDROID_external_memory_android_hardware_buffer), sType must be VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID
VUID-VkImportFenceFdInfoKHR-fd-01541,N,None,explicit,VkImportFenceFdInfoKHR,(VK_KHR_external_fence_fd), fd must obey any requirements listed for handleType in external fence handle types compatibility.
VUID-VkImportFenceFdInfoKHR-fence-parameter,Y,None,implicit,VkImportFenceFdInfoKHR,(VK_KHR_external_fence_fd), fence must be a valid VkFence handle
VUID-VkImportFenceFdInfoKHR-flags-parameter,Y,None,implicit,VkImportFenceFdInfoKHR,(VK_KHR_external_fence_fd), flags must be a valid combination of VkFenceImportFlagBits values
VUID-VkImportFenceFdInfoKHR-handleType-01464,N,None,explicit,VkImportFenceFdInfoKHR,(VK_KHR_external_fence_fd), handleType must be a value included in the Handle Types Supported by VkImportFenceFdInfoKHR table.
VUID-VkImportFenceFdInfoKHR-handleType-parameter,Y,None,implicit,VkImportFenceFdInfoKHR,(VK_KHR_external_fence_fd), handleType must be a valid VkExternalFenceHandleTypeFlagBits value
VUID-VkImportFenceFdInfoKHR-pNext-pNext,Y,None,implicit,VkImportFenceFdInfoKHR,(VK_KHR_external_fence_fd), pNext must be NULL
VUID-VkImportFenceFdInfoKHR-sType-sType,Y,None,implicit,VkImportFenceFdInfoKHR,(VK_KHR_external_fence_fd), sType must be VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR
VUID-VkImportFenceWin32HandleInfoKHR-fence-parameter,Y,None,implicit,VkImportFenceWin32HandleInfoKHR,(VK_KHR_external_fence_win32), fence must be a valid VkFence handle
VUID-VkImportFenceWin32HandleInfoKHR-flags-parameter,Y,None,implicit,VkImportFenceWin32HandleInfoKHR,(VK_KHR_external_fence_win32), flags must be a valid combination of VkFenceImportFlagBits values
VUID-VkImportFenceWin32HandleInfoKHR-handle-01462,N,None,explicit,VkImportFenceWin32HandleInfoKHR,(VK_KHR_external_fence_win32)," If handle is not NULL, name must be NULL."
VUID-VkImportFenceWin32HandleInfoKHR-handle-01539,N,None,explicit,VkImportFenceWin32HandleInfoKHR,(VK_KHR_external_fence_win32)," If handle is not NULL, it must obey any requirements listed for handleType in external fence handle types compatibility."
VUID-VkImportFenceWin32HandleInfoKHR-handleType-01457,N,None,explicit,VkImportFenceWin32HandleInfoKHR,(VK_KHR_external_fence_win32), handleType must be a value included in the Handle Types Supported by VkImportFenceWin32HandleInfoKHR table.
VUID-VkImportFenceWin32HandleInfoKHR-handleType-01459,N,None,explicit,VkImportFenceWin32HandleInfoKHR,(VK_KHR_external_fence_win32)," If handleType is not VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT, name must be NULL."
VUID-VkImportFenceWin32HandleInfoKHR-handleType-01460,N,None,explicit,VkImportFenceWin32HandleInfoKHR,(VK_KHR_external_fence_win32)," If handleType is not 0 and handle is NULL, name must name a valid synchronization primitive of the type specified by handleType."
VUID-VkImportFenceWin32HandleInfoKHR-handleType-01461,N,None,explicit,VkImportFenceWin32HandleInfoKHR,(VK_KHR_external_fence_win32)," If handleType is not 0 and name is NULL, handle must be a valid handle of the type specified by handleType."
VUID-VkImportFenceWin32HandleInfoKHR-handleType-parameter,Y,None,implicit,VkImportFenceWin32HandleInfoKHR,(VK_KHR_external_fence_win32)," If handleType is not 0, handleType must be a valid VkExternalFenceHandleTypeFlagBits value"
VUID-VkImportFenceWin32HandleInfoKHR-name-01540,N,None,explicit,VkImportFenceWin32HandleInfoKHR,(VK_KHR_external_fence_win32)," If name is not NULL, it must obey any requirements listed for handleType in external fence handle types compatibility."
VUID-VkImportFenceWin32HandleInfoKHR-pNext-pNext,Y,None,implicit,VkImportFenceWin32HandleInfoKHR,(VK_KHR_external_fence_win32), pNext must be NULL
VUID-VkImportFenceWin32HandleInfoKHR-sType-sType,Y,None,implicit,VkImportFenceWin32HandleInfoKHR,(VK_KHR_external_fence_win32), sType must be VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR
VUID-VkImportMemoryFdInfoKHR-fd-00668,N,None,explicit,VkImportMemoryFdInfoKHR,(VK_KHR_external_memory_fd), The memory from which fd was exported must have been created on the same underlying physical device as device.
VUID-VkImportMemoryFdInfoKHR-fd-01520,N,None,explicit,VkImportMemoryFdInfoKHR,(VK_KHR_external_memory_fd), fd must obey any requirements listed for handleType in external memory handle types compatibility.
VUID-VkImportMemoryFdInfoKHR-fd-01746,N,None,explicit,VkImportMemoryFdInfoKHR,(VK_KHR_external_memory_fd)," The memory represented by fd must have been created from a physical device and driver that is compatible with device and handleType, as described in External memory handle types compatibility."
VUID-VkImportMemoryFdInfoKHR-handleType-00667,N,None,explicit,VkImportMemoryFdInfoKHR,(VK_KHR_external_memory_fd)," If handleType is not 0, it must be supported for import, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties."
VUID-VkImportMemoryFdInfoKHR-handleType-00669,N,None,explicit,VkImportMemoryFdInfoKHR,(VK_KHR_external_memory_fd)," If handleType is not 0, it must be defined as a POSIX file descriptor handle."
VUID-VkImportMemoryFdInfoKHR-handleType-00670,N,None,explicit,VkImportMemoryFdInfoKHR,(VK_KHR_external_memory_fd)," If handleType is not 0, fd must be a valid handle of the type specified by handleType."
VUID-VkImportMemoryFdInfoKHR-handleType-parameter,Y,None,implicit,VkImportMemoryFdInfoKHR,(VK_KHR_external_memory_fd)," If handleType is not 0, handleType must be a valid VkExternalMemoryHandleTypeFlagBits value"
VUID-VkImportMemoryFdInfoKHR-sType-sType,N,None,implicit,VkImportMemoryFdInfoKHR,(VK_KHR_external_memory_fd), sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR
VUID-VkImportMemoryHostPointerInfoEXT-handleType-01747,N,None,explicit,VkImportMemoryHostPointerInfoEXT,(VK_EXT_external_memory_host)," If handleType is not 0, it must be supported for import, as reported in VkExternalMemoryPropertiesKHR"
VUID-VkImportMemoryHostPointerInfoEXT-handleType-01748,N,None,explicit,VkImportMemoryHostPointerInfoEXT,(VK_EXT_external_memory_host)," If handleType is not 0, it must be VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT"
VUID-VkImportMemoryHostPointerInfoEXT-handleType-01750,N,None,explicit,VkImportMemoryHostPointerInfoEXT,(VK_EXT_external_memory_host)," If handleType is VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT, pHostPointer must be a pointer to allocationSize number of bytes of host memory, where allocationSize is the member of the VkMemoryAllocateInfo structure this structure is chained to"
VUID-VkImportMemoryHostPointerInfoEXT-handleType-01751,N,None,explicit,VkImportMemoryHostPointerInfoEXT,(VK_EXT_external_memory_host)," If handleType is VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT, pHostPointer must be a pointer to allocationSize number of bytes of host mapped foreign memory, where allocationSize is the member of the VkMemoryAllocateInfo structure this structure is chained to"
VUID-VkImportMemoryHostPointerInfoEXT-handleType-parameter,Y,None,implicit,VkImportMemoryHostPointerInfoEXT,(VK_EXT_external_memory_host), handleType must be a valid VkExternalMemoryHandleTypeFlagBits value
VUID-VkImportMemoryHostPointerInfoEXT-pHostPointer-01749,N,None,explicit,VkImportMemoryHostPointerInfoEXT,(VK_EXT_external_memory_host), pHostPointer must be a pointer aligned to an integer multiple of VkPhysicalDeviceExternalMemoryHostPropertiesEXT::minImportedHostPointerAlignment
VUID-VkImportMemoryHostPointerInfoEXT-sType-sType,N,None,implicit,VkImportMemoryHostPointerInfoEXT,(VK_EXT_external_memory_host), sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT
VUID-VkImportMemoryWin32HandleInfoKHR-handle-00659,N,None,explicit,VkImportMemoryWin32HandleInfoKHR,(VK_KHR_external_memory_win32)," The memory from which handle was exported, or the memory named by name must have been created on the same underlying physical device as device."
VUID-VkImportMemoryWin32HandleInfoKHR-handle-01441,N,None,explicit,VkImportMemoryWin32HandleInfoKHR,(VK_KHR_external_memory_win32)," if handle is not NULL, name must be NULL."
VUID-VkImportMemoryWin32HandleInfoKHR-handle-01518,N,None,explicit,VkImportMemoryWin32HandleInfoKHR,(VK_KHR_external_memory_win32)," If handle is not NULL, it must obey any requirements listed for handleType in external memory handle types compatibility."
VUID-VkImportMemoryWin32HandleInfoKHR-handleType-00658,N,None,explicit,VkImportMemoryWin32HandleInfoKHR,(VK_KHR_external_memory_win32)," If handleType is not 0, it must be supported for import, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties."
VUID-VkImportMemoryWin32HandleInfoKHR-handleType-00660,N,None,explicit,VkImportMemoryWin32HandleInfoKHR,(VK_KHR_external_memory_win32)," If handleType is not 0, it must be defined as an NT handle or a global share handle."
VUID-VkImportMemoryWin32HandleInfoKHR-handleType-00661,N,None,explicit,VkImportMemoryWin32HandleInfoKHR,(VK_KHR_external_memory_win32)," If handleType is not 0 and name is NULL, handle must be a valid handle of the type specified by handleType."
VUID-VkImportMemoryWin32HandleInfoKHR-handleType-01439,N,None,explicit,VkImportMemoryWin32HandleInfoKHR,(VK_KHR_external_memory_win32)," If handleType is not VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, name must be NULL."
VUID-VkImportMemoryWin32HandleInfoKHR-handleType-01440,N,None,explicit,VkImportMemoryWin32HandleInfoKHR,(VK_KHR_external_memory_win32)," If handleType is not 0 and handle is NULL, name must name a valid memory resource of the type specified by handleType."
VUID-VkImportMemoryWin32HandleInfoKHR-handleType-parameter,Y,None,implicit,VkImportMemoryWin32HandleInfoKHR,(VK_KHR_external_memory_win32)," If handleType is not 0, handleType must be a valid VkExternalMemoryHandleTypeFlagBits value"
VUID-VkImportMemoryWin32HandleInfoKHR-name-01519,N,None,explicit,VkImportMemoryWin32HandleInfoKHR,(VK_KHR_external_memory_win32)," If name is not NULL, it must obey any requirements listed for handleType in external memory handle types compatibility."
VUID-VkImportMemoryWin32HandleInfoKHR-sType-sType,N,None,implicit,VkImportMemoryWin32HandleInfoKHR,(VK_KHR_external_memory_win32), sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR
VUID-VkImportMemoryWin32HandleInfoNV-handle-01328,N,None,explicit,VkImportMemoryWin32HandleInfoNV,(VK_NV_external_memory_win32)," handle must be a valid handle to memory, obtained as specified by handleType."
VUID-VkImportMemoryWin32HandleInfoNV-handleType-01327,N,None,explicit,VkImportMemoryWin32HandleInfoNV,(VK_NV_external_memory_win32), handleType must not have more than one bit set.
VUID-VkImportMemoryWin32HandleInfoNV-handleType-parameter,Y,None,implicit,VkImportMemoryWin32HandleInfoNV,(VK_NV_external_memory_win32), handleType must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values
VUID-VkImportMemoryWin32HandleInfoNV-sType-sType,N,None,implicit,VkImportMemoryWin32HandleInfoNV,(VK_NV_external_memory_win32), sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV
VUID-VkImportSemaphoreFdInfoKHR-fd-01544,N,None,explicit,VkImportSemaphoreFdInfoKHR,(VK_KHR_external_semaphore_fd), fd must obey any requirements listed for handleType in external semaphore handle types compatibility.
VUID-VkImportSemaphoreFdInfoKHR-flags-parameter,Y,None,implicit,VkImportSemaphoreFdInfoKHR,(VK_KHR_external_semaphore_fd), flags must be a valid combination of VkSemaphoreImportFlagBits values
VUID-VkImportSemaphoreFdInfoKHR-handleType-01143,N,None,explicit,VkImportSemaphoreFdInfoKHR,(VK_KHR_external_semaphore_fd), handleType must be a value included in the Handle Types Supported by VkImportSemaphoreFdInfoKHR table.
VUID-VkImportSemaphoreFdInfoKHR-handleType-parameter,Y,None,implicit,VkImportSemaphoreFdInfoKHR,(VK_KHR_external_semaphore_fd), handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value
VUID-VkImportSemaphoreFdInfoKHR-pNext-pNext,Y,None,implicit,VkImportSemaphoreFdInfoKHR,(VK_KHR_external_semaphore_fd), pNext must be NULL
VUID-VkImportSemaphoreFdInfoKHR-sType-sType,Y,None,implicit,VkImportSemaphoreFdInfoKHR,(VK_KHR_external_semaphore_fd), sType must be VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR
VUID-VkImportSemaphoreFdInfoKHR-semaphore-parameter,Y,None,implicit,VkImportSemaphoreFdInfoKHR,(VK_KHR_external_semaphore_fd), semaphore must be a valid VkSemaphore handle
VUID-VkImportSemaphoreWin32HandleInfoKHR-flags-parameter,Y,None,implicit,VkImportSemaphoreWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32), flags must be a valid combination of VkSemaphoreImportFlagBits values
VUID-VkImportSemaphoreWin32HandleInfoKHR-handle-01469,N,None,explicit,VkImportSemaphoreWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32)," If handle is not NULL, name must be NULL."
VUID-VkImportSemaphoreWin32HandleInfoKHR-handle-01542,N,None,explicit,VkImportSemaphoreWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32)," If handle is not NULL, it must obey any requirements listed for handleType in external semaphore handle types compatibility."
VUID-VkImportSemaphoreWin32HandleInfoKHR-handleType-01140,N,None,explicit,VkImportSemaphoreWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32), handleType must be a value included in the Handle Types Supported by VkImportSemaphoreWin32HandleInfoKHR table.
VUID-VkImportSemaphoreWin32HandleInfoKHR-handleType-01466,N,None,explicit,VkImportSemaphoreWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32)," If handleType is not VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT or VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT, name must be NULL."
VUID-VkImportSemaphoreWin32HandleInfoKHR-handleType-01467,N,None,explicit,VkImportSemaphoreWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32)," If handleType is not 0 and handle is NULL, name must name a valid synchronization primitive of the type specified by handleType."
VUID-VkImportSemaphoreWin32HandleInfoKHR-handleType-01468,N,None,explicit,VkImportSemaphoreWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32)," If handleType is not 0 and name is NULL, handle must be a valid handle of the type specified by handleType."
VUID-VkImportSemaphoreWin32HandleInfoKHR-handleType-parameter,Y,None,implicit,VkImportSemaphoreWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32)," If handleType is not 0, handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value"
VUID-VkImportSemaphoreWin32HandleInfoKHR-name-01543,N,None,explicit,VkImportSemaphoreWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32)," If name is not NULL, it must obey any requirements listed for handleType in external semaphore handle types compatibility."
VUID-VkImportSemaphoreWin32HandleInfoKHR-pNext-pNext,Y,None,implicit,VkImportSemaphoreWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32), pNext must be NULL
VUID-VkImportSemaphoreWin32HandleInfoKHR-sType-sType,Y,None,implicit,VkImportSemaphoreWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32), sType must be VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR
VUID-VkImportSemaphoreWin32HandleInfoKHR-semaphore-parameter,Y,None,implicit,VkImportSemaphoreWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32), semaphore must be a valid VkSemaphore handle
VUID-VkIndirectCommandsLayoutCreateInfoNVX-computeBindingPointSupport-01348,N,None,explicit,VkIndirectCommandsLayoutCreateInfoNVX,(VK_NVX_device_generated_commands)," If the VkDeviceGeneratedCommandsFeaturesNVX::computeBindingPointSupport feature is not enabled, then pipelineBindPoint must not be VK_PIPELINE_BIND_POINT_COMPUTE"
VUID-VkIndirectCommandsLayoutCreateInfoNVX-flags-parameter,N,None,implicit,VkIndirectCommandsLayoutCreateInfoNVX,(VK_NVX_device_generated_commands), flags must be a valid combination of VkIndirectCommandsLayoutUsageFlagBitsNVX values
VUID-VkIndirectCommandsLayoutCreateInfoNVX-flags-requiredbitmask,Y,None,implicit,VkIndirectCommandsLayoutCreateInfoNVX,(VK_NVX_device_generated_commands), flags must not be 0
VUID-VkIndirectCommandsLayoutCreateInfoNVX-pNext-pNext,Y,None,implicit,VkIndirectCommandsLayoutCreateInfoNVX,(VK_NVX_device_generated_commands), pNext must be NULL
VUID-VkIndirectCommandsLayoutCreateInfoNVX-pTokens-01349,N,None,explicit,VkIndirectCommandsLayoutCreateInfoNVX,(VK_NVX_device_generated_commands), If pTokens contains an entry of VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX it must be the first element of the array and there must be only a single element of such token type.
VUID-VkIndirectCommandsLayoutCreateInfoNVX-pTokens-01350,N,None,explicit,VkIndirectCommandsLayoutCreateInfoNVX,(VK_NVX_device_generated_commands)," All state binding tokens in pTokens must occur prior work provoking tokens (VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX, VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX, VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX)."
VUID-VkIndirectCommandsLayoutCreateInfoNVX-pTokens-01351,N,None,explicit,VkIndirectCommandsLayoutCreateInfoNVX,(VK_NVX_device_generated_commands), The content of pTokens must include one single work provoking token that is compatible with the pipelineBindPoint.
VUID-VkIndirectCommandsLayoutCreateInfoNVX-pTokens-parameter,Y,None,implicit,VkIndirectCommandsLayoutCreateInfoNVX,(VK_NVX_device_generated_commands), pTokens must be a valid pointer to an array of tokenCount valid VkIndirectCommandsLayoutTokenNVX structures
VUID-VkIndirectCommandsLayoutCreateInfoNVX-pipelineBindPoint-parameter,Y,None,implicit,VkIndirectCommandsLayoutCreateInfoNVX,(VK_NVX_device_generated_commands), pipelineBindPoint must be a valid VkPipelineBindPoint value
VUID-VkIndirectCommandsLayoutCreateInfoNVX-sType-sType,Y,None,implicit,VkIndirectCommandsLayoutCreateInfoNVX,(VK_NVX_device_generated_commands), sType must be VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX
VUID-VkIndirectCommandsLayoutCreateInfoNVX-tokenCount-01347,N,None,explicit,VkIndirectCommandsLayoutCreateInfoNVX,(VK_NVX_device_generated_commands), tokenCount must be greater than 0 and below VkDeviceGeneratedCommandsLimitsNVX::maxIndirectCommandsLayoutTokenCount
VUID-VkIndirectCommandsLayoutCreateInfoNVX-tokenCount-arraylength,Y,None,implicit,VkIndirectCommandsLayoutCreateInfoNVX,(VK_NVX_device_generated_commands), tokenCount must be greater than 0
VUID-VkIndirectCommandsLayoutTokenNVX-bindingUnit-01342,N,None,explicit,VkIndirectCommandsLayoutTokenNVX,(VK_NVX_device_generated_commands), bindingUnit must stay within device supported limits for the appropriate commands.
VUID-VkIndirectCommandsLayoutTokenNVX-divisor-01344,N,None,explicit,VkIndirectCommandsLayoutTokenNVX,(VK_NVX_device_generated_commands), divisor must be greater than 0 and a power of two.
VUID-VkIndirectCommandsLayoutTokenNVX-dynamicCount-01343,N,None,explicit,VkIndirectCommandsLayoutTokenNVX,(VK_NVX_device_generated_commands), dynamicCount must stay within device supported limits for the appropriate commands.
VUID-VkIndirectCommandsLayoutTokenNVX-tokenType-parameter,Y,None,implicit,VkIndirectCommandsLayoutTokenNVX,(VK_NVX_device_generated_commands), tokenType must be a valid VkIndirectCommandsTokenTypeNVX value
VUID-VkIndirectCommandsTokenNVX-buffer-01345,N,None,explicit,VkIndirectCommandsTokenNVX,(VK_NVX_device_generated_commands), The buffer's usage flag must have the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set.
VUID-VkIndirectCommandsTokenNVX-buffer-parameter,Y,None,implicit,VkIndirectCommandsTokenNVX,(VK_NVX_device_generated_commands), buffer must be a valid VkBuffer handle
VUID-VkIndirectCommandsTokenNVX-offset-01346,N,None,explicit,VkIndirectCommandsTokenNVX,(VK_NVX_device_generated_commands), The offset must be aligned to VkDeviceGeneratedCommandsLimitsNVX::minCommandsTokenBufferOffsetAlignment.
VUID-VkIndirectCommandsTokenNVX-tokenType-parameter,Y,None,implicit,VkIndirectCommandsTokenNVX,(VK_NVX_device_generated_commands), tokenType must be a valid VkIndirectCommandsTokenTypeNVX value
VUID-VkInputAttachmentAspectReference-aspectMask-01964,N,None,explicit,VkInputAttachmentAspectReference,"(VK_VERSION_1_1,VK_KHR_maintenance2)", aspectMask must not include VK_IMAGE_ASPECT_METADATA_BIT
VUID-VkInputAttachmentAspectReference-aspectMask-parameter,N,None,implicit,VkInputAttachmentAspectReference,"(VK_VERSION_1_1,VK_KHR_maintenance2)", aspectMask must be a valid combination of VkImageAspectFlagBits values
VUID-VkInputAttachmentAspectReference-aspectMask-requiredbitmask,Y,None,implicit,VkInputAttachmentAspectReference,"(VK_VERSION_1_1,VK_KHR_maintenance2)", aspectMask must not be 0
VUID-VkInstanceCreateInfo-flags-zerobitmask,Y,None,implicit,VkInstanceCreateInfo,core, flags must be 0
VUID-VkInstanceCreateInfo-pApplicationInfo-parameter,Y,None,implicit,VkInstanceCreateInfo,core," If pApplicationInfo is not NULL, pApplicationInfo must be a valid pointer to a valid VkApplicationInfo structure"
VUID-VkInstanceCreateInfo-pNext-pNext,Y,None,implicit,VkInstanceCreateInfo,core," Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDebugReportCallbackCreateInfoEXT, VkDebugUtilsMessengerCreateInfoEXT, or VkValidationFlagsEXT"
VUID-VkInstanceCreateInfo-ppEnabledExtensionNames-parameter,Y,None,implicit,VkInstanceCreateInfo,core," If enabledExtensionCount is not 0, ppEnabledExtensionNames must be a valid pointer to an array of enabledExtensionCount null-terminated UTF-8 strings"
VUID-VkInstanceCreateInfo-ppEnabledLayerNames-parameter,Y,None,implicit,VkInstanceCreateInfo,core," If enabledLayerCount is not 0, ppEnabledLayerNames must be a valid pointer to an array of enabledLayerCount null-terminated UTF-8 strings"
VUID-VkInstanceCreateInfo-sType-sType,Y,None,implicit,VkInstanceCreateInfo,core, sType must be VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO
VUID-VkInstanceCreateInfo-sType-unique,N,None,implicit,VkInstanceCreateInfo,core, Each sType member in the pNext chain must be unique
VUID-VkMacOSSurfaceCreateInfoMVK-flags-zerobitmask,Y,None,implicit,VkMacOSSurfaceCreateInfoMVK,(VK_KHR_surface)+(VK_MVK_macos_surface), flags must be 0
VUID-VkMacOSSurfaceCreateInfoMVK-pNext-pNext,Y,None,implicit,VkMacOSSurfaceCreateInfoMVK,(VK_KHR_surface)+(VK_MVK_macos_surface), pNext must be NULL
VUID-VkMacOSSurfaceCreateInfoMVK-pView-01317,N,None,explicit,VkMacOSSurfaceCreateInfoMVK,(VK_KHR_surface)+(VK_MVK_macos_surface), pView must be a valid NSView and must be backed by a CALayer instance of type CAMetalLayer.
VUID-VkMacOSSurfaceCreateInfoMVK-sType-sType,Y,None,implicit,VkMacOSSurfaceCreateInfoMVK,(VK_KHR_surface)+(VK_MVK_macos_surface), sType must be VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK
VUID-VkMappedMemoryRange-memory-00684,N,None,explicit,VkMappedMemoryRange,core, memory must be currently mapped
VUID-VkMappedMemoryRange-memory-parameter,Y,None,implicit,VkMappedMemoryRange,core, memory must be a valid VkDeviceMemory handle
VUID-VkMappedMemoryRange-offset-00687,Y,InvalidMemoryMapping,explicit,VkMappedMemoryRange,core, offset must be a multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize
VUID-VkMappedMemoryRange-pNext-pNext,Y,None,implicit,VkMappedMemoryRange,core, pNext must be NULL
VUID-VkMappedMemoryRange-sType-sType,Y,None,implicit,VkMappedMemoryRange,core, sType must be VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE
VUID-VkMappedMemoryRange-size-00685,Y,InvalidMemoryMapping,explicit,VkMappedMemoryRange,core," If size is not equal to VK_WHOLE_SIZE, offset and size must specify a range contained within the currently mapped range of memory"
VUID-VkMappedMemoryRange-size-00686,Y,InvalidMemoryMapping,explicit,VkMappedMemoryRange,core," If size is equal to VK_WHOLE_SIZE, offset must be within the currently mapped range of memory"
VUID-VkMappedMemoryRange-size-01389,N,None,explicit,VkMappedMemoryRange,core," If size is equal to VK_WHOLE_SIZE, the end of the current mapping of memory must be a multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize bytes from the beginning of the memory object."
VUID-VkMappedMemoryRange-size-01390,Y,InvalidMemoryMapping,explicit,VkMappedMemoryRange,core," If size is not equal to VK_WHOLE_SIZE, size must either be a multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize, or offset plus size must equal the size of memory."
VUID-VkMemoryAllocateFlagsInfo-deviceMask-00675,N,None,explicit,VkMemoryAllocateFlagsInfo,"(VK_VERSION_1_1,VK_KHR_device_group)"," If VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT is set, deviceMask must be a valid device mask."
VUID-VkMemoryAllocateFlagsInfo-deviceMask-00676,N,None,explicit,VkMemoryAllocateFlagsInfo,"(VK_VERSION_1_1,VK_KHR_device_group)"," If VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT is set, deviceMask must not be zero"
VUID-VkMemoryAllocateFlagsInfo-flags-parameter,Y,None,implicit,VkMemoryAllocateFlagsInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", flags must be a valid combination of VkMemoryAllocateFlagBits values
VUID-VkMemoryAllocateFlagsInfo-sType-sType,N,None,implicit,VkMemoryAllocateFlagsInfo,"(VK_VERSION_1_1,VK_KHR_device_group)", sType must be VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO
VUID-VkMemoryAllocateInfo-None-00643,N,None,explicit,VkMemoryAllocateInfo,(VK_KHR_external_memory+VK_KHR_device_group)," If the parameters define an import operation and the external handle specified was created by the Vulkan API, the device mask specified by VkMemoryAllocateFlagsInfo must match that specified when the memory object being imported was allocated."
VUID-VkMemoryAllocateInfo-None-00644,N,None,explicit,VkMemoryAllocateInfo,(VK_KHR_external_memory+VK_KHR_device_group)," If the parameters define an import operation and the external handle specified was created by the Vulkan API, the list of physical devices that comprise the logical device passed to vkAllocateMemory must match the list of physical devices that comprise the logical device on which the memory was originally allocated."
VUID-VkMemoryAllocateInfo-None-01873,N,None,explicit,VkMemoryAllocateInfo,(VK_ANDROID_external_memory_android_hardware_buffer), If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID:
VUID-VkMemoryAllocateInfo-allocationSize-00638,N,None,explicit,VkMemoryAllocateInfo,!(VK_ANDROID_external_memory_android_hardware_buffer), allocationSize must be greater than 0
VUID-VkMemoryAllocateInfo-allocationSize-00646,N,None,explicit,VkMemoryAllocateInfo,(VK_KHR_external_memory_win32)," If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, allocationSize must match the size reported in the memory requirements of the image or buffer member of the instance of VkDedicatedAllocationMemoryAllocateInfoNV included in the pNext chain."
VUID-VkMemoryAllocateInfo-allocationSize-00647,N,None,explicit,VkMemoryAllocateInfo,(VK_KHR_external_memory_win32)," If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, allocationSize must match the size specified when creating the Direct3D 12 heap from which the external handle was extracted."
VUID-VkMemoryAllocateInfo-allocationSize-01742,N,None,explicit,VkMemoryAllocateInfo,(VK_KHR_external_memory_fd)," If the parameters define an import operation, the external handle specified was created by the Vulkan API, and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR, then the values of allocationSize and memoryTypeIndex must match those specified when the memory object being imported was created."
VUID-VkMemoryAllocateInfo-allocationSize-01743,N,None,explicit,VkMemoryAllocateInfo,(VK_KHR_external_memory_win32)," If the parameters define an import operation, the external handle was created by the Vulkan API, and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR or VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR, then the values of allocationSize and memoryTypeIndex must match those specified when the memory object being imported was created."
VUID-VkMemoryAllocateInfo-allocationSize-01745,N,None,explicit,VkMemoryAllocateInfo,(VK_EXT_external_memory_host)," If the parameters define an import operation and the external handle is a host pointer, allocationSize must be an integer multiple of VkPhysicalDeviceExternalMemoryHostPropertiesEXT::minImportedHostPointerAlignment"
VUID-VkMemoryAllocateInfo-memoryTypeIndex-00645,N,None,explicit,VkMemoryAllocateInfo,(VK_KHR_external_memory_win32)," If the parameters define an import operation and the external handle is an NT handle or a global share handle created outside of the Vulkan API, the value of memoryTypeIndex must be one of those returned by vkGetMemoryWin32HandlePropertiesKHR."
VUID-VkMemoryAllocateInfo-memoryTypeIndex-00648,N,None,explicit,VkMemoryAllocateInfo,(VK_KHR_external_memory_fd)," If the parameters define an import operation and the external handle is a POSIX file descriptor created outside of the Vulkan API, the value of memoryTypeIndex must be one of those returned by vkGetMemoryFdPropertiesKHR."
VUID-VkMemoryAllocateInfo-memoryTypeIndex-01744,N,None,explicit,VkMemoryAllocateInfo,(VK_EXT_external_memory_host)," If the parameters define an import operation and the external handle is a host pointer, the value of memoryTypeIndex must be one of those returned by vkGetMemoryHostPointerPropertiesEXT"
VUID-VkMemoryAllocateInfo-memoryTypeIndex-01872,N,None,explicit,VkMemoryAllocateInfo,(VK_VERSION_1_1)," If the protected memory feature is not enabled, the VkMemoryAllocateInfo::memoryTypeIndex must not indicate a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT."
VUID-VkMemoryAllocateInfo-pNext-00639,N,None,explicit,VkMemoryAllocateInfo,"(VK_KHR_external_memory)+(VK_KHR_dedicated_allocation,VK_NV_dedicated_allocation)","     If the pNext chain contains an instance of     VkExportMemoryAllocateInfo, and any of the handle types specified     in VkExportMemoryAllocateInfo::handleTypes require a     dedicated allocation, as reported by     vkGetPhysicalDeviceImageFormatProperties2 in     VkExternalImageFormatProperties::externalMemoryProperties::externalMemoryFeatures     or     VkExternalBufferProperties::externalMemoryProperties::externalMemoryFeatures,     the pNext chain must contain an instance of ifdef::VK_KHR_dedicated_allocation[VkMemoryDedicatedAllocateInfo]"
VUID-VkMemoryAllocateInfo-pNext-00640,N,None,explicit,VkMemoryAllocateInfo,(VK_KHR_external_memory)+(VK_NV_external_memory)," If the pNext chain contains an instance of VkExportMemoryAllocateInfo, it must not contain an instance of VkExportMemoryAllocateInfoNV or VkExportMemoryWin32HandleInfoNV."
VUID-VkMemoryAllocateInfo-pNext-00641,N,None,explicit,VkMemoryAllocateInfo,(VK_KHR_external_memory_win32+VK_NV_external_memory_win32)," If the pNext chain contains an instance of VkImportMemoryWin32HandleInfoKHR, it must not contain an instance of VkImportMemoryWin32HandleInfoNV."
VUID-VkMemoryAllocateInfo-pNext-01874,N,None,explicit,VkMemoryAllocateInfo,(VK_ANDROID_external_memory_android_hardware_buffer)," If the parameters do not define an import operation, and the pNext chain contains an instance of VkExportMemoryAllocateInfo with VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID included in its handleTypes member, and the pNext contains an instance of VkMemoryDedicatedAllocateInfo with image not equal to VK_NULL_HANDLE, then allocationSize must be 0, otherwise allocationSize must be greater than 0."
VUID-VkMemoryAllocateInfo-pNext-01875,N,None,explicit,VkMemoryAllocateInfo,(VK_ANDROID_external_memory_android_hardware_buffer)," If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes an instance of VkMemoryDedicatedAllocateInfo with image that is not VK_NULL_HANDLE:"
VUID-VkMemoryAllocateInfo-pNext-pNext,Y,None,implicit,VkMemoryAllocateInfo,core," Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDedicatedAllocationMemoryAllocateInfoNV, VkExportMemoryAllocateInfo, VkExportMemoryAllocateInfoNV, VkExportMemoryWin32HandleInfoKHR, VkExportMemoryWin32HandleInfoNV, VkImportAndroidHardwareBufferInfoANDROID, VkImportMemoryFdInfoKHR, VkImportMemoryHostPointerInfoEXT, VkImportMemoryWin32HandleInfoKHR, VkImportMemoryWin32HandleInfoNV, VkMemoryAllocateFlagsInfo, or VkMemoryDedicatedAllocateInfo"
VUID-VkMemoryAllocateInfo-sType-sType,Y,None,implicit,VkMemoryAllocateInfo,core, sType must be VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO
VUID-VkMemoryAllocateInfo-sType-unique,N,None,implicit,VkMemoryAllocateInfo,core, Each sType member in the pNext chain must be unique
VUID-VkMemoryBarrier-dstAccessMask-parameter,Y,None,implicit,VkMemoryBarrier,core, dstAccessMask must be a valid combination of VkAccessFlagBits values
VUID-VkMemoryBarrier-pNext-pNext,Y,None,implicit,VkMemoryBarrier,core, pNext must be NULL
VUID-VkMemoryBarrier-sType-sType,Y,None,implicit,VkMemoryBarrier,core, sType must be VK_STRUCTURE_TYPE_MEMORY_BARRIER
VUID-VkMemoryBarrier-srcAccessMask-parameter,Y,None,implicit,VkMemoryBarrier,core, srcAccessMask must be a valid combination of VkAccessFlagBits values
VUID-VkMemoryDedicatedAllocateInfo-buffer-01435,N,None,explicit,VkMemoryDedicatedAllocateInfo,"(VK_VERSION_1_1,VK_KHR_dedicated_allocation)"," If buffer is not VK_NULL_HANDLE, VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the buffer"
VUID-VkMemoryDedicatedAllocateInfo-buffer-01436,N,None,explicit,VkMemoryDedicatedAllocateInfo,"(VK_VERSION_1_1,VK_KHR_dedicated_allocation)"," If buffer is not VK_NULL_HANDLE, buffer must have been created without VK_BUFFER_CREATE_SPARSE_BINDING_BIT set in VkBufferCreateInfo::flags"
VUID-VkMemoryDedicatedAllocateInfo-buffer-01877,N,None,explicit,VkMemoryDedicatedAllocateInfo,"(VK_VERSION_1_1,VK_KHR_dedicated_allocation)+(VK_KHR_external_memory_win32)"," If buffer is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, and the external handle was created by the Vulkan API, then the memory being imported must also be a dedicated buffer allocation and buffer must be identical to the buffer associated with the imported memory."
VUID-VkMemoryDedicatedAllocateInfo-buffer-01879,N,None,explicit,VkMemoryDedicatedAllocateInfo,"(VK_VERSION_1_1,VK_KHR_dedicated_allocation)+(VK_KHR_external_memory_fd)"," If buffer is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT, the memory being imported must also be a dedicated buffer allocation and buffer must be identical to the buffer associated with the imported memory."
VUID-VkMemoryDedicatedAllocateInfo-buffer-parameter,N,None,implicit,VkMemoryDedicatedAllocateInfo,"(VK_VERSION_1_1,VK_KHR_dedicated_allocation)"," If buffer is not VK_NULL_HANDLE, buffer must be a valid VkBuffer handle"
VUID-VkMemoryDedicatedAllocateInfo-commonparent,N,None,implicit,VkMemoryDedicatedAllocateInfo,"(VK_VERSION_1_1,VK_KHR_dedicated_allocation)"," Both of buffer, and image that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkMemoryDedicatedAllocateInfo-image-01432,N,None,explicit,VkMemoryDedicatedAllocateInfo,"(VK_VERSION_1_1,VK_KHR_dedicated_allocation)", At least one of image and buffer must be VK_NULL_HANDLE
VUID-VkMemoryDedicatedAllocateInfo-image-01433,N,None,explicit,VkMemoryDedicatedAllocateInfo,"(VK_VERSION_1_1,VK_KHR_dedicated_allocation)"," If image is not VK_NULL_HANDLE, VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the image"
VUID-VkMemoryDedicatedAllocateInfo-image-01434,N,None,explicit,VkMemoryDedicatedAllocateInfo,"(VK_VERSION_1_1,VK_KHR_dedicated_allocation)"," If image is not VK_NULL_HANDLE, image must have been created without VK_IMAGE_CREATE_SPARSE_BINDING_BIT set in VkImageCreateInfo::flags"
VUID-VkMemoryDedicatedAllocateInfo-image-01797,N,None,explicit,VkMemoryDedicatedAllocateInfo,"(VK_VERSION_1_1,VK_KHR_dedicated_allocation)+(VK_KHR_sampler_ycbcr_conversion)"," If image is not VK_NULL_HANDLE, image must not have been created with VK_IMAGE_CREATE_DISJOINT_BIT set in VkImageCreateInfo::flags"
VUID-VkMemoryDedicatedAllocateInfo-image-01876,N,None,explicit,VkMemoryDedicatedAllocateInfo,"(VK_VERSION_1_1,VK_KHR_dedicated_allocation)+(VK_KHR_external_memory_win32)"," If image is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, and the external handle was created by the Vulkan API, then the memory being imported must also be a dedicated image allocation and image must be identical to the image associated with the imported memory."
VUID-VkMemoryDedicatedAllocateInfo-image-01878,N,None,explicit,VkMemoryDedicatedAllocateInfo,"(VK_VERSION_1_1,VK_KHR_dedicated_allocation)+(VK_KHR_external_memory_fd)"," If image is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT, the memory being imported must also be a dedicated image allocation and image must be identical to the image associated with the imported memory."
VUID-VkMemoryDedicatedAllocateInfo-image-parameter,N,None,implicit,VkMemoryDedicatedAllocateInfo,"(VK_VERSION_1_1,VK_KHR_dedicated_allocation)"," If image is not VK_NULL_HANDLE, image must be a valid VkImage handle"
VUID-VkMemoryDedicatedAllocateInfo-sType-sType,N,None,implicit,VkMemoryDedicatedAllocateInfo,"(VK_VERSION_1_1,VK_KHR_dedicated_allocation)", sType must be VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO
VUID-VkMemoryDedicatedRequirements-sType-sType,N,None,implicit,VkMemoryDedicatedRequirements,"(VK_VERSION_1_1,VK_KHR_dedicated_allocation)", sType must be VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS
VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-handleTypes-01882,N,None,explicit,VkMemoryGetAndroidHardwareBufferInfoANDROID,(VK_ANDROID_external_memory_android_hardware_buffer), VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID must have been included in VkExportMemoryAllocateInfoKHR::handleTypes when memory was created.
VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-pNext-01883,N,None,explicit,VkMemoryGetAndroidHardwareBufferInfoANDROID,(VK_ANDROID_external_memory_android_hardware_buffer)," If the pNext chain of the VkMemoryAllocateInfo used to allocate memory included a VkMemoryDedicatedAllocateInfo with non-NULL image member, then that image must already be bound to memory."
VUID-VkMemoryGetFdInfoKHR-handleType-00671,N,None,explicit,VkMemoryGetFdInfoKHR,(VK_KHR_external_memory_fd), handleType must have been included in VkExportMemoryAllocateInfo::handleTypes when memory was created.
VUID-VkMemoryGetFdInfoKHR-handleType-00672,N,None,explicit,VkMemoryGetFdInfoKHR,(VK_KHR_external_memory_fd), handleType must be defined as a POSIX file descriptor handle.
VUID-VkMemoryGetFdInfoKHR-handleType-parameter,Y,None,implicit,VkMemoryGetFdInfoKHR,(VK_KHR_external_memory_fd), handleType must be a valid VkExternalMemoryHandleTypeFlagBits value
VUID-VkMemoryGetFdInfoKHR-memory-parameter,Y,None,implicit,VkMemoryGetFdInfoKHR,(VK_KHR_external_memory_fd), memory must be a valid VkDeviceMemory handle
VUID-VkMemoryGetFdInfoKHR-pNext-pNext,Y,None,implicit,VkMemoryGetFdInfoKHR,(VK_KHR_external_memory_fd), pNext must be NULL
VUID-VkMemoryGetFdInfoKHR-sType-sType,Y,None,implicit,VkMemoryGetFdInfoKHR,(VK_KHR_external_memory_fd), sType must be VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR
VUID-VkMemoryGetWin32HandleInfoKHR-handleType-00662,N,None,explicit,VkMemoryGetWin32HandleInfoKHR,(VK_KHR_external_memory_win32), handleType must have been included in VkExportMemoryAllocateInfo::handleTypes when memory was created.
VUID-VkMemoryGetWin32HandleInfoKHR-handleType-00663,N,None,explicit,VkMemoryGetWin32HandleInfoKHR,(VK_KHR_external_memory_win32)," If handleType is defined as an NT handle, vkGetMemoryWin32HandleKHR must be called no more than once for each valid unique combination of memory and handleType."
VUID-VkMemoryGetWin32HandleInfoKHR-handleType-00664,N,None,explicit,VkMemoryGetWin32HandleInfoKHR,(VK_KHR_external_memory_win32), handleType must be defined as an NT handle or a global share handle.
VUID-VkMemoryGetWin32HandleInfoKHR-handleType-parameter,Y,None,implicit,VkMemoryGetWin32HandleInfoKHR,(VK_KHR_external_memory_win32), handleType must be a valid VkExternalMemoryHandleTypeFlagBits value
VUID-VkMemoryGetWin32HandleInfoKHR-memory-parameter,Y,None,implicit,VkMemoryGetWin32HandleInfoKHR,(VK_KHR_external_memory_win32), memory must be a valid VkDeviceMemory handle
VUID-VkMemoryGetWin32HandleInfoKHR-pNext-pNext,Y,None,implicit,VkMemoryGetWin32HandleInfoKHR,(VK_KHR_external_memory_win32), pNext must be NULL
VUID-VkMemoryGetWin32HandleInfoKHR-sType-sType,Y,None,implicit,VkMemoryGetWin32HandleInfoKHR,(VK_KHR_external_memory_win32), sType must be VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR
VUID-VkMemoryHostPointerPropertiesEXT-pNext-pNext,N,None,implicit,VkMemoryHostPointerPropertiesEXT,(VK_EXT_external_memory_host), pNext must be NULL
VUID-VkMemoryHostPointerPropertiesEXT-sType-sType,Y,None,implicit,VkMemoryHostPointerPropertiesEXT,(VK_EXT_external_memory_host), sType must be VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT
VUID-VkMemoryRequirements2-pNext-pNext,Y,None,implicit,VkMemoryRequirements2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", pNext must be NULL or a pointer to a valid instance of VkMemoryDedicatedRequirements
VUID-VkMemoryRequirements2-sType-sType,Y,None,implicit,VkMemoryRequirements2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", sType must be VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2
VUID-VkMirSurfaceCreateInfoKHR-connection-01263,N,None,explicit,VkMirSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_mir_surface), connection must point to a valid MirConnection.
VUID-VkMirSurfaceCreateInfoKHR-flags-zerobitmask,Y,None,implicit,VkMirSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_mir_surface), flags must be 0
VUID-VkMirSurfaceCreateInfoKHR-pNext-pNext,Y,None,implicit,VkMirSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_mir_surface), pNext must be NULL
VUID-VkMirSurfaceCreateInfoKHR-sType-sType,Y,None,implicit,VkMirSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_mir_surface), sType must be VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR
VUID-VkMirSurfaceCreateInfoKHR-surface-01264,N,None,explicit,VkMirSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_mir_surface), surface must point to a valid MirSurface.
VUID-VkMultisamplePropertiesEXT-pNext-pNext,Y,None,implicit,VkMultisamplePropertiesEXT,(VK_EXT_sample_locations), pNext must be NULL
VUID-VkMultisamplePropertiesEXT-sType-sType,Y,None,implicit,VkMultisamplePropertiesEXT,(VK_EXT_sample_locations), sType must be VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT
VUID-VkObjectTableCreateInfoNVX-computeBindingPointSupport-01355,N,None,explicit,VkObjectTableCreateInfoNVX,(VK_NVX_device_generated_commands)," If the VkDeviceGeneratedCommandsFeaturesNVX::computeBindingPointSupport feature is not enabled, pObjectEntryUsageFlags must not contain VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX"
VUID-VkObjectTableCreateInfoNVX-maxSampledImagesPerDescriptor-01360,N,None,explicit,VkObjectTableCreateInfoNVX,(VK_NVX_device_generated_commands), maxSampledImagesPerDescriptor must be within the limits supported by the device.
VUID-VkObjectTableCreateInfoNVX-maxStorageBuffersPerDescriptor-01358,N,None,explicit,VkObjectTableCreateInfoNVX,(VK_NVX_device_generated_commands), maxStorageBuffersPerDescriptor must be within the limits supported by the device.
VUID-VkObjectTableCreateInfoNVX-maxStorageImagesPerDescriptor-01359,N,None,explicit,VkObjectTableCreateInfoNVX,(VK_NVX_device_generated_commands), maxStorageImagesPerDescriptor must be within the limits supported by the device.
VUID-VkObjectTableCreateInfoNVX-maxUniformBuffersPerDescriptor-01357,N,None,explicit,VkObjectTableCreateInfoNVX,(VK_NVX_device_generated_commands), maxUniformBuffersPerDescriptor must be within the limits supported by the device.
VUID-VkObjectTableCreateInfoNVX-objectCount-arraylength,Y,None,implicit,VkObjectTableCreateInfoNVX,(VK_NVX_device_generated_commands), objectCount must be greater than 0
VUID-VkObjectTableCreateInfoNVX-pNext-pNext,Y,None,implicit,VkObjectTableCreateInfoNVX,(VK_NVX_device_generated_commands), pNext must be NULL
VUID-VkObjectTableCreateInfoNVX-pObjectEntryCounts-01356,N,None,explicit,VkObjectTableCreateInfoNVX,(VK_NVX_device_generated_commands), Any value within pObjectEntryCounts must not exceed VkDeviceGeneratedCommandsLimitsNVX::maxObjectEntryCounts
VUID-VkObjectTableCreateInfoNVX-pObjectEntryCounts-parameter,Y,None,implicit,VkObjectTableCreateInfoNVX,(VK_NVX_device_generated_commands), pObjectEntryCounts must be a valid pointer to an array of objectCount uint32_t values
VUID-VkObjectTableCreateInfoNVX-pObjectEntryTypes-parameter,N,None,implicit,VkObjectTableCreateInfoNVX,(VK_NVX_device_generated_commands), pObjectEntryTypes must be a valid pointer to an array of objectCount valid VkObjectEntryTypeNVX values
VUID-VkObjectTableCreateInfoNVX-pObjectEntryUsageFlags-parameter,N,None,implicit,VkObjectTableCreateInfoNVX,(VK_NVX_device_generated_commands), pObjectEntryUsageFlags must be a valid pointer to an array of objectCount valid combinations of VkObjectEntryUsageFlagBitsNVX values
VUID-VkObjectTableCreateInfoNVX-pObjectEntryUsageFlags-requiredbitmask,N,None,implicit,VkObjectTableCreateInfoNVX,(VK_NVX_device_generated_commands), Each element of pObjectEntryUsageFlags must not be 0
VUID-VkObjectTableCreateInfoNVX-sType-sType,Y,None,implicit,VkObjectTableCreateInfoNVX,(VK_NVX_device_generated_commands), sType must be VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX
VUID-VkObjectTableDescriptorSetEntryNVX-commonparent,N,None,implicit,VkObjectTableDescriptorSetEntryNVX,(VK_NVX_device_generated_commands)," Both of descriptorSet, and pipelineLayout must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkObjectTableDescriptorSetEntryNVX-descriptorSet-parameter,N,None,implicit,VkObjectTableDescriptorSetEntryNVX,(VK_NVX_device_generated_commands), descriptorSet must be a valid VkDescriptorSet handle
VUID-VkObjectTableDescriptorSetEntryNVX-flags-parameter,N,None,implicit,VkObjectTableDescriptorSetEntryNVX,(VK_NVX_device_generated_commands), flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values
VUID-VkObjectTableDescriptorSetEntryNVX-flags-requiredbitmask,N,None,implicit,VkObjectTableDescriptorSetEntryNVX,(VK_NVX_device_generated_commands), flags must not be 0
VUID-VkObjectTableDescriptorSetEntryNVX-pipelineLayout-parameter,N,None,implicit,VkObjectTableDescriptorSetEntryNVX,(VK_NVX_device_generated_commands), pipelineLayout must be a valid VkPipelineLayout handle
VUID-VkObjectTableDescriptorSetEntryNVX-type-01369,N,None,explicit,VkObjectTableDescriptorSetEntryNVX,(VK_NVX_device_generated_commands), type must be VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX
VUID-VkObjectTableDescriptorSetEntryNVX-type-parameter,N,None,implicit,VkObjectTableDescriptorSetEntryNVX,(VK_NVX_device_generated_commands), type must be a valid VkObjectEntryTypeNVX value
VUID-VkObjectTableEntryNVX-computeBindingPointSupport-01367,N,None,explicit,VkObjectTableEntryNVX,(VK_NVX_device_generated_commands)," If the VkDeviceGeneratedCommandsFeaturesNVX::computeBindingPointSupport feature is not enabled, flags must not contain VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX"
VUID-VkObjectTableEntryNVX-flags-parameter,N,None,implicit,VkObjectTableEntryNVX,(VK_NVX_device_generated_commands), flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values
VUID-VkObjectTableEntryNVX-flags-requiredbitmask,Y,None,implicit,VkObjectTableEntryNVX,(VK_NVX_device_generated_commands), flags must not be 0
VUID-VkObjectTableEntryNVX-type-parameter,Y,None,implicit,VkObjectTableEntryNVX,(VK_NVX_device_generated_commands), type must be a valid VkObjectEntryTypeNVX value
VUID-VkObjectTableIndexBufferEntryNVX-buffer-parameter,N,None,implicit,VkObjectTableIndexBufferEntryNVX,(VK_NVX_device_generated_commands), buffer must be a valid VkBuffer handle
VUID-VkObjectTableIndexBufferEntryNVX-flags-parameter,N,None,implicit,VkObjectTableIndexBufferEntryNVX,(VK_NVX_device_generated_commands), flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values
VUID-VkObjectTableIndexBufferEntryNVX-flags-requiredbitmask,N,None,implicit,VkObjectTableIndexBufferEntryNVX,(VK_NVX_device_generated_commands), flags must not be 0
VUID-VkObjectTableIndexBufferEntryNVX-indexType-parameter,N,None,implicit,VkObjectTableIndexBufferEntryNVX,(VK_NVX_device_generated_commands), indexType must be a valid VkIndexType value
VUID-VkObjectTableIndexBufferEntryNVX-type-01371,N,None,explicit,VkObjectTableIndexBufferEntryNVX,(VK_NVX_device_generated_commands), type must be VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX
VUID-VkObjectTableIndexBufferEntryNVX-type-parameter,N,None,implicit,VkObjectTableIndexBufferEntryNVX,(VK_NVX_device_generated_commands), type must be a valid VkObjectEntryTypeNVX value
VUID-VkObjectTablePipelineEntryNVX-flags-parameter,N,None,implicit,VkObjectTablePipelineEntryNVX,(VK_NVX_device_generated_commands), flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values
VUID-VkObjectTablePipelineEntryNVX-flags-requiredbitmask,N,None,implicit,VkObjectTablePipelineEntryNVX,(VK_NVX_device_generated_commands), flags must not be 0
VUID-VkObjectTablePipelineEntryNVX-pipeline-parameter,N,None,implicit,VkObjectTablePipelineEntryNVX,(VK_NVX_device_generated_commands), pipeline must be a valid VkPipeline handle
VUID-VkObjectTablePipelineEntryNVX-type-01368,N,None,explicit,VkObjectTablePipelineEntryNVX,(VK_NVX_device_generated_commands), type must be VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX
VUID-VkObjectTablePipelineEntryNVX-type-parameter,N,None,implicit,VkObjectTablePipelineEntryNVX,(VK_NVX_device_generated_commands), type must be a valid VkObjectEntryTypeNVX value
VUID-VkObjectTablePushConstantEntryNVX-flags-parameter,N,None,implicit,VkObjectTablePushConstantEntryNVX,(VK_NVX_device_generated_commands), flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values
VUID-VkObjectTablePushConstantEntryNVX-flags-requiredbitmask,N,None,implicit,VkObjectTablePushConstantEntryNVX,(VK_NVX_device_generated_commands), flags must not be 0
VUID-VkObjectTablePushConstantEntryNVX-pipelineLayout-parameter,N,None,implicit,VkObjectTablePushConstantEntryNVX,(VK_NVX_device_generated_commands), pipelineLayout must be a valid VkPipelineLayout handle
VUID-VkObjectTablePushConstantEntryNVX-stageFlags-parameter,N,None,implicit,VkObjectTablePushConstantEntryNVX,(VK_NVX_device_generated_commands), stageFlags must be a valid combination of VkShaderStageFlagBits values
VUID-VkObjectTablePushConstantEntryNVX-stageFlags-requiredbitmask,N,None,implicit,VkObjectTablePushConstantEntryNVX,(VK_NVX_device_generated_commands), stageFlags must not be 0
VUID-VkObjectTablePushConstantEntryNVX-type-01372,N,None,explicit,VkObjectTablePushConstantEntryNVX,(VK_NVX_device_generated_commands), type must be VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX
VUID-VkObjectTablePushConstantEntryNVX-type-parameter,N,None,implicit,VkObjectTablePushConstantEntryNVX,(VK_NVX_device_generated_commands), type must be a valid VkObjectEntryTypeNVX value
VUID-VkObjectTableVertexBufferEntryNVX-buffer-parameter,N,None,implicit,VkObjectTableVertexBufferEntryNVX,(VK_NVX_device_generated_commands), buffer must be a valid VkBuffer handle
VUID-VkObjectTableVertexBufferEntryNVX-flags-parameter,N,None,implicit,VkObjectTableVertexBufferEntryNVX,(VK_NVX_device_generated_commands), flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values
VUID-VkObjectTableVertexBufferEntryNVX-flags-requiredbitmask,N,None,implicit,VkObjectTableVertexBufferEntryNVX,(VK_NVX_device_generated_commands), flags must not be 0
VUID-VkObjectTableVertexBufferEntryNVX-type-01370,N,None,explicit,VkObjectTableVertexBufferEntryNVX,(VK_NVX_device_generated_commands), type must be VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX
VUID-VkObjectTableVertexBufferEntryNVX-type-parameter,N,None,implicit,VkObjectTableVertexBufferEntryNVX,(VK_NVX_device_generated_commands), type must be a valid VkObjectEntryTypeNVX value
VUID-VkPhysicalDevice16BitStorageFeatures-sType-sType,N,None,implicit,VkPhysicalDevice16BitStorageFeatures,"(VK_VERSION_1_1,VK_KHR_16bit_storage)", sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES
VUID-VkPhysicalDevice8BitStorageFeaturesKHR-sType-sType,N,None,implicit,VkPhysicalDevice8BitStorageFeaturesKHR,(VK_KHR_8bit_storage), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR
VUID-VkPhysicalDeviceASTCDecodeFeaturesEXT-sType-sType,N,None,implicit,VkPhysicalDeviceASTCDecodeFeaturesEXT,(VK_EXT_astc_decode_mode), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT
VUID-VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT-sType-sType,N,None,implicit,VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT,(VK_EXT_blend_operation_advanced), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT
VUID-VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT-sType-sType,N,None,implicit,VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,(VK_EXT_blend_operation_advanced), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT
VUID-VkPhysicalDeviceComputeShaderDerivativesFeaturesNV-sType-sType,N,None,implicit,VkPhysicalDeviceComputeShaderDerivativesFeaturesNV,(VK_NV_compute_shader_derivatives), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV
VUID-VkPhysicalDeviceConditionalRenderingFeaturesEXT-sType-sType,N,None,implicit,VkPhysicalDeviceConditionalRenderingFeaturesEXT,(VK_EXT_conditional_rendering), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT
VUID-VkPhysicalDeviceConservativeRasterizationPropertiesEXT-sType-sType,N,None,implicit,VkPhysicalDeviceConservativeRasterizationPropertiesEXT,(VK_EXT_conservative_rasterization), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT
VUID-VkPhysicalDeviceCornerSampledImageFeaturesNV-sType-sType,N,None,implicit,VkPhysicalDeviceCornerSampledImageFeaturesNV,(VK_NV_corner_sampled_image), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV
VUID-VkPhysicalDeviceDescriptorIndexingFeaturesEXT-sType-sType,N,None,implicit,VkPhysicalDeviceDescriptorIndexingFeaturesEXT,(VK_EXT_descriptor_indexing), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT
VUID-VkPhysicalDeviceDescriptorIndexingPropertiesEXT-sType-sType,N,None,implicit,VkPhysicalDeviceDescriptorIndexingPropertiesEXT,(VK_EXT_descriptor_indexing), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT
VUID-VkPhysicalDeviceDiscardRectanglePropertiesEXT-sType-sType,N,None,implicit,VkPhysicalDeviceDiscardRectanglePropertiesEXT,(VK_EXT_discard_rectangles), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT
VUID-VkPhysicalDeviceExclusiveScissorFeaturesNV-sType-sType,N,None,implicit,VkPhysicalDeviceExclusiveScissorFeaturesNV,(VK_NV_scissor_exclusive), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV
VUID-VkPhysicalDeviceExternalBufferInfo-flags-parameter,Y,None,implicit,VkPhysicalDeviceExternalBufferInfo,"(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)", flags must be a valid combination of VkBufferCreateFlagBits values
VUID-VkPhysicalDeviceExternalBufferInfo-handleType-parameter,Y,None,implicit,VkPhysicalDeviceExternalBufferInfo,"(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)", handleType must be a valid VkExternalMemoryHandleTypeFlagBits value
VUID-VkPhysicalDeviceExternalBufferInfo-pNext-pNext,Y,None,implicit,VkPhysicalDeviceExternalBufferInfo,"(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)", pNext must be NULL
VUID-VkPhysicalDeviceExternalBufferInfo-sType-sType,Y,None,implicit,VkPhysicalDeviceExternalBufferInfo,"(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)", sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO
VUID-VkPhysicalDeviceExternalBufferInfo-usage-parameter,N,None,implicit,VkPhysicalDeviceExternalBufferInfo,"(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)", usage must be a valid combination of VkBufferUsageFlagBits values
VUID-VkPhysicalDeviceExternalBufferInfo-usage-requiredbitmask,Y,None,implicit,VkPhysicalDeviceExternalBufferInfo,"(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)", usage must not be 0
VUID-VkPhysicalDeviceExternalFenceInfo-handleType-parameter,Y,None,implicit,VkPhysicalDeviceExternalFenceInfo,"(VK_VERSION_1_1,VK_KHR_external_fence_capabilities)", handleType must be a valid VkExternalFenceHandleTypeFlagBits value
VUID-VkPhysicalDeviceExternalFenceInfo-pNext-pNext,Y,None,implicit,VkPhysicalDeviceExternalFenceInfo,"(VK_VERSION_1_1,VK_KHR_external_fence_capabilities)", pNext must be NULL
VUID-VkPhysicalDeviceExternalFenceInfo-sType-sType,Y,None,implicit,VkPhysicalDeviceExternalFenceInfo,"(VK_VERSION_1_1,VK_KHR_external_fence_capabilities)", sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO
VUID-VkPhysicalDeviceExternalImageFormatInfo-handleType-parameter,Y,None,implicit,VkPhysicalDeviceExternalImageFormatInfo,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)"," If handleType is not 0, handleType must be a valid VkExternalMemoryHandleTypeFlagBits value"
VUID-VkPhysicalDeviceExternalImageFormatInfo-sType-sType,N,None,implicit,VkPhysicalDeviceExternalImageFormatInfo,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)", sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO
VUID-VkPhysicalDeviceExternalMemoryHostPropertiesEXT-sType-sType,N,None,implicit,VkPhysicalDeviceExternalMemoryHostPropertiesEXT,(VK_EXT_external_memory_host), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT
VUID-VkPhysicalDeviceExternalSemaphoreInfo-handleType-parameter,Y,None,implicit,VkPhysicalDeviceExternalSemaphoreInfo,"(VK_VERSION_1_1,VK_KHR_external_semaphore_capabilities)", handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value
VUID-VkPhysicalDeviceExternalSemaphoreInfo-pNext-pNext,Y,None,implicit,VkPhysicalDeviceExternalSemaphoreInfo,"(VK_VERSION_1_1,VK_KHR_external_semaphore_capabilities)", pNext must be NULL
VUID-VkPhysicalDeviceExternalSemaphoreInfo-sType-sType,Y,None,implicit,VkPhysicalDeviceExternalSemaphoreInfo,"(VK_VERSION_1_1,VK_KHR_external_semaphore_capabilities)", sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO
VUID-VkPhysicalDeviceFeatures2-sType-sType,Y,None,implicit,VkPhysicalDeviceFeatures2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2
VUID-VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV-sType-sType,N,None,implicit,VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV,(VK_NV_fragment_shader_barycentric), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV
VUID-VkPhysicalDeviceIDProperties-sType-sType,N,None,implicit,VkPhysicalDeviceIDProperties,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_VERSION_1_1,VK_KHR_external_memory_capabilities,VK_KHR_external_semaphore_capabilities,VK_KHR_external_fence_capabilities)", sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES
VUID-VkPhysicalDeviceImageFormatInfo2-flags-parameter,Y,None,implicit,VkPhysicalDeviceImageFormatInfo2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", flags must be a valid combination of VkImageCreateFlagBits values
VUID-VkPhysicalDeviceImageFormatInfo2-format-parameter,Y,None,implicit,VkPhysicalDeviceImageFormatInfo2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", format must be a valid VkFormat value
VUID-VkPhysicalDeviceImageFormatInfo2-pNext-pNext,Y,None,implicit,VkPhysicalDeviceImageFormatInfo2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", pNext must be NULL or a pointer to a valid instance of VkPhysicalDeviceExternalImageFormatInfo
VUID-VkPhysicalDeviceImageFormatInfo2-sType-sType,Y,None,implicit,VkPhysicalDeviceImageFormatInfo2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2
VUID-VkPhysicalDeviceImageFormatInfo2-tiling-parameter,Y,None,implicit,VkPhysicalDeviceImageFormatInfo2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", tiling must be a valid VkImageTiling value
VUID-VkPhysicalDeviceImageFormatInfo2-type-parameter,Y,None,implicit,VkPhysicalDeviceImageFormatInfo2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", type must be a valid VkImageType value
VUID-VkPhysicalDeviceImageFormatInfo2-usage-parameter,N,None,implicit,VkPhysicalDeviceImageFormatInfo2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", usage must be a valid combination of VkImageUsageFlagBits values
VUID-VkPhysicalDeviceImageFormatInfo2-usage-requiredbitmask,Y,None,implicit,VkPhysicalDeviceImageFormatInfo2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", usage must not be 0
VUID-VkPhysicalDeviceInlineUniformBlockFeaturesEXT-sType-sType,N,None,implicit,VkPhysicalDeviceInlineUniformBlockFeaturesEXT,(VK_EXT_inline_uniform_block), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT
VUID-VkPhysicalDeviceInlineUniformBlockPropertiesEXT-sType-sType,N,None,implicit,VkPhysicalDeviceInlineUniformBlockPropertiesEXT,(VK_EXT_inline_uniform_block), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT
VUID-VkPhysicalDeviceMaintenance3Properties-sType-sType,N,None,implicit,VkPhysicalDeviceMaintenance3Properties,"(VK_VERSION_1_1,VK_KHR_maintenance3)", sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES
VUID-VkPhysicalDeviceMemoryProperties2-pNext-pNext,Y,None,implicit,VkPhysicalDeviceMemoryProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", pNext must be NULL
VUID-VkPhysicalDeviceMemoryProperties2-sType-sType,Y,None,implicit,VkPhysicalDeviceMemoryProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2
VUID-VkPhysicalDeviceMeshShaderFeaturesNV-sType-sType,N,None,implicit,VkPhysicalDeviceMeshShaderFeaturesNV,(VK_NV_mesh_shader), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV
VUID-VkPhysicalDeviceMeshShaderPropertiesNV-sType-sType,N,None,implicit,VkPhysicalDeviceMeshShaderPropertiesNV,(VK_NV_mesh_shader), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV
VUID-VkPhysicalDeviceMultiviewFeatures-multiviewGeometryShader-00580,N,None,explicit,VkPhysicalDeviceMultiviewFeatures,"(VK_VERSION_1_1,VK_KHR_multiview)", If multiviewGeometryShader is enabled then multiview must also be enabled.
VUID-VkPhysicalDeviceMultiviewFeatures-multiviewTessellationShader-00581,N,None,explicit,VkPhysicalDeviceMultiviewFeatures,"(VK_VERSION_1_1,VK_KHR_multiview)", If multiviewTessellationShader is enabled then multiview must also be enabled.
VUID-VkPhysicalDeviceMultiviewFeatures-sType-sType,N,None,implicit,VkPhysicalDeviceMultiviewFeatures,"(VK_VERSION_1_1,VK_KHR_multiview)", sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES
VUID-VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX-sType-sType,N,None,implicit,VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX,(VK_NVX_multiview_per_view_attributes), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX
VUID-VkPhysicalDeviceMultiviewProperties-sType-sType,N,None,implicit,VkPhysicalDeviceMultiviewProperties,"(VK_VERSION_1_1,VK_KHR_multiview)", sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES
VUID-VkPhysicalDevicePointClippingProperties-sType-sType,N,None,implicit,VkPhysicalDevicePointClippingProperties,"(VK_VERSION_1_1,VK_KHR_maintenance2)", sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES
VUID-VkPhysicalDeviceProperties2-pNext-pNext,Y,None,implicit,VkPhysicalDeviceProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)"," Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, VkPhysicalDeviceConservativeRasterizationPropertiesEXT, VkPhysicalDeviceDescriptorIndexingPropertiesEXT, VkPhysicalDeviceDiscardRectanglePropertiesEXT, VkPhysicalDeviceExternalMemoryHostPropertiesEXT, VkPhysicalDeviceIDProperties, VkPhysicalDeviceInlineUniformBlockPropertiesEXT, VkPhysicalDeviceMaintenance3Properties, VkPhysicalDeviceMeshShaderPropertiesNV, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, VkPhysicalDeviceMultiviewProperties, VkPhysicalDevicePointClippingProperties, VkPhysicalDeviceProtectedMemoryProperties, VkPhysicalDevicePushDescriptorPropertiesKHR, VkPhysicalDeviceRaytracingPropertiesNVX, VkPhysicalDeviceSampleLocationsPropertiesEXT, VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT, VkPhysicalDeviceShaderCorePropertiesAMD, VkPhysicalDeviceSubgroupProperties, or VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT"
VUID-VkPhysicalDeviceProperties2-sType-sType,Y,None,implicit,VkPhysicalDeviceProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2
VUID-VkPhysicalDeviceProperties2-sType-unique,N,None,implicit,VkPhysicalDeviceProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", Each sType member in the pNext chain must be unique
VUID-VkPhysicalDeviceProtectedMemoryFeatures-sType-sType,N,None,implicit,VkPhysicalDeviceProtectedMemoryFeatures,(VK_VERSION_1_1), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES
VUID-VkPhysicalDeviceProtectedMemoryProperties-sType-sType,N,None,implicit,VkPhysicalDeviceProtectedMemoryProperties,(VK_VERSION_1_1), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES
VUID-VkPhysicalDevicePushDescriptorPropertiesKHR-sType-sType,N,None,implicit,VkPhysicalDevicePushDescriptorPropertiesKHR,(VK_KHR_push_descriptor), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR
VUID-VkPhysicalDeviceRaytracingPropertiesNVX-sType-sType,N,None,implicit,VkPhysicalDeviceRaytracingPropertiesNVX,(VK_NVX_raytracing), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAYTRACING_PROPERTIES_NVX
VUID-VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV-sType-sType,N,None,implicit,VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV,(VK_NV_representative_fragment_test), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV
VUID-VkPhysicalDeviceSampleLocationsPropertiesEXT-sType-sType,N,None,implicit,VkPhysicalDeviceSampleLocationsPropertiesEXT,(VK_EXT_sample_locations), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT
VUID-VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT-sType-sType,N,None,implicit,VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT,(VK_EXT_sampler_filter_minmax), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT
VUID-VkPhysicalDeviceSamplerYcbcrConversionFeatures-sType-sType,N,None,implicit,VkPhysicalDeviceSamplerYcbcrConversionFeatures,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES
VUID-VkPhysicalDeviceShaderCorePropertiesAMD-sType-sType,N,None,implicit,VkPhysicalDeviceShaderCorePropertiesAMD,(VK_AMD_shader_core_properties), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD
VUID-VkPhysicalDeviceShaderDrawParameterFeatures-sType-sType,N,None,implicit,VkPhysicalDeviceShaderDrawParameterFeatures,(VK_VERSION_1_1), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES
VUID-VkPhysicalDeviceShaderImageFootprintFeaturesNV-sType-sType,N,None,implicit,VkPhysicalDeviceShaderImageFootprintFeaturesNV,(VK_NV_shader_image_footprint), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV
VUID-VkPhysicalDeviceShadingRateImageFeaturesNV-sType-sType,N,None,implicit,VkPhysicalDeviceShadingRateImageFeaturesNV,(VK_NV_shading_rate_image), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV
VUID-VkPhysicalDeviceShadingRateImagePropertiesNV-sType-sType,N,None,implicit,VkPhysicalDeviceShadingRateImagePropertiesNV,(VK_NV_shading_rate_image), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV
VUID-VkPhysicalDeviceSparseImageFormatInfo2-format-parameter,Y,None,implicit,VkPhysicalDeviceSparseImageFormatInfo2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", format must be a valid VkFormat value
VUID-VkPhysicalDeviceSparseImageFormatInfo2-pNext-pNext,Y,None,implicit,VkPhysicalDeviceSparseImageFormatInfo2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", pNext must be NULL
VUID-VkPhysicalDeviceSparseImageFormatInfo2-sType-sType,Y,None,implicit,VkPhysicalDeviceSparseImageFormatInfo2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2
VUID-VkPhysicalDeviceSparseImageFormatInfo2-samples-01095,N,None,explicit,VkPhysicalDeviceSparseImageFormatInfo2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)"," samples must be a bit value that is set in VkImageFormatProperties::sampleCounts returned by vkGetPhysicalDeviceImageFormatProperties with format, type, tiling, and usage equal to those in this command and flags equal to the value that is set in VkImageCreateInfo::flags when the image is created"
VUID-VkPhysicalDeviceSparseImageFormatInfo2-samples-parameter,Y,None,implicit,VkPhysicalDeviceSparseImageFormatInfo2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", samples must be a valid VkSampleCountFlagBits value
VUID-VkPhysicalDeviceSparseImageFormatInfo2-tiling-parameter,Y,None,implicit,VkPhysicalDeviceSparseImageFormatInfo2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", tiling must be a valid VkImageTiling value
VUID-VkPhysicalDeviceSparseImageFormatInfo2-type-parameter,Y,None,implicit,VkPhysicalDeviceSparseImageFormatInfo2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", type must be a valid VkImageType value
VUID-VkPhysicalDeviceSparseImageFormatInfo2-usage-parameter,N,None,implicit,VkPhysicalDeviceSparseImageFormatInfo2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", usage must be a valid combination of VkImageUsageFlagBits values
VUID-VkPhysicalDeviceSparseImageFormatInfo2-usage-requiredbitmask,Y,None,implicit,VkPhysicalDeviceSparseImageFormatInfo2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", usage must not be 0
VUID-VkPhysicalDeviceSubgroupProperties-sType-sType,N,None,implicit,VkPhysicalDeviceSubgroupProperties,(VK_VERSION_1_1), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES
VUID-VkPhysicalDeviceSurfaceInfo2KHR-pNext-pNext,Y,None,implicit,VkPhysicalDeviceSurfaceInfo2KHR,(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2), pNext must be NULL
VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-sType,Y,None,implicit,VkPhysicalDeviceSurfaceInfo2KHR,(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR
VUID-VkPhysicalDeviceSurfaceInfo2KHR-surface-parameter,Y,None,implicit,VkPhysicalDeviceSurfaceInfo2KHR,(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2), surface must be a valid VkSurfaceKHR handle
VUID-VkPhysicalDeviceVariablePointerFeatures-sType-sType,N,None,implicit,VkPhysicalDeviceVariablePointerFeatures,"(VK_VERSION_1_1,VK_KHR_variable_pointers)", sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES
VUID-VkPhysicalDeviceVariablePointerFeatures-variablePointers-01431,N,None,explicit,VkPhysicalDeviceVariablePointerFeatures,"(VK_VERSION_1_1,VK_KHR_variable_pointers)", If variablePointers is enabled then variablePointersStorageBuffer must also be enabled.
VUID-VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT-sType-sType,N,None,implicit,VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT,(VK_EXT_vertex_attribute_divisor), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT
VUID-VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT-sType-sType,N,None,implicit,VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT,(VK_EXT_vertex_attribute_divisor), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT
VUID-VkPhysicalDeviceVulkanMemoryModelFeaturesKHR-sType-sType,N,None,implicit,VkPhysicalDeviceVulkanMemoryModelFeaturesKHR,(VK_KHR_vulkan_memory_model), sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR
VUID-VkPipelineCacheCreateInfo-flags-zerobitmask,Y,None,implicit,VkPipelineCacheCreateInfo,core, flags must be 0
VUID-VkPipelineCacheCreateInfo-initialDataSize-00768,N,None,explicit,VkPipelineCacheCreateInfo,core," If initialDataSize is not 0, it must be equal to the size of pInitialData, as returned by vkGetPipelineCacheData when pInitialData was originally retrieved"
VUID-VkPipelineCacheCreateInfo-initialDataSize-00769,N,None,explicit,VkPipelineCacheCreateInfo,core," If initialDataSize is not 0, pInitialData must have been retrieved from a previous call to vkGetPipelineCacheData"
VUID-VkPipelineCacheCreateInfo-pInitialData-parameter,Y,None,implicit,VkPipelineCacheCreateInfo,core," If initialDataSize is not 0, pInitialData must be a valid pointer to an array of initialDataSize bytes"
VUID-VkPipelineCacheCreateInfo-pNext-pNext,Y,None,implicit,VkPipelineCacheCreateInfo,core, pNext must be NULL
VUID-VkPipelineCacheCreateInfo-sType-sType,Y,None,implicit,VkPipelineCacheCreateInfo,core, sType must be VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO
VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-blendOverlap-01426,N,None,explicit,VkPipelineColorBlendAdvancedStateCreateInfoEXT,(VK_EXT_blend_operation_advanced)," If the correlated overlap property is not supported, blendOverlap must be VK_BLEND_OVERLAP_UNCORRELATED_EXT"
VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-blendOverlap-parameter,Y,None,implicit,VkPipelineColorBlendAdvancedStateCreateInfoEXT,(VK_EXT_blend_operation_advanced), blendOverlap must be a valid VkBlendOverlapEXT value
VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-dstPremultiplied-01425,N,None,explicit,VkPipelineColorBlendAdvancedStateCreateInfoEXT,(VK_EXT_blend_operation_advanced)," If the non-premultiplied destination color property is not supported, dstPremultiplied must be VK_TRUE"
VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-sType-sType,N,None,implicit,VkPipelineColorBlendAdvancedStateCreateInfoEXT,(VK_EXT_blend_operation_advanced), sType must be VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT
VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-srcPremultiplied-01424,N,None,explicit,VkPipelineColorBlendAdvancedStateCreateInfoEXT,(VK_EXT_blend_operation_advanced)," If the non-premultiplied source color property is not supported, srcPremultiplied must be VK_TRUE"
VUID-VkPipelineColorBlendAttachmentState-advancedBlendAllOperations-01409,N,None,explicit,VkPipelineColorBlendAttachmentState,(VK_EXT_blend_operation_advanced)," If VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendAllOperations is VK_FALSE, then colorBlendOp must not be VK_BLEND_OP_ZERO_EXT, VK_BLEND_OP_SRC_EXT, VK_BLEND_OP_DST_EXT, VK_BLEND_OP_SRC_OVER_EXT, VK_BLEND_OP_DST_OVER_EXT, VK_BLEND_OP_SRC_IN_EXT, VK_BLEND_OP_DST_IN_EXT, VK_BLEND_OP_SRC_OUT_EXT, VK_BLEND_OP_DST_OUT_EXT, VK_BLEND_OP_SRC_ATOP_EXT, VK_BLEND_OP_DST_ATOP_EXT, VK_BLEND_OP_XOR_EXT, VK_BLEND_OP_INVERT_EXT, VK_BLEND_OP_INVERT_RGB_EXT, VK_BLEND_OP_LINEARDODGE_EXT, VK_BLEND_OP_LINEARBURN_EXT, VK_BLEND_OP_VIVIDLIGHT_EXT, VK_BLEND_OP_LINEARLIGHT_EXT, VK_BLEND_OP_PINLIGHT_EXT, VK_BLEND_OP_HARDMIX_EXT, VK_BLEND_OP_PLUS_EXT, VK_BLEND_OP_PLUS_CLAMPED_EXT, VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT, VK_BLEND_OP_PLUS_DARKER_EXT, VK_BLEND_OP_MINUS_EXT, VK_BLEND_OP_MINUS_CLAMPED_EXT, VK_BLEND_OP_CONTRAST_EXT, VK_BLEND_OP_INVERT_OVG_EXT, VK_BLEND_OP_RED_EXT, VK_BLEND_OP_GREEN_EXT, or VK_BLEND_OP_BLUE_EXT"
VUID-VkPipelineColorBlendAttachmentState-advancedBlendIndependentBlend-01407,N,None,explicit,VkPipelineColorBlendAttachmentState,(VK_EXT_blend_operation_advanced)," If VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendIndependentBlend is VK_FALSE and colorBlendOp is an advanced blend operation, then colorBlendOp must be the same for all attachments."
VUID-VkPipelineColorBlendAttachmentState-advancedBlendIndependentBlend-01408,N,None,explicit,VkPipelineColorBlendAttachmentState,(VK_EXT_blend_operation_advanced)," If VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendIndependentBlend is VK_FALSE and alphaBlendOp is an advanced blend operation, then alphaBlendOp must be the same for all attachments."
VUID-VkPipelineColorBlendAttachmentState-alphaBlendOp-parameter,Y,None,implicit,VkPipelineColorBlendAttachmentState,core, alphaBlendOp must be a valid VkBlendOp value
VUID-VkPipelineColorBlendAttachmentState-colorBlendOp-01406,N,None,explicit,VkPipelineColorBlendAttachmentState,(VK_EXT_blend_operation_advanced)," If either of colorBlendOp or alphaBlendOp is an advanced blend operation, then colorBlendOp must equal alphaBlendOp"
VUID-VkPipelineColorBlendAttachmentState-colorBlendOp-01410,N,None,explicit,VkPipelineColorBlendAttachmentState,(VK_EXT_blend_operation_advanced)," If colorBlendOp or alphaBlendOp is an advanced blend operation, then VkSubpassDescription::colorAttachmentCount of the subpass this pipeline is compiled against must be less than or equal to VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendMaxColorAttachments"
VUID-VkPipelineColorBlendAttachmentState-colorBlendOp-parameter,Y,None,implicit,VkPipelineColorBlendAttachmentState,core, colorBlendOp must be a valid VkBlendOp value
VUID-VkPipelineColorBlendAttachmentState-colorWriteMask-parameter,Y,None,implicit,VkPipelineColorBlendAttachmentState,core, colorWriteMask must be a valid combination of VkColorComponentFlagBits values
VUID-VkPipelineColorBlendAttachmentState-dstAlphaBlendFactor-00611,Y,ColorBlendUnsupportedDualSourceBlend,explicit,VkPipelineColorBlendAttachmentState,core," If the dual source blending feature is not enabled, dstAlphaBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA"
VUID-VkPipelineColorBlendAttachmentState-dstAlphaBlendFactor-parameter,Y,None,implicit,VkPipelineColorBlendAttachmentState,core, dstAlphaBlendFactor must be a valid VkBlendFactor value
VUID-VkPipelineColorBlendAttachmentState-dstColorBlendFactor-00609,Y,ColorBlendUnsupportedDualSourceBlend,explicit,VkPipelineColorBlendAttachmentState,core," If the dual source blending feature is not enabled, dstColorBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA"
VUID-VkPipelineColorBlendAttachmentState-dstColorBlendFactor-parameter,Y,None,implicit,VkPipelineColorBlendAttachmentState,core, dstColorBlendFactor must be a valid VkBlendFactor value
VUID-VkPipelineColorBlendAttachmentState-srcAlphaBlendFactor-00610,Y,ColorBlendUnsupportedDualSourceBlend,explicit,VkPipelineColorBlendAttachmentState,core," If the dual source blending feature is not enabled, srcAlphaBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA"
VUID-VkPipelineColorBlendAttachmentState-srcAlphaBlendFactor-parameter,Y,None,implicit,VkPipelineColorBlendAttachmentState,core, srcAlphaBlendFactor must be a valid VkBlendFactor value
VUID-VkPipelineColorBlendAttachmentState-srcColorBlendFactor-00608,Y,ColorBlendUnsupportedDualSourceBlend,explicit,VkPipelineColorBlendAttachmentState,core," If the dual source blending feature is not enabled, srcColorBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA"
VUID-VkPipelineColorBlendAttachmentState-srcColorBlendFactor-parameter,Y,None,implicit,VkPipelineColorBlendAttachmentState,core, srcColorBlendFactor must be a valid VkBlendFactor value
VUID-VkPipelineColorBlendStateCreateInfo-flags-zerobitmask,Y,None,implicit,VkPipelineColorBlendStateCreateInfo,core, flags must be 0
VUID-VkPipelineColorBlendStateCreateInfo-logicOpEnable-00606,Y,ColorBlendUnsupportedLogicOp,explicit,VkPipelineColorBlendStateCreateInfo,core," If the logic operations feature is not enabled, logicOpEnable must be VK_FALSE"
VUID-VkPipelineColorBlendStateCreateInfo-logicOpEnable-00607,Y,ColorBlendInvalidLogicOp,explicit,VkPipelineColorBlendStateCreateInfo,core," If logicOpEnable is VK_TRUE, logicOp must be a valid VkLogicOp value"
VUID-VkPipelineColorBlendStateCreateInfo-pAttachments-00605,Y,None,explicit,VkPipelineColorBlendStateCreateInfo,core," If the independent blending feature is not enabled, all elements of pAttachments must be identical"
VUID-VkPipelineColorBlendStateCreateInfo-pAttachments-parameter,N,None,implicit,VkPipelineColorBlendStateCreateInfo,core," If attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkPipelineColorBlendAttachmentState structures"
VUID-VkPipelineColorBlendStateCreateInfo-pNext-pNext,Y,None,implicit,VkPipelineColorBlendStateCreateInfo,core, pNext must be NULL or a pointer to a valid instance of VkPipelineColorBlendAdvancedStateCreateInfoEXT
VUID-VkPipelineColorBlendStateCreateInfo-sType-sType,N,None,implicit,VkPipelineColorBlendStateCreateInfo,core, sType must be VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO
VUID-VkPipelineCoverageModulationStateCreateInfoNV-coverageModulationMode-parameter,Y,None,implicit,VkPipelineCoverageModulationStateCreateInfoNV,(VK_NV_framebuffer_mixed_samples), coverageModulationMode must be a valid VkCoverageModulationModeNV value
VUID-VkPipelineCoverageModulationStateCreateInfoNV-coverageModulationTableCount-arraylength,N,None,implicit,VkPipelineCoverageModulationStateCreateInfoNV,(VK_NV_framebuffer_mixed_samples), coverageModulationTableCount must be greater than 0
VUID-VkPipelineCoverageModulationStateCreateInfoNV-coverageModulationTableEnable-01405,N,None,explicit,VkPipelineCoverageModulationStateCreateInfoNV,(VK_NV_framebuffer_mixed_samples)," If coverageModulationTableEnable is VK_TRUE, coverageModulationTableCount must be equal to the number of rasterization samples divided by the number of color samples in the subpass."
VUID-VkPipelineCoverageModulationStateCreateInfoNV-flags-zerobitmask,Y,None,implicit,VkPipelineCoverageModulationStateCreateInfoNV,(VK_NV_framebuffer_mixed_samples), flags must be 0
VUID-VkPipelineCoverageModulationStateCreateInfoNV-sType-sType,N,None,implicit,VkPipelineCoverageModulationStateCreateInfoNV,(VK_NV_framebuffer_mixed_samples), sType must be VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV
VUID-VkPipelineCoverageToColorStateCreateInfoNV-coverageToColorEnable-01404,N,None,explicit,VkPipelineCoverageToColorStateCreateInfoNV,(VK_NV_fragment_coverage_to_color)," If coverageToColorEnable is VK_TRUE, then the render pass subpass indicated by VkGraphicsPipelineCreateInfo::renderPass and VkGraphicsPipelineCreateInfo::subpass must have a color attachment at the location selected by coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT"
VUID-VkPipelineCoverageToColorStateCreateInfoNV-flags-zerobitmask,Y,None,implicit,VkPipelineCoverageToColorStateCreateInfoNV,(VK_NV_fragment_coverage_to_color), flags must be 0
VUID-VkPipelineCoverageToColorStateCreateInfoNV-sType-sType,N,None,implicit,VkPipelineCoverageToColorStateCreateInfoNV,(VK_NV_fragment_coverage_to_color), sType must be VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV
VUID-VkPipelineDepthStencilStateCreateInfo-back-parameter,N,None,implicit,VkPipelineDepthStencilStateCreateInfo,core, back must be a valid VkStencilOpState structure
VUID-VkPipelineDepthStencilStateCreateInfo-depthBoundsTestEnable-00598,Y,None,explicit,VkPipelineDepthStencilStateCreateInfo,core," If the depth bounds testing feature is not enabled, depthBoundsTestEnable must be VK_FALSE"
VUID-VkPipelineDepthStencilStateCreateInfo-depthCompareOp-parameter,Y,None,implicit,VkPipelineDepthStencilStateCreateInfo,core, depthCompareOp must be a valid VkCompareOp value
VUID-VkPipelineDepthStencilStateCreateInfo-flags-zerobitmask,Y,None,implicit,VkPipelineDepthStencilStateCreateInfo,core, flags must be 0
VUID-VkPipelineDepthStencilStateCreateInfo-front-parameter,N,None,implicit,VkPipelineDepthStencilStateCreateInfo,core, front must be a valid VkStencilOpState structure
VUID-VkPipelineDepthStencilStateCreateInfo-pNext-pNext,Y,None,implicit,VkPipelineDepthStencilStateCreateInfo,core, pNext must be NULL
VUID-VkPipelineDepthStencilStateCreateInfo-sType-sType,N,None,implicit,VkPipelineDepthStencilStateCreateInfo,core, sType must be VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO
VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-discardRectangleCount-00582,N,None,explicit,VkPipelineDiscardRectangleStateCreateInfoEXT,(VK_EXT_discard_rectangles)," discardRectangleCount must be between 0 and VkPhysicalDeviceDiscardRectanglePropertiesEXT::maxDiscardRectangles, inclusive"
VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-discardRectangleMode-parameter,Y,None,implicit,VkPipelineDiscardRectangleStateCreateInfoEXT,(VK_EXT_discard_rectangles), discardRectangleMode must be a valid VkDiscardRectangleModeEXT value
VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-flags-zerobitmask,Y,None,implicit,VkPipelineDiscardRectangleStateCreateInfoEXT,(VK_EXT_discard_rectangles), flags must be 0
VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-sType-sType,N,None,implicit,VkPipelineDiscardRectangleStateCreateInfoEXT,(VK_EXT_discard_rectangles), sType must be VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT
VUID-VkPipelineDynamicStateCreateInfo-dynamicStateCount-arraylength,N,None,implicit,VkPipelineDynamicStateCreateInfo,core, dynamicStateCount must be greater than 0
VUID-VkPipelineDynamicStateCreateInfo-flags-zerobitmask,Y,None,implicit,VkPipelineDynamicStateCreateInfo,core, flags must be 0
VUID-VkPipelineDynamicStateCreateInfo-pDynamicStates-01442,N,None,explicit,VkPipelineDynamicStateCreateInfo,core, Each element of pDynamicStates must be unique
VUID-VkPipelineDynamicStateCreateInfo-pDynamicStates-parameter,N,None,implicit,VkPipelineDynamicStateCreateInfo,core, pDynamicStates must be a valid pointer to an array of dynamicStateCount valid VkDynamicState values
VUID-VkPipelineDynamicStateCreateInfo-pNext-pNext,Y,None,implicit,VkPipelineDynamicStateCreateInfo,core, pNext must be NULL
VUID-VkPipelineDynamicStateCreateInfo-sType-sType,Y,None,implicit,VkPipelineDynamicStateCreateInfo,core, sType must be VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO
VUID-VkPipelineInputAssemblyStateCreateInfo-flags-zerobitmask,N,None,implicit,VkPipelineInputAssemblyStateCreateInfo,core, flags must be 0
VUID-VkPipelineInputAssemblyStateCreateInfo-pNext-pNext,N,None,implicit,VkPipelineInputAssemblyStateCreateInfo,core, pNext must be NULL
VUID-VkPipelineInputAssemblyStateCreateInfo-sType-sType,N,None,implicit,VkPipelineInputAssemblyStateCreateInfo,core, sType must be VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO
VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00428,N,None,explicit,VkPipelineInputAssemblyStateCreateInfo,core," If topology is VK_PRIMITIVE_TOPOLOGY_POINT_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY or VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, primitiveRestartEnable must be VK_FALSE"
VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00429,N,None,explicit,VkPipelineInputAssemblyStateCreateInfo,core," If the geometry shaders feature is not enabled, topology must not be any of VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY or VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY"
VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00430,N,None,explicit,VkPipelineInputAssemblyStateCreateInfo,core," If the tessellation shaders feature is not enabled, topology must not be VK_PRIMITIVE_TOPOLOGY_PATCH_LIST"
VUID-VkPipelineInputAssemblyStateCreateInfo-topology-parameter,N,None,implicit,VkPipelineInputAssemblyStateCreateInfo,core, topology must be a valid VkPrimitiveTopology value
VUID-VkPipelineLayoutCreateInfo-descriptorType-02212,N,None,explicit,VkPipelineLayoutCreateInfo,!(VK_EXT_descriptor_indexing)+(VK_EXT_inline_uniform_block), The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxPerStageDescriptorInlineUniformBlocks
VUID-VkPipelineLayoutCreateInfo-descriptorType-02213,N,None,explicit,VkPipelineLayoutCreateInfo,!(VK_EXT_descriptor_indexing)+(VK_EXT_inline_uniform_block), The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxDescriptorSetInlineUniformBlocks
VUID-VkPipelineLayoutCreateInfo-descriptorType-02214,Y,InlineUniformBlockEXT,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing)+(VK_EXT_inline_uniform_block), The total number of bindings in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxPerStageDescriptorInlineUniformBlocks
VUID-VkPipelineLayoutCreateInfo-descriptorType-02215,Y,InlineUniformBlockEXT,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing)+(VK_EXT_inline_uniform_block), The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks
VUID-VkPipelineLayoutCreateInfo-descriptorType-02216,Y,InlineUniformBlockEXT,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing)+(VK_EXT_inline_uniform_block), The total number of bindings in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxDescriptorSetInlineUniformBlocks
VUID-VkPipelineLayoutCreateInfo-descriptorType-02217,Y,InlineUniformBlockEXT,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing)+(VK_EXT_inline_uniform_block), The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxDescriptorSetUpdateAfterBindInlineUniformBlocks
VUID-VkPipelineLayoutCreateInfo-descriptorType-03016,N,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorSamplers
VUID-VkPipelineLayoutCreateInfo-descriptorType-03017,N,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER and VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorUniformBuffers
VUID-VkPipelineLayoutCreateInfo-descriptorType-03018,N,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER and VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorStorageBuffers
VUID-VkPipelineLayoutCreateInfo-descriptorType-03019,N,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing)," The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorSampledImages"
VUID-VkPipelineLayoutCreateInfo-descriptorType-03020,N,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing)," The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorStorageImages"
VUID-VkPipelineLayoutCreateInfo-descriptorType-03021,N,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorInputAttachments
VUID-VkPipelineLayoutCreateInfo-descriptorType-03022,Y,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindSamplers
VUID-VkPipelineLayoutCreateInfo-descriptorType-03023,Y,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER and VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindUniformBuffers
VUID-VkPipelineLayoutCreateInfo-descriptorType-03024,Y,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER and VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindStorageBuffers
VUID-VkPipelineLayoutCreateInfo-descriptorType-03025,Y,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing)," The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindSampledImages"
VUID-VkPipelineLayoutCreateInfo-descriptorType-03026,Y,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing)," The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindStorageImages"
VUID-VkPipelineLayoutCreateInfo-descriptorType-03027,Y,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindInputAttachments
VUID-VkPipelineLayoutCreateInfo-descriptorType-03028,N,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetSamplers
VUID-VkPipelineLayoutCreateInfo-descriptorType-03029,N,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetUniformBuffers
VUID-VkPipelineLayoutCreateInfo-descriptorType-03030,N,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetUniformBuffersDynamic
VUID-VkPipelineLayoutCreateInfo-descriptorType-03031,N,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageBuffers
VUID-VkPipelineLayoutCreateInfo-descriptorType-03032,N,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageBuffersDynamic
VUID-VkPipelineLayoutCreateInfo-descriptorType-03033,N,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing)," The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetSampledImages"
VUID-VkPipelineLayoutCreateInfo-descriptorType-03034,N,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing)," The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageImages"
VUID-VkPipelineLayoutCreateInfo-descriptorType-03035,N,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetInputAttachments
VUID-VkPipelineLayoutCreateInfo-flags-zerobitmask,Y,None,implicit,VkPipelineLayoutCreateInfo,core, flags must be 0
VUID-VkPipelineLayoutCreateInfo-pNext-pNext,Y,None,implicit,VkPipelineLayoutCreateInfo,core, pNext must be NULL
VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-00292,Y,None,explicit,VkPipelineLayoutCreateInfo,core, Any two elements of pPushConstantRanges must not include the same stage in stageFlags
VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-parameter,Y,None,implicit,VkPipelineLayoutCreateInfo,core," If pushConstantRangeCount is not 0, pPushConstantRanges must be a valid pointer to an array of pushConstantRangeCount valid VkPushConstantRange structures"
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00287,Y,"CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall",explicit,VkPipelineLayoutCreateInfo,!(VK_EXT_descriptor_indexing), The total number of descriptors of the type VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible to any shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorSamplers
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00288,Y,"CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall",explicit,VkPipelineLayoutCreateInfo,!(VK_EXT_descriptor_indexing), The total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER and VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible to any shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorUniformBuffers
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00289,Y,"CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall",explicit,VkPipelineLayoutCreateInfo,!(VK_EXT_descriptor_indexing), The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER and VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible to any shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorStorageBuffers
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00290,Y,"CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall",explicit,VkPipelineLayoutCreateInfo,!(VK_EXT_descriptor_indexing)," The total number of descriptors of the type VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible to any shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorSampledImages"
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00291,Y,"CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall",explicit,VkPipelineLayoutCreateInfo,!(VK_EXT_descriptor_indexing)," The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible to any shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorStorageImages"
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00293,Y,MultiplePushDescriptorSets,explicit,VkPipelineLayoutCreateInfo,(VK_KHR_push_descriptor), pSetLayouts must not contain more than one descriptor set layout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR set
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01676,Y,"CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall",explicit,VkPipelineLayoutCreateInfo,!(VK_EXT_descriptor_indexing), The total number of descriptors of the type VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorInputAttachments
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01677,Y,"CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall",explicit,VkPipelineLayoutCreateInfo,!(VK_EXT_descriptor_indexing), The total number of descriptors of the type VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetSamplers
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01678,Y,"CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall",explicit,VkPipelineLayoutCreateInfo,!(VK_EXT_descriptor_indexing), The total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetUniformBuffers
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01679,Y,"CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall",explicit,VkPipelineLayoutCreateInfo,!(VK_EXT_descriptor_indexing), The total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetUniformBuffersDynamic
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01680,Y,"CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall",explicit,VkPipelineLayoutCreateInfo,!(VK_EXT_descriptor_indexing), The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageBuffers
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01681,Y,"CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall",explicit,VkPipelineLayoutCreateInfo,!(VK_EXT_descriptor_indexing), The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageBuffersDynamic
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01682,Y,"CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall",explicit,VkPipelineLayoutCreateInfo,!(VK_EXT_descriptor_indexing)," The total number of descriptors of the type VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetSampledImages"
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01683,Y,"CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall",explicit,VkPipelineLayoutCreateInfo,!(VK_EXT_descriptor_indexing)," The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageImages"
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01684,Y,"CreatePipelineLayoutExcessPerStageDescriptors, CreatePipelineLayoutExcessDescriptorsOverall",explicit,VkPipelineLayoutCreateInfo,!(VK_EXT_descriptor_indexing), The total number of descriptors of the type VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetInputAttachments
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03036,Y,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors of the type VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindSamplers
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03037,Y,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindUniformBuffers
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03038,Y,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindUniformBuffersDynamic
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03039,Y,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindStorageBuffers
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03040,Y,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindStorageBuffersDynamic
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03041,Y,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing)," The total number of descriptors of the type VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindSampledImages"
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03042,Y,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing)," The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindStorageImages"
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03043,Y,None,explicit,VkPipelineLayoutCreateInfo,(VK_EXT_descriptor_indexing), The total number of descriptors of the type VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindInputAttachments
VUID-VkPipelineLayoutCreateInfo-pSetLayouts-parameter,Y,InvalidDescriptorSetLayout,implicit,VkPipelineLayoutCreateInfo,core," If setLayoutCount is not 0, pSetLayouts must be a valid pointer to an array of setLayoutCount valid VkDescriptorSetLayout handles"
VUID-VkPipelineLayoutCreateInfo-sType-sType,Y,None,implicit,VkPipelineLayoutCreateInfo,core, sType must be VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO
VUID-VkPipelineLayoutCreateInfo-setLayoutCount-00286,Y,CreatePipelineLayoutExceedsSetLimit,explicit,VkPipelineLayoutCreateInfo,core, setLayoutCount must be less than or equal to VkPhysicalDeviceLimits::maxBoundDescriptorSets
VUID-VkPipelineMultisampleStateCreateInfo-alphaToOneEnable-00785,Y,None,explicit,VkPipelineMultisampleStateCreateInfo,core," If the alpha to one feature is not enabled, alphaToOneEnable must be VK_FALSE"
VUID-VkPipelineMultisampleStateCreateInfo-flags-zerobitmask,Y,None,implicit,VkPipelineMultisampleStateCreateInfo,core, flags must be 0
VUID-VkPipelineMultisampleStateCreateInfo-minSampleShading-00786,Y,InvalidPipelineSampleRateFeatureEnable,explicit,VkPipelineMultisampleStateCreateInfo,core," minSampleShading must be in the range [0,1]"
VUID-VkPipelineMultisampleStateCreateInfo-pNext-pNext,Y,InvalidPipelineSamplePNext,implicit,VkPipelineMultisampleStateCreateInfo,core," Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineCoverageModulationStateCreateInfoNV, VkPipelineCoverageToColorStateCreateInfoNV, or VkPipelineSampleLocationsStateCreateInfoEXT"
VUID-VkPipelineMultisampleStateCreateInfo-pSampleMask-parameter,N,None,implicit,VkPipelineMultisampleStateCreateInfo,core," If pSampleMask is not NULL, pSampleMask must be a valid pointer to an array of (rasterizationSamples/32) VkSampleMask values"
VUID-VkPipelineMultisampleStateCreateInfo-rasterizationSamples-01415,N,None,explicit,VkPipelineMultisampleStateCreateInfo,(VK_NV_framebuffer_mixed_samples)," If the subpass has any color attachments and rasterizationSamples is greater than the number of color samples, then sampleShadingEnable must be VK_FALSE"
VUID-VkPipelineMultisampleStateCreateInfo-rasterizationSamples-parameter,N,None,implicit,VkPipelineMultisampleStateCreateInfo,core, rasterizationSamples must be a valid VkSampleCountFlagBits value
VUID-VkPipelineMultisampleStateCreateInfo-sType-sType,N,None,implicit,VkPipelineMultisampleStateCreateInfo,core, sType must be VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO
VUID-VkPipelineMultisampleStateCreateInfo-sType-unique,N,None,implicit,VkPipelineMultisampleStateCreateInfo,core, Each sType member in the pNext chain must be unique
VUID-VkPipelineMultisampleStateCreateInfo-sampleShadingEnable-00784,Y,InvalidPipelineSampleRateFeatureDisable,explicit,VkPipelineMultisampleStateCreateInfo,core," If the sample rate shading feature is not enabled, sampleShadingEnable must be VK_FALSE"
VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-conservativeRasterizationMode-parameter,Y,None,implicit,VkPipelineRasterizationConservativeStateCreateInfoEXT,(VK_EXT_conservative_rasterization), conservativeRasterizationMode must be a valid VkConservativeRasterizationModeEXT value
VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-extraPrimitiveOverestimationSize-01769,N,None,explicit,VkPipelineRasterizationConservativeStateCreateInfoEXT,(VK_EXT_conservative_rasterization), extraPrimitiveOverestimationSize must be in the range of 0.0 to VkPhysicalDeviceConservativeRasterizationPropertiesEXT::maxExtraPrimitiveOverestimationSize inclusive
VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-flags-zerobitmask,Y,None,implicit,VkPipelineRasterizationConservativeStateCreateInfoEXT,(VK_EXT_conservative_rasterization), flags must be 0
VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-sType-sType,N,None,implicit,VkPipelineRasterizationConservativeStateCreateInfoEXT,(VK_EXT_conservative_rasterization), sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT
VUID-VkPipelineRasterizationStateCreateInfo-cullMode-parameter,Y,None,implicit,VkPipelineRasterizationStateCreateInfo,core, cullMode must be a valid combination of VkCullModeFlagBits values
VUID-VkPipelineRasterizationStateCreateInfo-depthClampEnable-00782,Y,None,explicit,VkPipelineRasterizationStateCreateInfo,core," If the depth clamping feature is not enabled, depthClampEnable must be VK_FALSE"
VUID-VkPipelineRasterizationStateCreateInfo-flags-zerobitmask,Y,None,implicit,VkPipelineRasterizationStateCreateInfo,core, flags must be 0
VUID-VkPipelineRasterizationStateCreateInfo-frontFace-parameter,Y,None,implicit,VkPipelineRasterizationStateCreateInfo,core, frontFace must be a valid VkFrontFace value
VUID-VkPipelineRasterizationStateCreateInfo-pNext-pNext,Y,None,implicit,VkPipelineRasterizationStateCreateInfo,core, Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineRasterizationConservativeStateCreateInfoEXT or VkPipelineRasterizationStateRasterizationOrderAMD
VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-01413,N,None,explicit,VkPipelineRasterizationStateCreateInfo,!(VK_NV_fill_rectangle)," If the non-solid fill modes feature is not enabled, polygonMode must be VK_POLYGON_MODE_FILL"
VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-01414,N,None,explicit,VkPipelineRasterizationStateCreateInfo,(VK_NV_fill_rectangle)," If the VK_NV_fill_rectangle extension is not enabled, polygonMode must not be VK_POLYGON_MODE_FILL_RECTANGLE_NV"
VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-01507,N,None,explicit,VkPipelineRasterizationStateCreateInfo,(VK_NV_fill_rectangle)," If the non-solid fill modes feature is not enabled, polygonMode must be VK_POLYGON_MODE_FILL or VK_POLYGON_MODE_FILL_RECTANGLE_NV"
VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-parameter,Y,None,implicit,VkPipelineRasterizationStateCreateInfo,core, polygonMode must be a valid VkPolygonMode value
VUID-VkPipelineRasterizationStateCreateInfo-sType-sType,Y,None,implicit,VkPipelineRasterizationStateCreateInfo,core, sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO
VUID-VkPipelineRasterizationStateCreateInfo-sType-unique,N,None,implicit,VkPipelineRasterizationStateCreateInfo,core, Each sType member in the pNext chain must be unique
VUID-VkPipelineRasterizationStateRasterizationOrderAMD-rasterizationOrder-parameter,Y,None,implicit,VkPipelineRasterizationStateRasterizationOrderAMD,(VK_AMD_rasterization_order), rasterizationOrder must be a valid VkRasterizationOrderAMD value
VUID-VkPipelineRasterizationStateRasterizationOrderAMD-sType-sType,N,None,implicit,VkPipelineRasterizationStateRasterizationOrderAMD,(VK_AMD_rasterization_order), sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD
VUID-VkPipelineRepresentativeFragmentTestStateCreateInfoNV-sType-sType,N,None,implicit,VkPipelineRepresentativeFragmentTestStateCreateInfoNV,(VK_NV_representative_fragment_test), sType must be VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV
VUID-VkPipelineSampleLocationsStateCreateInfoEXT-sType-sType,N,None,implicit,VkPipelineSampleLocationsStateCreateInfoEXT,(VK_EXT_sample_locations), sType must be VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT
VUID-VkPipelineSampleLocationsStateCreateInfoEXT-sampleLocationsInfo-parameter,N,None,implicit,VkPipelineSampleLocationsStateCreateInfoEXT,(VK_EXT_sample_locations), sampleLocationsInfo must be a valid VkSampleLocationsInfoEXT structure
VUID-VkPipelineShaderStageCreateInfo-flags-zerobitmask,Y,None,implicit,VkPipelineShaderStageCreateInfo,core, flags must be 0
VUID-VkPipelineShaderStageCreateInfo-maxClipDistances-00708,N,None,explicit,VkPipelineShaderStageCreateInfo,core," If the identified entry point includes any variable in its interface that is declared with the ClipDistance BuiltIn decoration, that variable must not have an array size greater than VkPhysicalDeviceLimits::maxClipDistances"
VUID-VkPipelineShaderStageCreateInfo-maxCombinedClipAndCullDistances-00710,N,None,explicit,VkPipelineShaderStageCreateInfo,core," If the identified entry point includes any variables in its interface that are declared with the ClipDistance or CullDistance BuiltIn decoration, those variables must not have array sizes which sum to more than VkPhysicalDeviceLimits::maxCombinedClipAndCullDistances"
VUID-VkPipelineShaderStageCreateInfo-maxCullDistances-00709,N,None,explicit,VkPipelineShaderStageCreateInfo,core," If the identified entry point includes any variable in its interface that is declared with the CullDistance BuiltIn decoration, that variable must not have an array size greater than VkPhysicalDeviceLimits::maxCullDistances"
VUID-VkPipelineShaderStageCreateInfo-maxSampleMaskWords-00711,N,None,explicit,VkPipelineShaderStageCreateInfo,core," If the identified entry point includes any variable in its interface that is declared with the SampleMask BuiltIn decoration, that variable must not have an array size greater than VkPhysicalDeviceLimits::maxSampleMaskWords"
VUID-VkPipelineShaderStageCreateInfo-module-parameter,Y,None,implicit,VkPipelineShaderStageCreateInfo,core, module must be a valid VkShaderModule handle
VUID-VkPipelineShaderStageCreateInfo-pName-00707,Y,"MeshShaderNV, MeshShaderDisabledNV",explicit,VkPipelineShaderStageCreateInfo,core, pName must be the name of an OpEntryPoint in module with an execution model that matches stage
VUID-VkPipelineShaderStageCreateInfo-pName-parameter,Y,None,implicit,VkPipelineShaderStageCreateInfo,core, pName must be a null-terminated UTF-8 string
VUID-VkPipelineShaderStageCreateInfo-pNext-pNext,Y,None,implicit,VkPipelineShaderStageCreateInfo,core, pNext must be NULL
VUID-VkPipelineShaderStageCreateInfo-pSpecializationInfo-parameter,N,None,implicit,VkPipelineShaderStageCreateInfo,core," If pSpecializationInfo is not NULL, pSpecializationInfo must be a valid pointer to a valid VkSpecializationInfo structure"
VUID-VkPipelineShaderStageCreateInfo-sType-sType,Y,None,implicit,VkPipelineShaderStageCreateInfo,core, sType must be VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO
VUID-VkPipelineShaderStageCreateInfo-stage-00704,N,None,explicit,VkPipelineShaderStageCreateInfo,core," If the geometry shaders feature is not enabled, stage must not be VK_SHADER_STAGE_GEOMETRY_BIT"
VUID-VkPipelineShaderStageCreateInfo-stage-00705,N,None,explicit,VkPipelineShaderStageCreateInfo,core," If the tessellation shaders feature is not enabled, stage must not be VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT"
VUID-VkPipelineShaderStageCreateInfo-stage-00706,N,None,explicit,VkPipelineShaderStageCreateInfo,core," stage must not be VK_SHADER_STAGE_ALL_GRAPHICS, or VK_SHADER_STAGE_ALL"
VUID-VkPipelineShaderStageCreateInfo-stage-00712,N,None,explicit,VkPipelineShaderStageCreateInfo,core," If stage is VK_SHADER_STAGE_VERTEX_BIT, the identified entry point must not include any input variable in its interface that is decorated with CullDistance"
VUID-VkPipelineShaderStageCreateInfo-stage-00713,N,None,explicit,VkPipelineShaderStageCreateInfo,core," If stage is VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, and the identified entry point has an OpExecutionMode instruction that specifies a patch size with OutputVertices, the patch size must be greater than 0 and less than or equal to VkPhysicalDeviceLimits::maxTessellationPatchSize"
VUID-VkPipelineShaderStageCreateInfo-stage-00714,N,None,explicit,VkPipelineShaderStageCreateInfo,core," If stage is VK_SHADER_STAGE_GEOMETRY_BIT, the identified entry point must have an OpExecutionMode instruction that specifies a maximum output vertex count that is greater than 0 and less than or equal to VkPhysicalDeviceLimits::maxGeometryOutputVertices"
VUID-VkPipelineShaderStageCreateInfo-stage-00715,N,None,explicit,VkPipelineShaderStageCreateInfo,core," If stage is VK_SHADER_STAGE_GEOMETRY_BIT, the identified entry point must have an OpExecutionMode instruction that specifies an invocation count that is greater than 0 and less than or equal to VkPhysicalDeviceLimits::maxGeometryShaderInvocations"
VUID-VkPipelineShaderStageCreateInfo-stage-00716,N,None,explicit,VkPipelineShaderStageCreateInfo,core," If stage is VK_SHADER_STAGE_GEOMETRY_BIT, and the identified entry point writes to Layer for any primitive, it must write the same value to Layer for all vertices of a given primitive"
VUID-VkPipelineShaderStageCreateInfo-stage-00717,N,None,explicit,VkPipelineShaderStageCreateInfo,core," If stage is VK_SHADER_STAGE_GEOMETRY_BIT, and the identified entry point writes to ViewportIndex for any primitive, it must write the same value to ViewportIndex for all vertices of a given primitive"
VUID-VkPipelineShaderStageCreateInfo-stage-00718,N,None,explicit,VkPipelineShaderStageCreateInfo,core," If stage is VK_SHADER_STAGE_FRAGMENT_BIT, the identified entry point must not include any output variables in its interface decorated with CullDistance"
VUID-VkPipelineShaderStageCreateInfo-stage-00719,N,None,explicit,VkPipelineShaderStageCreateInfo,core," If stage is VK_SHADER_STAGE_FRAGMENT_BIT, and the identified entry point writes to FragDepth in any execution path, it must write to FragDepth in all execution paths"
VUID-VkPipelineShaderStageCreateInfo-stage-01511,N,None,explicit,VkPipelineShaderStageCreateInfo,(VK_EXT_shader_stencil_export)," If stage is VK_SHADER_STAGE_FRAGMENT_BIT, and the identified entry point writes to FragStencilRefEXT in any execution path, it must write to FragStencilRefEXT in all execution paths"
VUID-VkPipelineShaderStageCreateInfo-stage-02091,Y,MeshShaderDisabledNV,explicit,VkPipelineShaderStageCreateInfo,(VK_NV_mesh_shader)," If the mesh shader feature is not enabled, stage must not be VK_SHADER_STAGE_MESH_BIT_NV"
VUID-VkPipelineShaderStageCreateInfo-stage-02092,Y,MeshShaderDisabledNV,explicit,VkPipelineShaderStageCreateInfo,(VK_NV_mesh_shader)," If the task shader feature is not enabled, stage must not be VK_SHADER_STAGE_TASK_BIT_NV"
VUID-VkPipelineShaderStageCreateInfo-stage-02093,N,None,explicit,VkPipelineShaderStageCreateInfo,(VK_NV_mesh_shader)," If stage is VK_SHADER_STAGE_MESH_BIT_NV, the identified entry point must have an OpExecutionMode instruction that specifies a maximum output vertex count, OutputVertices, that is greater than 0 and less than or equal to VkPhysicalDeviceMeshShaderPropertiesNV::maxMeshOutputVertices."
VUID-VkPipelineShaderStageCreateInfo-stage-02094,N,None,explicit,VkPipelineShaderStageCreateInfo,(VK_NV_mesh_shader)," If stage is VK_SHADER_STAGE_MESH_BIT_NV, the identified entry point must have an OpExecutionMode instruction that specifies a maximum output primitive count, OutputPrimitivesNV, that is greater than 0 and less than or equal to VkPhysicalDeviceMeshShaderPropertiesNV::maxMeshOutputPrimitives."
VUID-VkPipelineShaderStageCreateInfo-stage-parameter,Y,None,implicit,VkPipelineShaderStageCreateInfo,core, stage must be a valid VkShaderStageFlagBits value
VUID-VkPipelineTessellationDomainOriginStateCreateInfo-domainOrigin-parameter,Y,None,implicit,VkPipelineTessellationDomainOriginStateCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)", domainOrigin must be a valid VkTessellationDomainOrigin value
VUID-VkPipelineTessellationDomainOriginStateCreateInfo-sType-sType,N,None,implicit,VkPipelineTessellationDomainOriginStateCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)", sType must be VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO
VUID-VkPipelineTessellationStateCreateInfo-flags-zerobitmask,Y,None,implicit,VkPipelineTessellationStateCreateInfo,core, flags must be 0
VUID-VkPipelineTessellationStateCreateInfo-pNext-pNext,N,None,implicit,VkPipelineTessellationStateCreateInfo,core, pNext must be NULL or a pointer to a valid instance of VkPipelineTessellationDomainOriginStateCreateInfo
VUID-VkPipelineTessellationStateCreateInfo-patchControlPoints-01214,Y,CreatePipelineTessErrors,explicit,VkPipelineTessellationStateCreateInfo,core, patchControlPoints must be greater than zero and less than or equal to VkPhysicalDeviceLimits::maxTessellationPatchSize
VUID-VkPipelineTessellationStateCreateInfo-sType-sType,Y,CreatePipelineTessErrors,implicit,VkPipelineTessellationStateCreateInfo,core, sType must be VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO
VUID-VkPipelineVertexInputDivisorStateCreateInfoEXT-pVertexBindingDivisors-parameter,Y,None,implicit,VkPipelineVertexInputDivisorStateCreateInfoEXT,(VK_EXT_vertex_attribute_divisor), pVertexBindingDivisors must be a valid pointer to an array of vertexBindingDivisorCount VkVertexInputBindingDivisorDescriptionEXT structures
VUID-VkPipelineVertexInputDivisorStateCreateInfoEXT-sType-sType,N,None,implicit,VkPipelineVertexInputDivisorStateCreateInfoEXT,(VK_EXT_vertex_attribute_divisor), sType must be VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT
VUID-VkPipelineVertexInputDivisorStateCreateInfoEXT-vertexBindingDivisorCount-arraylength,Y,None,implicit,VkPipelineVertexInputDivisorStateCreateInfoEXT,(VK_EXT_vertex_attribute_divisor), vertexBindingDivisorCount must be greater than 0
VUID-VkPipelineVertexInputStateCreateInfo-binding-00615,Y,"InvalidVertexAttributeDescriptions, VUID_VkVertexInputAttributeDescription_binding_00621, VUID_VkVertexInputAttributeDescription_location_00620",explicit,VkPipelineVertexInputStateCreateInfo,core," For every binding specified by each element of pVertexAttributeDescriptions, a VkVertexInputBindingDescription must exist in pVertexBindingDescriptions with the same value of binding"
VUID-VkPipelineVertexInputStateCreateInfo-flags-zerobitmask,N,None,implicit,VkPipelineVertexInputStateCreateInfo,core, flags must be 0
VUID-VkPipelineVertexInputStateCreateInfo-pNext-pNext,N,None,implicit,VkPipelineVertexInputStateCreateInfo,core, pNext must be NULL or a pointer to a valid instance of VkPipelineVertexInputDivisorStateCreateInfoEXT
VUID-VkPipelineVertexInputStateCreateInfo-pVertexAttributeDescriptions-00617,Y,InvalidVertexAttributeDescriptions,explicit,VkPipelineVertexInputStateCreateInfo,core, All elements of pVertexAttributeDescriptions must describe distinct attribute locations
VUID-VkPipelineVertexInputStateCreateInfo-pVertexAttributeDescriptions-parameter,N,None,implicit,VkPipelineVertexInputStateCreateInfo,core," If vertexAttributeDescriptionCount is not 0, pVertexAttributeDescriptions must be a valid pointer to an array of vertexAttributeDescriptionCount valid VkVertexInputAttributeDescription structures"
VUID-VkPipelineVertexInputStateCreateInfo-pVertexBindingDescriptions-00616,Y,InvalidVertexBindingDescriptions,explicit,VkPipelineVertexInputStateCreateInfo,core, All elements of pVertexBindingDescriptions must describe distinct binding numbers
VUID-VkPipelineVertexInputStateCreateInfo-pVertexBindingDescriptions-parameter,N,None,implicit,VkPipelineVertexInputStateCreateInfo,core," If vertexBindingDescriptionCount is not 0, pVertexBindingDescriptions must be a valid pointer to an array of vertexBindingDescriptionCount valid VkVertexInputBindingDescription structures"
VUID-VkPipelineVertexInputStateCreateInfo-sType-sType,N,None,implicit,VkPipelineVertexInputStateCreateInfo,core, sType must be VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO
VUID-VkPipelineVertexInputStateCreateInfo-vertexAttributeDescriptionCount-00614,Y,InvalidVertexAttributeDescriptions,explicit,VkPipelineVertexInputStateCreateInfo,core, vertexAttributeDescriptionCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputAttributes
VUID-VkPipelineVertexInputStateCreateInfo-vertexBindingDescriptionCount-00613,Y,InvalidVertexBindingDescriptions,explicit,VkPipelineVertexInputStateCreateInfo,core, vertexBindingDescriptionCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindings
VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-pCustomSampleOrders-02234,N,None,explicit,VkPipelineViewportCoarseSampleOrderStateCreateInfoNV,(VK_NV_shading_rate_image), The array pCustomSampleOrders must not contain two structures with matching values for both the shadingRate and sampleCount members.
VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-pCustomSampleOrders-parameter,Y,None,implicit,VkPipelineViewportCoarseSampleOrderStateCreateInfoNV,(VK_NV_shading_rate_image)," If customSampleOrderCount is not 0, pCustomSampleOrders must be a valid pointer to an array of customSampleOrderCount valid VkCoarseSampleOrderCustomNV structures"
VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-sType-sType,N,None,implicit,VkPipelineViewportCoarseSampleOrderStateCreateInfoNV,(VK_NV_shading_rate_image), sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV
VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-sampleOrderType-02072,Y,None,explicit,VkPipelineViewportCoarseSampleOrderStateCreateInfoNV,(VK_NV_shading_rate_image)," If sampleOrderType is not VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV, customSamplerOrderCount must be 0"
VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-sampleOrderType-parameter,Y,None,implicit,VkPipelineViewportCoarseSampleOrderStateCreateInfoNV,(VK_NV_shading_rate_image), sampleOrderType must be a valid VkCoarseSampleOrderTypeNV value
VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-exclusiveScissorCount-02027,Y,ExclusiveScissorNV,explicit,VkPipelineViewportExclusiveScissorStateCreateInfoNV,(VK_NV_scissor_exclusive)," If the multiple viewports feature is not enabled, exclusiveScissorCount must be 0 or 1"
VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-exclusiveScissorCount-02028,Y,ExclusiveScissorNV,explicit,VkPipelineViewportExclusiveScissorStateCreateInfoNV,(VK_NV_scissor_exclusive), exclusiveScissorCount must be less than or equal to VkPhysicalDeviceLimits::maxViewports
VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-exclusiveScissorCount-02029,Y,ExclusiveScissorNV,explicit,VkPipelineViewportExclusiveScissorStateCreateInfoNV,(VK_NV_scissor_exclusive), exclusiveScissorCount must be 0 or identical to the viewportCount member of VkPipelineViewportStateCreateInfo
VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-pDynamicStates-02030,Y,ExclusiveScissorNV,explicit,VkPipelineViewportExclusiveScissorStateCreateInfoNV,(VK_NV_scissor_exclusive)," If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV and exclusiveScissorCount is not 0, pExclusiveScissors must be a valid pointer to an array of exclusiveScissorCount VkRect2D structures"
VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-pExclusiveScissors-parameter,N,None,implicit,VkPipelineViewportExclusiveScissorStateCreateInfoNV,(VK_NV_scissor_exclusive)," If exclusiveScissorCount is not 0, and pExclusiveScissors is not NULL, pExclusiveScissors must be a valid pointer to an array of exclusiveScissorCount VkRect2D structures"
VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-sType-sType,N,None,implicit,VkPipelineViewportExclusiveScissorStateCreateInfoNV,(VK_NV_scissor_exclusive), sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV
VUID-VkPipelineViewportShadingRateImageStateCreateInfoNV-pDynamicStates-02057,Y,ShadingRateImageNV,explicit,VkPipelineViewportShadingRateImageStateCreateInfoNV,(VK_NV_shading_rate_image)," If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV, pShadingRatePalettes must be a valid pointer to an array of viewportCount VkShadingRatePaletteNV structures"
VUID-VkPipelineViewportShadingRateImageStateCreateInfoNV-pShadingRatePalettes-parameter,N,None,implicit,VkPipelineViewportShadingRateImageStateCreateInfoNV,(VK_NV_shading_rate_image)," If viewportCount is not 0, and pShadingRatePalettes is not NULL, pShadingRatePalettes must be a valid pointer to an array of viewportCount valid VkShadingRatePaletteNV structures"
VUID-VkPipelineViewportShadingRateImageStateCreateInfoNV-sType-sType,N,None,implicit,VkPipelineViewportShadingRateImageStateCreateInfoNV,(VK_NV_shading_rate_image), sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV
VUID-VkPipelineViewportShadingRateImageStateCreateInfoNV-shadingRateImageEnable-02056,Y,ShadingRateImageNV,explicit,VkPipelineViewportShadingRateImageStateCreateInfoNV,(VK_NV_shading_rate_image)," If shadingRateImageEnable is VK_TRUE, viewportCount must be equal to the viewportCount member of VkPipelineViewportStateCreateInfo"
VUID-VkPipelineViewportShadingRateImageStateCreateInfoNV-viewportCount-02054,Y,ShadingRateImageNV,explicit,VkPipelineViewportShadingRateImageStateCreateInfoNV,(VK_NV_shading_rate_image)," If the multiple viewports feature is not enabled, viewportCount must be 0 or 1"
VUID-VkPipelineViewportShadingRateImageStateCreateInfoNV-viewportCount-02055,Y,None,explicit,VkPipelineViewportShadingRateImageStateCreateInfoNV,(VK_NV_shading_rate_image), viewportCount must be less than or equal to VkPhysicalDeviceLimits::maxViewports
VUID-VkPipelineViewportStateCreateInfo-flags-zerobitmask,Y,None,implicit,VkPipelineViewportStateCreateInfo,core, flags must be 0
VUID-VkPipelineViewportStateCreateInfo-pNext-pNext,Y,None,implicit,VkPipelineViewportStateCreateInfo,core," Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, VkPipelineViewportExclusiveScissorStateCreateInfoNV, VkPipelineViewportShadingRateImageStateCreateInfoNV, VkPipelineViewportSwizzleStateCreateInfoNV, or VkPipelineViewportWScalingStateCreateInfoNV"
VUID-VkPipelineViewportStateCreateInfo-sType-sType,Y,None,implicit,VkPipelineViewportStateCreateInfo,core, sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO
VUID-VkPipelineViewportStateCreateInfo-sType-unique,N,None,implicit,VkPipelineViewportStateCreateInfo,core, Each sType member in the pNext chain must be unique
VUID-VkPipelineViewportStateCreateInfo-scissorCount-01217,Y,"ShadingRateImageNV, PSOViewportStateTests",explicit,VkPipelineViewportStateCreateInfo,core," If the multiple viewports feature is not enabled, scissorCount must be 1"
VUID-VkPipelineViewportStateCreateInfo-scissorCount-01219,Y,PSOViewportStateMultiViewportTests,explicit,VkPipelineViewportStateCreateInfo,core," scissorCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive"
VUID-VkPipelineViewportStateCreateInfo-scissorCount-01220,Y,"PSOViewportStateMultiViewportTests, PSOViewportStateTests",explicit,VkPipelineViewportStateCreateInfo,core, scissorCount and viewportCount must be identical
VUID-VkPipelineViewportStateCreateInfo-scissorCount-arraylength,Y,PSOViewportStateMultiViewportTests,implicit,VkPipelineViewportStateCreateInfo,core, scissorCount must be greater than 0
VUID-VkPipelineViewportStateCreateInfo-viewportCount-01216,Y,"ShadingRateImageNV, PSOViewportStateTests",explicit,VkPipelineViewportStateCreateInfo,core," If the multiple viewports feature is not enabled, viewportCount must be 1"
VUID-VkPipelineViewportStateCreateInfo-viewportCount-01218,Y,PSOViewportStateMultiViewportTests,explicit,VkPipelineViewportStateCreateInfo,core," viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive"
VUID-VkPipelineViewportStateCreateInfo-viewportCount-arraylength,Y,PSOViewportStateMultiViewportTests,implicit,VkPipelineViewportStateCreateInfo,core, viewportCount must be greater than 0
VUID-VkPipelineViewportStateCreateInfo-viewportWScalingEnable-01726,N,None,explicit,VkPipelineViewportStateCreateInfo,(VK_NV_clip_space_w_scaling)," If the viewportWScalingEnable member of a VkPipelineViewportWScalingStateCreateInfoNV structure chained to the pNext chain is VK_TRUE, the viewportCount member of the VkPipelineViewportWScalingStateCreateInfoNV structure must be equal to viewportCount"
VUID-VkPipelineViewportSwizzleStateCreateInfoNV-flags-zerobitmask,Y,None,implicit,VkPipelineViewportSwizzleStateCreateInfoNV,(VK_NV_viewport_swizzle), flags must be 0
VUID-VkPipelineViewportSwizzleStateCreateInfoNV-sType-sType,N,None,implicit,VkPipelineViewportSwizzleStateCreateInfoNV,(VK_NV_viewport_swizzle), sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV
VUID-VkPipelineViewportSwizzleStateCreateInfoNV-viewportCount-01215,N,None,explicit,VkPipelineViewportSwizzleStateCreateInfoNV,(VK_NV_viewport_swizzle), viewportCount must match the viewportCount set in VkPipelineViewportStateCreateInfo
VUID-VkPipelineViewportSwizzleStateCreateInfoNV-viewportCount-arraylength,N,None,implicit,VkPipelineViewportSwizzleStateCreateInfoNV,(VK_NV_viewport_swizzle), viewportCount must be greater than 0
VUID-VkPipelineViewportWScalingStateCreateInfoNV-sType-sType,N,None,implicit,VkPipelineViewportWScalingStateCreateInfoNV,(VK_NV_clip_space_w_scaling), sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV
VUID-VkPipelineViewportWScalingStateCreateInfoNV-viewportCount-arraylength,N,None,implicit,VkPipelineViewportWScalingStateCreateInfoNV,(VK_NV_clip_space_w_scaling), viewportCount must be greater than 0
VUID-VkPresentInfoKHR-commonparent,Y,None,implicit,VkPresentInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," Both of the elements of pSwapchains, and the elements of pWaitSemaphores that are valid handles must have been created, allocated, or retrieved from the same VkInstance"
VUID-VkPresentInfoKHR-pImageIndices-01296,Y,None,explicit,VkPresentInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+!(VK_KHR_shared_presentable_image)," Each element of pImageIndices must be the index of a presentable image acquired from the swapchain specified by the corresponding element of the pSwapchains array, and the presented image subresource must be in the VK_IMAGE_LAYOUT_PRESENT_SRC_KHR layout at the time the operation is executed on a VkDevice"
VUID-VkPresentInfoKHR-pImageIndices-01430,N,None,explicit,VkPresentInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_shared_presentable_image)," Each element of pImageIndices must be the index of a presentable image acquired from the swapchain specified by the corresponding element of the pSwapchains array, and the presented image subresource must be in the VK_IMAGE_LAYOUT_PRESENT_SRC_KHR or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR layout at the time the operation is executed on a VkDevice"
VUID-VkPresentInfoKHR-pImageIndices-parameter,Y,None,implicit,VkPresentInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), pImageIndices must be a valid pointer to an array of swapchainCount uint32_t values
VUID-VkPresentInfoKHR-pNext-pNext,Y,None,implicit,VkPresentInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupPresentInfoKHR, VkDisplayPresentInfoKHR, VkPresentRegionsKHR, or VkPresentTimesInfoGOOGLE"
VUID-VkPresentInfoKHR-pResults-parameter,Y,None,implicit,VkPresentInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," If pResults is not NULL, pResults must be a valid pointer to an array of swapchainCount VkResult values"
VUID-VkPresentInfoKHR-pSwapchains-parameter,Y,None,implicit,VkPresentInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), pSwapchains must be a valid pointer to an array of swapchainCount valid VkSwapchainKHR handles
VUID-VkPresentInfoKHR-pWaitSemaphores-parameter,Y,None,implicit,VkPresentInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," If waitSemaphoreCount is not 0, pWaitSemaphores must be a valid pointer to an array of waitSemaphoreCount valid VkSemaphore handles"
VUID-VkPresentInfoKHR-sType-sType,Y,None,implicit,VkPresentInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), sType must be VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
VUID-VkPresentInfoKHR-sType-unique,N,None,implicit,VkPresentInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), Each sType member in the pNext chain must be unique
VUID-VkPresentInfoKHR-swapchainCount-arraylength,Y,None,implicit,VkPresentInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), swapchainCount must be greater than 0
VUID-VkPresentRegionKHR-pRectangles-parameter,N,None,implicit,VkPresentRegionKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_incremental_present)," If rectangleCount is not 0, and pRectangles is not NULL, pRectangles must be a valid pointer to an array of rectangleCount valid VkRectLayerKHR structures"
VUID-VkPresentRegionsKHR-pRegions-parameter,Y,None,implicit,VkPresentRegionsKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_incremental_present)," If pRegions is not NULL, pRegions must be a valid pointer to an array of swapchainCount valid VkPresentRegionKHR structures"
VUID-VkPresentRegionsKHR-sType-sType,N,None,implicit,VkPresentRegionsKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_incremental_present), sType must be VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR
VUID-VkPresentRegionsKHR-swapchainCount-01260,N,None,explicit,VkPresentRegionsKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_incremental_present)," swapchainCount must be the same value as VkPresentInfoKHR::swapchainCount, where VkPresentInfoKHR is in the pNext-chain of this VkPresentRegionsKHR structure."
VUID-VkPresentRegionsKHR-swapchainCount-arraylength,Y,None,implicit,VkPresentRegionsKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_incremental_present), swapchainCount must be greater than 0
VUID-VkPresentTimesInfoGOOGLE-pTimes-parameter,Y,None,implicit,VkPresentTimesInfoGOOGLE,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing)," If pTimes is not NULL, pTimes must be a valid pointer to an array of swapchainCount VkPresentTimeGOOGLE structures"
VUID-VkPresentTimesInfoGOOGLE-sType-sType,N,None,implicit,VkPresentTimesInfoGOOGLE,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing), sType must be VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE
VUID-VkPresentTimesInfoGOOGLE-swapchainCount-01247,Y,None,explicit,VkPresentTimesInfoGOOGLE,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing)," swapchainCount must be the same value as VkPresentInfoKHR::swapchainCount, where VkPresentInfoKHR is in the pNext chain of this VkPresentTimesInfoGOOGLE structure."
VUID-VkPresentTimesInfoGOOGLE-swapchainCount-arraylength,Y,None,implicit,VkPresentTimesInfoGOOGLE,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing), swapchainCount must be greater than 0
VUID-VkProtectedSubmitInfo-pNext-01819,N,None,explicit,VkProtectedSubmitInfo,(VK_VERSION_1_1)," If the VkSubmitInfo::pNext chain does not include a VkProtectedSubmitInfo structure, then each element of the command buffer of the pCommandBuffers array must be an unprotected command buffer."
VUID-VkProtectedSubmitInfo-protectedSubmit-01816,N,None,explicit,VkProtectedSubmitInfo,(VK_VERSION_1_1)," If the protected memory feature is not enabled, protectedSubmit must not be VK_TRUE."
VUID-VkProtectedSubmitInfo-protectedSubmit-01817,N,None,explicit,VkProtectedSubmitInfo,(VK_VERSION_1_1)," If protectedSubmit is VK_TRUE, then each element of the pCommandBuffers array must be a protected command buffer."
VUID-VkProtectedSubmitInfo-protectedSubmit-01818,N,None,explicit,VkProtectedSubmitInfo,(VK_VERSION_1_1)," If protectedSubmit is VK_FALSE, then each element of the pCommandBuffers array must be an unprotected command buffer."
VUID-VkProtectedSubmitInfo-sType-sType,N,None,implicit,VkProtectedSubmitInfo,(VK_VERSION_1_1), sType must be VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO
VUID-VkPushConstantRange-offset-00294,Y,None,explicit,VkPushConstantRange,core, offset must be less than VkPhysicalDeviceLimits::maxPushConstantsSize
VUID-VkPushConstantRange-offset-00295,Y,None,explicit,VkPushConstantRange,core, offset must be a multiple of 4
VUID-VkPushConstantRange-size-00296,Y,None,explicit,VkPushConstantRange,core, size must be greater than 0
VUID-VkPushConstantRange-size-00297,Y,None,explicit,VkPushConstantRange,core, size must be a multiple of 4
VUID-VkPushConstantRange-size-00298,Y,None,explicit,VkPushConstantRange,core, size must be less than or equal to VkPhysicalDeviceLimits::maxPushConstantsSize minus offset
VUID-VkPushConstantRange-stageFlags-parameter,N,None,implicit,VkPushConstantRange,core, stageFlags must be a valid combination of VkShaderStageFlagBits values
VUID-VkPushConstantRange-stageFlags-requiredbitmask,Y,None,implicit,VkPushConstantRange,core, stageFlags must not be 0
VUID-VkQueryPoolCreateInfo-flags-zerobitmask,Y,None,implicit,VkQueryPoolCreateInfo,core, flags must be 0
VUID-VkQueryPoolCreateInfo-pNext-pNext,Y,None,implicit,VkQueryPoolCreateInfo,core, pNext must be NULL
VUID-VkQueryPoolCreateInfo-queryType-00791,Y,InvalidQueryPoolCreate,explicit,VkQueryPoolCreateInfo,core," If the pipeline statistics queries feature is not enabled, queryType must not be VK_QUERY_TYPE_PIPELINE_STATISTICS"
VUID-VkQueryPoolCreateInfo-queryType-00792,Y,None,explicit,VkQueryPoolCreateInfo,core," If queryType is VK_QUERY_TYPE_PIPELINE_STATISTICS, pipelineStatistics must be a valid combination of VkQueryPipelineStatisticFlagBits values"
VUID-VkQueryPoolCreateInfo-queryType-parameter,Y,None,implicit,VkQueryPoolCreateInfo,core, queryType must be a valid VkQueryType value
VUID-VkQueryPoolCreateInfo-sType-sType,Y,None,implicit,VkQueryPoolCreateInfo,core, sType must be VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO
VUID-VkQueueFamilyCheckpointPropertiesNV-sType-sType,N,None,implicit,VkQueueFamilyCheckpointPropertiesNV,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_NV_device_diagnostic_checkpoints)", sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV
VUID-VkQueueFamilyProperties2-pNext-pNext,Y,None,implicit,VkQueueFamilyProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", pNext must be NULL or a pointer to a valid instance of VkQueueFamilyCheckpointPropertiesNV
VUID-VkQueueFamilyProperties2-sType-sType,Y,None,implicit,VkQueueFamilyProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2
VUID-VkRaytracingPipelineCreateInfoNVX-commonparent,Y,None,implicit,VkRaytracingPipelineCreateInfoNVX,(VK_NVX_raytracing)," Both of basePipelineHandle, and layout that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkRaytracingPipelineCreateInfoNVX-flags-parameter,Y,None,implicit,VkRaytracingPipelineCreateInfoNVX,(VK_NVX_raytracing), flags must be a valid combination of VkPipelineCreateFlagBits values
VUID-VkRaytracingPipelineCreateInfoNVX-layout-parameter,Y,None,implicit,VkRaytracingPipelineCreateInfoNVX,(VK_NVX_raytracing), layout must be a valid VkPipelineLayout handle
VUID-VkRaytracingPipelineCreateInfoNVX-pGroupNumbers-parameter,Y,None,implicit,VkRaytracingPipelineCreateInfoNVX,(VK_NVX_raytracing), pGroupNumbers must be a valid pointer to an array of stageCount uint32_t values
VUID-VkRaytracingPipelineCreateInfoNVX-pNext-pNext,Y,None,implicit,VkRaytracingPipelineCreateInfoNVX,(VK_NVX_raytracing), pNext must be NULL
VUID-VkRaytracingPipelineCreateInfoNVX-pStages-parameter,Y,None,implicit,VkRaytracingPipelineCreateInfoNVX,(VK_NVX_raytracing), pStages must be a valid pointer to an array of stageCount valid VkPipelineShaderStageCreateInfo structures
VUID-VkRaytracingPipelineCreateInfoNVX-sType-sType,Y,None,implicit,VkRaytracingPipelineCreateInfoNVX,(VK_NVX_raytracing), sType must be VK_STRUCTURE_TYPE_RAYTRACING_PIPELINE_CREATE_INFO_NVX
VUID-VkRaytracingPipelineCreateInfoNVX-stageCount-arraylength,Y,None,implicit,VkRaytracingPipelineCreateInfoNVX,(VK_NVX_raytracing), stageCount must be greater than 0
VUID-VkRectLayerKHR-layer-01262,Y,None,explicit,VkRectLayerKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_incremental_present), layer must be less than imageArrayLayers member of the VkSwapchainCreateInfoKHR structure given to vkCreateSwapchainKHR.
VUID-VkRectLayerKHR-offset-01261,Y,None,explicit,VkRectLayerKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_incremental_present), The sum of offset and extent must be no greater than the imageExtent member of the VkSwapchainCreateInfoKHR structure given to vkCreateSwapchainKHR.
VUID-VkRenderPassBeginInfo-clearValueCount-00902,Y,RenderPassClearOpMismatch,explicit,VkRenderPassBeginInfo,core," clearValueCount must be greater than the largest attachment index in renderPass that specifies a loadOp (or stencilLoadOp, if the attachment has a depth/stencil format) of VK_ATTACHMENT_LOAD_OP_CLEAR"
VUID-VkRenderPassBeginInfo-clearValueCount-00903,N,None,explicit,VkRenderPassBeginInfo,core," If clearValueCount is not 0, pClearValues must be a valid pointer to an array of clearValueCount valid VkClearValue unions"
VUID-VkRenderPassBeginInfo-commonparent,Y,None,implicit,VkRenderPassBeginInfo,core," Both of framebuffer, and renderPass must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkRenderPassBeginInfo-framebuffer-parameter,Y,RenderPassMissingAttachment,implicit,VkRenderPassBeginInfo,core, framebuffer must be a valid VkFramebuffer handle
VUID-VkRenderPassBeginInfo-pNext-pNext,Y,None,implicit,VkRenderPassBeginInfo,core, Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupRenderPassBeginInfo or VkRenderPassSampleLocationsBeginInfoEXT
VUID-VkRenderPassBeginInfo-renderPass-00904,Y,None,explicit,VkRenderPassBeginInfo,core, renderPass must be compatible with the renderPass member of the VkFramebufferCreateInfo structure specified when creating framebuffer.
VUID-VkRenderPassBeginInfo-renderPass-parameter,Y,None,implicit,VkRenderPassBeginInfo,core, renderPass must be a valid VkRenderPass handle
VUID-VkRenderPassBeginInfo-sType-sType,Y,None,implicit,VkRenderPassBeginInfo,core, sType must be VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO
VUID-VkRenderPassBeginInfo-sType-unique,N,None,implicit,VkRenderPassBeginInfo,core, Each sType member in the pNext chain must be unique
VUID-VkRenderPassCreateInfo-None-00832,N,None,explicit,VkRenderPassCreateInfo,core," If any two subpasses operate on attachments with overlapping ranges of the same VkDeviceMemory object, and at least one subpass writes to that area of VkDeviceMemory, a subpass dependency must be included (either directly or via some intermediate subpasses) between them"
VUID-VkRenderPassCreateInfo-attachment-00833,Y,None,explicit,VkRenderPassCreateInfo,core," If the attachment member of any element of pInputAttachments, pColorAttachments, pResolveAttachments or pDepthStencilAttachment, or the attachment indexed by any element of pPreserveAttachments in any element of pSubpasses is bound to a range of a VkDeviceMemory object that overlaps with any other attachment in any subpass (including the same subpass), the VkAttachmentDescription structures describing them must include VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT in flags"
VUID-VkRenderPassCreateInfo-attachment-00834,Y,RenderPassAttachmentIndexOutOfRange,explicit,VkRenderPassCreateInfo,core," If the attachment member of any element of pInputAttachments, pColorAttachments, pResolveAttachments or pDepthStencilAttachment, or any element of pPreserveAttachments in any element of pSubpasses is not VK_ATTACHMENT_UNUSED, it must be less than attachmentCount"
VUID-VkRenderPassCreateInfo-flags-zerobitmask,Y,None,implicit,VkRenderPassCreateInfo,core, flags must be 0
VUID-VkRenderPassCreateInfo-pAttachments-00836,Y,None,explicit,VkRenderPassCreateInfo,core," For any member of pAttachments with a loadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL."
VUID-VkRenderPassCreateInfo-pAttachments-01566,Y,None,explicit,VkRenderPassCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)"," For any member of pAttachments with a loadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL."
VUID-VkRenderPassCreateInfo-pAttachments-01567,Y,None,explicit,VkRenderPassCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)"," For any member of pAttachments with a stencilLoadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL."
VUID-VkRenderPassCreateInfo-pAttachments-parameter,Y,None,implicit,VkRenderPassCreateInfo,core," If attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkAttachmentDescription structures"
VUID-VkRenderPassCreateInfo-pDependencies-00837,N,None,explicit,VkRenderPassCreateInfo,core," For any element of pDependencies, if the srcSubpass is not VK_SUBPASS_EXTERNAL, all stage flags included in the srcStageMask member of that dependency must be a pipeline stage supported by the pipeline identified by the pipelineBindPoint member of the source subpass."
VUID-VkRenderPassCreateInfo-pDependencies-00838,N,None,explicit,VkRenderPassCreateInfo,core," For any element of pDependencies, if the dstSubpass is not VK_SUBPASS_EXTERNAL, all stage flags included in the dstStageMask member of that dependency must be a pipeline stage supported by the pipeline identified by the pipelineBindPoint member of the source subpass."
VUID-VkRenderPassCreateInfo-pDependencies-parameter,Y,None,implicit,VkRenderPassCreateInfo,core," If dependencyCount is not 0, pDependencies must be a valid pointer to an array of dependencyCount valid VkSubpassDependency structures"
VUID-VkRenderPassCreateInfo-pNext-01926,N,None,explicit,VkRenderPassCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)"," If the pNext chain includes an instance of VkRenderPassInputAttachmentAspectCreateInfo, the subpass member of each element of its pAspectReferences member must be less than subpassCount"
VUID-VkRenderPassCreateInfo-pNext-01927,N,None,explicit,VkRenderPassCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)"," If the pNext chain includes an instance of VkRenderPassInputAttachmentAspectCreateInfo, the inputAttachmentIndex member of each element of its pAspectReferences member must be less than the value of inputAttachmentCount in the member of pSubpasses identified by its subpass member"
VUID-VkRenderPassCreateInfo-pNext-01928,N,None,explicit,VkRenderPassCreateInfo,"(VK_VERSION_1_1,VK_KHR_multiview)"," If the pNext chain includes an instance of VkRenderPassMultiviewCreateInfo, and its subpassCount member is not zero, that member must be equal to the value of subpassCount"
VUID-VkRenderPassCreateInfo-pNext-01929,N,None,explicit,VkRenderPassCreateInfo,"(VK_VERSION_1_1,VK_KHR_multiview)"," If the pNext chain includes an instance of VkRenderPassMultiviewCreateInfo, if its dependencyCount member is not zero, it must be equal to dependencyCount"
VUID-VkRenderPassCreateInfo-pNext-01930,N,None,explicit,VkRenderPassCreateInfo,"(VK_VERSION_1_1,VK_KHR_multiview)"," If the pNext chain includes an instance of VkRenderPassMultiviewCreateInfo, for each non-zero element of pViewOffsets, the srcSubpass and dstSubpass members of pDependencies at the same index must not be equal"
VUID-VkRenderPassCreateInfo-pNext-01963,N,None,explicit,VkRenderPassCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)"," If the pNext chain includes an instance of VkRenderPassInputAttachmentAspectCreateInfo, the aspectMask member of any element of pAspectReferences must only include aspects that are present in images of the format of the input attachment specified by the subpass and inputAttachment of the same element of pAspectReferences"
VUID-VkRenderPassCreateInfo-pNext-pNext,Y,None,implicit,VkRenderPassCreateInfo,core, Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkRenderPassInputAttachmentAspectCreateInfo or VkRenderPassMultiviewCreateInfo
VUID-VkRenderPassCreateInfo-pPreserveAttachments-00835,N,None,explicit,VkRenderPassCreateInfo,core, The value of each element of the pPreserveAttachments member in each element of pSubpasses must not be VK_ATTACHMENT_UNUSED
VUID-VkRenderPassCreateInfo-pSubpasses-parameter,Y,None,implicit,VkRenderPassCreateInfo,core, pSubpasses must be a valid pointer to an array of subpassCount valid VkSubpassDescription structures
VUID-VkRenderPassCreateInfo-sType-sType,Y,None,implicit,VkRenderPassCreateInfo,core, sType must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO
VUID-VkRenderPassCreateInfo-sType-unique,N,None,implicit,VkRenderPassCreateInfo,core, Each sType member in the pNext chain must be unique
VUID-VkRenderPassCreateInfo-subpassCount-arraylength,Y,None,implicit,VkRenderPassCreateInfo,core, subpassCount must be greater than 0
VUID-VkRenderPassCreateInfo2KHR-None-03049,N,None,explicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2)," If any two subpasses operate on attachments with overlapping ranges of the same VkDeviceMemory object, and at least one subpass writes to that area of VkDeviceMemory, a subpass dependency must be included (either directly or via some intermediate subpasses) between them"
VUID-VkRenderPassCreateInfo2KHR-attachment-03050,N,None,explicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2)," If the attachment member of any element of pInputAttachments, pColorAttachments, pResolveAttachments or pDepthStencilAttachment, or the attachment indexed by any element of pPreserveAttachments in any given element of pSubpasses is bound to a range of a VkDeviceMemory object that overlaps with any other attachment in any subpass (including the same subpass), the VkAttachmentDescription2KHR structures describing them must include VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT in flags"
VUID-VkRenderPassCreateInfo2KHR-attachment-03051,N,None,explicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2)," If the attachment member of any element of pInputAttachments, pColorAttachments, pResolveAttachments or pDepthStencilAttachment, or any element of pPreserveAttachments in any given element of pSubpasses is not VK_ATTACHMENT_UNUSED, it must be less than attachmentCount"
VUID-VkRenderPassCreateInfo2KHR-flags-zerobitmask,Y,None,implicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2), flags must be 0
VUID-VkRenderPassCreateInfo2KHR-pAttachments-03053,N,None,explicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2)," For any member of pAttachments with a loadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL."
VUID-VkRenderPassCreateInfo2KHR-pAttachments-parameter,Y,None,implicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2)," If attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkAttachmentDescription2KHR structures"
VUID-VkRenderPassCreateInfo2KHR-pCorrelatedViewMasks-03056,N,None,explicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2), The set of bits included in any element of pCorrelatedViewMasks must not overlap with the set of bits included in any other element of pCorrelatedViewMasks
VUID-VkRenderPassCreateInfo2KHR-pCorrelatedViewMasks-parameter,Y,None,implicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2)," If correlatedViewMaskCount is not 0, pCorrelatedViewMasks must be a valid pointer to an array of correlatedViewMaskCount uint32_t values"
VUID-VkRenderPassCreateInfo2KHR-pDependencies-03054,N,None,explicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2)," For any element of pDependencies, if the srcSubpass is not VK_SUBPASS_EXTERNAL, all stage flags included in the srcStageMask member of that dependency must be a pipeline stage supported by the pipeline identified by the pipelineBindPoint member of the source subpass."
VUID-VkRenderPassCreateInfo2KHR-pDependencies-03055,N,None,explicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2)," For any element of pDependencies, if the dstSubpass is not VK_SUBPASS_EXTERNAL, all stage flags included in the dstStageMask member of that dependency must be a pipeline stage supported by the pipeline identified by the pipelineBindPoint member of the source subpass."
VUID-VkRenderPassCreateInfo2KHR-pDependencies-03060,N,None,explicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2)," For any element of pDependencies where its srcSubpass member equals its dstSubpass member, if the viewMask member of the corresponding element of pSubpasses includes more than one bit, its dependencyFlags member must include VK_DEPENDENCY_VIEW_LOCAL_BIT"
VUID-VkRenderPassCreateInfo2KHR-pDependencies-parameter,Y,None,implicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2)," If dependencyCount is not 0, pDependencies must be a valid pointer to an array of dependencyCount valid VkSubpassDependency2KHR structures"
VUID-VkRenderPassCreateInfo2KHR-pNext-pNext,Y,None,implicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2), pNext must be NULL
VUID-VkRenderPassCreateInfo2KHR-pPreserveAttachments-03052,N,None,explicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2), The value of any element of the pPreserveAttachments member in any given element of pSubpasses must not be VK_ATTACHMENT_UNUSED
VUID-VkRenderPassCreateInfo2KHR-pSubpasses-parameter,Y,None,implicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2), pSubpasses must be a valid pointer to an array of subpassCount valid VkSubpassDescription2KHR structures
VUID-VkRenderPassCreateInfo2KHR-sType-sType,Y,None,implicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2), sType must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR
VUID-VkRenderPassCreateInfo2KHR-subpassCount-arraylength,N,None,implicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2), subpassCount must be greater than 0
VUID-VkRenderPassCreateInfo2KHR-viewMask-03057,N,None,explicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2)," If the VkSubpassDescription2KHR::viewMask member of all elements of pSubpasses is 0, correlatedViewMaskCount must be 0"
VUID-VkRenderPassCreateInfo2KHR-viewMask-03058,N,None,explicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2)," The VkSubpassDescription2KHR::viewMask member of all elements of pSubpasses must either all be 0, or all not be 0"
VUID-VkRenderPassCreateInfo2KHR-viewMask-03059,N,None,explicit,VkRenderPassCreateInfo2KHR,(VK_KHR_create_renderpass2)," If the VkSubpassDescription2KHR::viewMask member of all elements of pSubpasses is 0, the dependencyFlags member of any element of pDependencies must not include VK_DEPENDENCY_VIEW_LOCAL_BIT"
VUID-VkRenderPassInputAttachmentAspectCreateInfo-aspectReferenceCount-arraylength,Y,None,implicit,VkRenderPassInputAttachmentAspectCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)", aspectReferenceCount must be greater than 0
VUID-VkRenderPassInputAttachmentAspectCreateInfo-pAspectReferences-parameter,Y,None,implicit,VkRenderPassInputAttachmentAspectCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)", pAspectReferences must be a valid pointer to an array of aspectReferenceCount valid VkInputAttachmentAspectReference structures
VUID-VkRenderPassInputAttachmentAspectCreateInfo-sType-sType,N,None,implicit,VkRenderPassInputAttachmentAspectCreateInfo,"(VK_VERSION_1_1,VK_KHR_maintenance2)", sType must be VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO
VUID-VkRenderPassMultiviewCreateInfo-pCorrelationMasks-00841,N,None,explicit,VkRenderPassMultiviewCreateInfo,"(VK_VERSION_1_1,VK_KHR_multiview)", Each view index must not be set in more than one element of pCorrelationMasks
VUID-VkRenderPassMultiviewCreateInfo-pCorrelationMasks-parameter,Y,None,implicit,VkRenderPassMultiviewCreateInfo,"(VK_VERSION_1_1,VK_KHR_multiview)"," If correlationMaskCount is not 0, pCorrelationMasks must be a valid pointer to an array of correlationMaskCount uint32_t values"
VUID-VkRenderPassMultiviewCreateInfo-pViewMasks-parameter,Y,None,implicit,VkRenderPassMultiviewCreateInfo,"(VK_VERSION_1_1,VK_KHR_multiview)"," If subpassCount is not 0, pViewMasks must be a valid pointer to an array of subpassCount uint32_t values"
VUID-VkRenderPassMultiviewCreateInfo-pViewOffsets-parameter,Y,None,implicit,VkRenderPassMultiviewCreateInfo,"(VK_VERSION_1_1,VK_KHR_multiview)"," If dependencyCount is not 0, pViewOffsets must be a valid pointer to an array of dependencyCount int32_t values"
VUID-VkRenderPassMultiviewCreateInfo-sType-sType,N,None,implicit,VkRenderPassMultiviewCreateInfo,"(VK_VERSION_1_1,VK_KHR_multiview)", sType must be VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO
VUID-VkRenderPassSampleLocationsBeginInfoEXT-pAttachmentInitialSampleLocations-parameter,Y,None,implicit,VkRenderPassSampleLocationsBeginInfoEXT,(VK_EXT_sample_locations)," If attachmentInitialSampleLocationsCount is not 0, pAttachmentInitialSampleLocations must be a valid pointer to an array of attachmentInitialSampleLocationsCount valid VkAttachmentSampleLocationsEXT structures"
VUID-VkRenderPassSampleLocationsBeginInfoEXT-pPostSubpassSampleLocations-parameter,Y,None,implicit,VkRenderPassSampleLocationsBeginInfoEXT,(VK_EXT_sample_locations)," If postSubpassSampleLocationsCount is not 0, pPostSubpassSampleLocations must be a valid pointer to an array of postSubpassSampleLocationsCount valid VkSubpassSampleLocationsEXT structures"
VUID-VkRenderPassSampleLocationsBeginInfoEXT-sType-sType,N,None,implicit,VkRenderPassSampleLocationsBeginInfoEXT,(VK_EXT_sample_locations), sType must be VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT
VUID-VkSampleLocationsInfoEXT-pSampleLocations-parameter,Y,None,implicit,VkSampleLocationsInfoEXT,(VK_EXT_sample_locations), pSampleLocations must be a valid pointer to an array of sampleLocationsCount VkSampleLocationEXT structures
VUID-VkSampleLocationsInfoEXT-sType-sType,Y,None,implicit,VkSampleLocationsInfoEXT,(VK_EXT_sample_locations), sType must be VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT
VUID-VkSampleLocationsInfoEXT-sampleLocationsCount-01527,N,None,explicit,VkSampleLocationsInfoEXT,(VK_EXT_sample_locations), sampleLocationsCount must equal sampleLocationsPerPixel {times} sampleLocationGridSize.width {times} sampleLocationGridSize.height
VUID-VkSampleLocationsInfoEXT-sampleLocationsCount-arraylength,Y,None,implicit,VkSampleLocationsInfoEXT,(VK_EXT_sample_locations), sampleLocationsCount must be greater than 0
VUID-VkSampleLocationsInfoEXT-sampleLocationsPerPixel-01526,N,None,explicit,VkSampleLocationsInfoEXT,(VK_EXT_sample_locations), sampleLocationsPerPixel must be a bit value that is set in VkPhysicalDeviceSampleLocationsPropertiesEXT::sampleLocationSampleCounts
VUID-VkSampleLocationsInfoEXT-sampleLocationsPerPixel-parameter,Y,None,implicit,VkSampleLocationsInfoEXT,(VK_EXT_sample_locations), sampleLocationsPerPixel must be a valid VkSampleCountFlagBits value
VUID-VkSamplerCreateInfo-None-01647,N,None,explicit,VkSamplerCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)+(VK_EXT_sampler_filter_minmax)", The sampler reduction mode must be set to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT if sampler Y'CBCR conversion is enabled
VUID-VkSamplerCreateInfo-addressModeU-01078,Y,None,explicit,VkSamplerCreateInfo,core," If any of addressModeU, addressModeV or addressModeW are VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER, borderColor must be a valid VkBorderColor value"
VUID-VkSamplerCreateInfo-addressModeU-01079,Y,MirrorClampToEdgeNotEnabled,explicit,VkSamplerCreateInfo,core," If the VK_KHR_sampler_mirror_clamp_to_edge extension is not enabled, addressModeU, addressModeV and addressModeW must not be VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE"
VUID-VkSamplerCreateInfo-addressModeU-01646,N,None,explicit,VkSamplerCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If sampler Y'CBCR conversion is enabled, addressModeU, addressModeV, and addressModeW must be VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, anisotropyEnable must be VK_FALSE, and unnormalizedCoordinates must be VK_FALSE"
VUID-VkSamplerCreateInfo-addressModeU-parameter,Y,None,implicit,VkSamplerCreateInfo,core, addressModeU must be a valid VkSamplerAddressMode value
VUID-VkSamplerCreateInfo-addressModeV-parameter,Y,None,implicit,VkSamplerCreateInfo,core, addressModeV must be a valid VkSamplerAddressMode value
VUID-VkSamplerCreateInfo-addressModeW-parameter,Y,None,implicit,VkSamplerCreateInfo,core, addressModeW must be a valid VkSamplerAddressMode value
VUID-VkSamplerCreateInfo-anisotropyEnable-01070,Y,AnisotropyFeatureDisabled,explicit,VkSamplerCreateInfo,core," If the anisotropic sampling feature is not enabled, anisotropyEnable must be VK_FALSE"
VUID-VkSamplerCreateInfo-anisotropyEnable-01071,Y,AnisotropyFeatureEnabled,explicit,VkSamplerCreateInfo,core," If anisotropyEnable is VK_TRUE, maxAnisotropy must be between 1.0 and VkPhysicalDeviceLimits::maxSamplerAnisotropy, inclusive"
VUID-VkSamplerCreateInfo-compareEnable-01080,Y,None,explicit,VkSamplerCreateInfo,core," If compareEnable is VK_TRUE, compareOp must be a valid VkCompareOp value"
VUID-VkSamplerCreateInfo-compareEnable-01423,N,None,explicit,VkSamplerCreateInfo,(VK_EXT_sampler_filter_minmax)," If compareEnable is VK_TRUE, the reductionMode member of VkSamplerReductionModeCreateInfoEXT must be VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT"
VUID-VkSamplerCreateInfo-flags-zerobitmask,Y,None,implicit,VkSamplerCreateInfo,core, flags must be 0
VUID-VkSamplerCreateInfo-magFilter-01081,Y,AnisotropyFeatureEnabled,explicit,VkSamplerCreateInfo,(VK_IMG_filter_cubic)," If either magFilter or minFilter is VK_FILTER_CUBIC_IMG, anisotropyEnable must be VK_FALSE"
VUID-VkSamplerCreateInfo-magFilter-01422,N,None,explicit,VkSamplerCreateInfo,(VK_IMG_filter_cubic+VK_EXT_sampler_filter_minmax)," If either magFilter or minFilter is VK_FILTER_CUBIC_IMG, the reductionMode member of VkSamplerReductionModeCreateInfoEXT must be VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT"
VUID-VkSamplerCreateInfo-magFilter-parameter,Y,None,implicit,VkSamplerCreateInfo,core, magFilter must be a valid VkFilter value
VUID-VkSamplerCreateInfo-maxLod-01973,N,None,explicit,VkSamplerCreateInfo,core, maxLod must be greater than or equal to minLod
VUID-VkSamplerCreateInfo-minFilter-01645,N,None,explicit,VkSamplerCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If sampler Y'CBCR conversion is enabled and VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT is not set for the format, minFilter and magFilter must be equal to the sampler Y'CBCR conversion's chromaFilter"
VUID-VkSamplerCreateInfo-minFilter-parameter,Y,None,implicit,VkSamplerCreateInfo,core, minFilter must be a valid VkFilter value
VUID-VkSamplerCreateInfo-mipLodBias-01069,N,None,explicit,VkSamplerCreateInfo,core, The absolute value of mipLodBias must be less than or equal to VkPhysicalDeviceLimits::maxSamplerLodBias
VUID-VkSamplerCreateInfo-mipmapMode-parameter,Y,None,implicit,VkSamplerCreateInfo,core, mipmapMode must be a valid VkSamplerMipmapMode value
VUID-VkSamplerCreateInfo-pNext-pNext,Y,None,implicit,VkSamplerCreateInfo,core, Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkSamplerReductionModeCreateInfoEXT or VkSamplerYcbcrConversionInfo
VUID-VkSamplerCreateInfo-sType-sType,Y,None,implicit,VkSamplerCreateInfo,core, sType must be VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO
VUID-VkSamplerCreateInfo-sType-unique,N,None,implicit,VkSamplerCreateInfo,core, Each sType member in the pNext chain must be unique
VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01072,Y,UnnormalizedCoordinatesEnabled,explicit,VkSamplerCreateInfo,core," If unnormalizedCoordinates is VK_TRUE, minFilter and magFilter must be equal"
VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01073,Y,UnnormalizedCoordinatesEnabled,explicit,VkSamplerCreateInfo,core," If unnormalizedCoordinates is VK_TRUE, mipmapMode must be VK_SAMPLER_MIPMAP_MODE_NEAREST"
VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01074,Y,UnnormalizedCoordinatesEnabled,explicit,VkSamplerCreateInfo,core," If unnormalizedCoordinates is VK_TRUE, minLod and maxLod must be zero"
VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01075,Y,UnnormalizedCoordinatesEnabled,explicit,VkSamplerCreateInfo,core," If unnormalizedCoordinates is VK_TRUE, addressModeU and addressModeV must each be either VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE or VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"
VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01076,Y,AnisotropyFeatureEnabled,explicit,VkSamplerCreateInfo,core," If unnormalizedCoordinates is VK_TRUE, anisotropyEnable must be VK_FALSE"
VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01077,Y,UnnormalizedCoordinatesEnabled,explicit,VkSamplerCreateInfo,core," If unnormalizedCoordinates is VK_TRUE, compareEnable must be VK_FALSE"
VUID-VkSamplerReductionModeCreateInfoEXT-reductionMode-parameter,Y,None,implicit,VkSamplerReductionModeCreateInfoEXT,(VK_EXT_sampler_filter_minmax), reductionMode must be a valid VkSamplerReductionModeEXT value
VUID-VkSamplerReductionModeCreateInfoEXT-sType-sType,N,None,implicit,VkSamplerReductionModeCreateInfoEXT,(VK_EXT_sampler_filter_minmax), sType must be VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT
VUID-VkSamplerYcbcrConversionCreateInfo-None-01654,N,None,explicit,VkSamplerYcbcrConversionCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", If the format has a _422 or _420 suffix:
VUID-VkSamplerYcbcrConversionCreateInfo-chromaFilter-01657,N,None,explicit,VkSamplerYcbcrConversionCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the format does not support VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT, chromaFilter must be VK_FILTER_NEAREST"
VUID-VkSamplerYcbcrConversionCreateInfo-chromaFilter-parameter,Y,None,implicit,VkSamplerYcbcrConversionCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", chromaFilter must be a valid VkFilter value
VUID-VkSamplerYcbcrConversionCreateInfo-components-parameter,N,None,implicit,VkSamplerYcbcrConversionCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", components must be a valid VkComponentMapping structure
VUID-VkSamplerYcbcrConversionCreateInfo-forceExplicitReconstruction-01656,N,None,explicit,VkSamplerYcbcrConversionCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the format does not support VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT, forceExplicitReconstruction must be FALSE"
VUID-VkSamplerYcbcrConversionCreateInfo-format-01649,N,None,explicit,VkSamplerYcbcrConversionCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)+!(VK_ANDROID_external_memory_android_hardware_buffer)", format must not be VK_FORMAT_UNDEFINED
VUID-VkSamplerYcbcrConversionCreateInfo-format-01650,N,None,explicit,VkSamplerYcbcrConversionCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", format must support VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT or VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT
VUID-VkSamplerYcbcrConversionCreateInfo-format-01653,N,None,explicit,VkSamplerYcbcrConversionCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", format must represent unsigned normalized values (i.e. the format must be a UNORM format)
VUID-VkSamplerYcbcrConversionCreateInfo-format-01904,N,None,explicit,VkSamplerYcbcrConversionCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)+(VK_ANDROID_external_memory_android_hardware_buffer)"," If an external format conversion is being created, format must be VK_FORMAT_UNDEFINED, otherwise it must not be VK_FORMAT_UNDEFINED."
VUID-VkSamplerYcbcrConversionCreateInfo-format-parameter,Y,None,implicit,VkSamplerYcbcrConversionCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", format must be a valid VkFormat value
VUID-VkSamplerYcbcrConversionCreateInfo-pNext-pNext,Y,None,implicit,VkSamplerYcbcrConversionCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", pNext must be NULL or a pointer to a valid instance of VkExternalFormatANDROID
VUID-VkSamplerYcbcrConversionCreateInfo-sType-sType,Y,None,implicit,VkSamplerYcbcrConversionCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", sType must be VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO
VUID-VkSamplerYcbcrConversionCreateInfo-xChromaOffset-01651,N,None,explicit,VkSamplerYcbcrConversionCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the format does not support VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT, xChromaOffset and yChromaOffset must not be VK_CHROMA_LOCATION_COSITED_EVEN"
VUID-VkSamplerYcbcrConversionCreateInfo-xChromaOffset-01652,N,None,explicit,VkSamplerYcbcrConversionCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the format does not support VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT, xChromaOffset and yChromaOffset must not be VK_CHROMA_LOCATION_MIDPOINT"
VUID-VkSamplerYcbcrConversionCreateInfo-xChromaOffset-parameter,Y,None,implicit,VkSamplerYcbcrConversionCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", xChromaOffset must be a valid VkChromaLocation value
VUID-VkSamplerYcbcrConversionCreateInfo-yChromaOffset-parameter,Y,None,implicit,VkSamplerYcbcrConversionCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", yChromaOffset must be a valid VkChromaLocation value
VUID-VkSamplerYcbcrConversionCreateInfo-ycbcrModel-01655,N,None,explicit,VkSamplerYcbcrConversionCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If ycbcrModel is not VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY, then components.r, components.g, and components.b must correspond to channels of the format; that is, components.r, components.g, and components.b must not be VK_COMPONENT_SWIZZLE_ZERO or VK_COMPONENT_SWIZZLE_ONE, and must not correspond to a channel which contains zero or one as a consequence of conversion to RGBA"
VUID-VkSamplerYcbcrConversionCreateInfo-ycbcrModel-parameter,Y,None,implicit,VkSamplerYcbcrConversionCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", ycbcrModel must be a valid VkSamplerYcbcrModelConversion value
VUID-VkSamplerYcbcrConversionCreateInfo-ycbcrRange-parameter,Y,None,implicit,VkSamplerYcbcrConversionCreateInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", ycbcrRange must be a valid VkSamplerYcbcrRange value
VUID-VkSamplerYcbcrConversionImageFormatProperties-sType-sType,N,None,implicit,VkSamplerYcbcrConversionImageFormatProperties,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", sType must be VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES
VUID-VkSamplerYcbcrConversionInfo-conversion-parameter,N,None,implicit,VkSamplerYcbcrConversionInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", conversion must be a valid VkSamplerYcbcrConversion handle
VUID-VkSamplerYcbcrConversionInfo-sType-sType,N,None,implicit,VkSamplerYcbcrConversionInfo,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", sType must be VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO
VUID-VkSemaphoreCreateInfo-flags-zerobitmask,Y,None,implicit,VkSemaphoreCreateInfo,core, flags must be 0
VUID-VkSemaphoreCreateInfo-pNext-pNext,Y,None,implicit,VkSemaphoreCreateInfo,core, Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkExportSemaphoreCreateInfo or VkExportSemaphoreWin32HandleInfoKHR
VUID-VkSemaphoreCreateInfo-sType-sType,Y,None,implicit,VkSemaphoreCreateInfo,core, sType must be VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO
VUID-VkSemaphoreCreateInfo-sType-unique,N,None,implicit,VkSemaphoreCreateInfo,core, Each sType member in the pNext chain must be unique
VUID-VkSemaphoreGetFdInfoKHR-handleType-01132,N,None,explicit,VkSemaphoreGetFdInfoKHR,(VK_KHR_external_semaphore_fd), handleType must have been included in VkExportSemaphoreCreateInfo::handleTypes when semaphore's current payload was created.
VUID-VkSemaphoreGetFdInfoKHR-handleType-01134,N,None,explicit,VkSemaphoreGetFdInfoKHR,(VK_KHR_external_semaphore_fd)," If handleType refers to a handle type with copy payload transference semantics, as defined below in Importing Semaphore Payloads, there must be no queue waiting on semaphore."
VUID-VkSemaphoreGetFdInfoKHR-handleType-01135,N,None,explicit,VkSemaphoreGetFdInfoKHR,(VK_KHR_external_semaphore_fd)," If handleType refers to a handle type with copy payload transference semantics, semaphore must be signaled, or have an associated semaphore signal operation pending execution."
VUID-VkSemaphoreGetFdInfoKHR-handleType-01136,N,None,explicit,VkSemaphoreGetFdInfoKHR,(VK_KHR_external_semaphore_fd), handleType must be defined as a POSIX file descriptor handle.
VUID-VkSemaphoreGetFdInfoKHR-handleType-parameter,Y,None,implicit,VkSemaphoreGetFdInfoKHR,(VK_KHR_external_semaphore_fd), handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value
VUID-VkSemaphoreGetFdInfoKHR-pNext-pNext,Y,None,implicit,VkSemaphoreGetFdInfoKHR,(VK_KHR_external_semaphore_fd), pNext must be NULL
VUID-VkSemaphoreGetFdInfoKHR-sType-sType,Y,None,implicit,VkSemaphoreGetFdInfoKHR,(VK_KHR_external_semaphore_fd), sType must be VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR
VUID-VkSemaphoreGetFdInfoKHR-semaphore-01133,N,None,explicit,VkSemaphoreGetFdInfoKHR,(VK_KHR_external_semaphore_fd), semaphore must not currently have its payload replaced by an imported payload as described below in Importing Semaphore Payloads unless that imported payload's handle type was included in VkExternalSemaphoreProperties::exportFromImportedHandleTypes for handleType.
VUID-VkSemaphoreGetFdInfoKHR-semaphore-parameter,Y,None,implicit,VkSemaphoreGetFdInfoKHR,(VK_KHR_external_semaphore_fd), semaphore must be a valid VkSemaphore handle
VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-01126,N,None,explicit,VkSemaphoreGetWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32), handleType must have been included in VkExportSemaphoreCreateInfo::handleTypes when the semaphore's current payload was created.
VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-01127,N,None,explicit,VkSemaphoreGetWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32)," If handleType is defined as an NT handle, vkGetSemaphoreWin32HandleKHR must be called no more than once for each valid unique combination of semaphore and handleType."
VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-01129,N,None,explicit,VkSemaphoreGetWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32)," If handleType refers to a handle type with copy payload transference semantics, as defined below in Importing Semaphore Payloads, there must be no queue waiting on semaphore."
VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-01130,N,None,explicit,VkSemaphoreGetWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32)," If handleType refers to a handle type with copy payload transference semantics, semaphore must be signaled, or have an associated semaphore signal operation pending execution."
VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-01131,N,None,explicit,VkSemaphoreGetWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32), handleType must be defined as an NT handle or a global share handle.
VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-parameter,Y,None,implicit,VkSemaphoreGetWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32), handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value
VUID-VkSemaphoreGetWin32HandleInfoKHR-pNext-pNext,Y,None,implicit,VkSemaphoreGetWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32), pNext must be NULL
VUID-VkSemaphoreGetWin32HandleInfoKHR-sType-sType,Y,None,implicit,VkSemaphoreGetWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32), sType must be VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR
VUID-VkSemaphoreGetWin32HandleInfoKHR-semaphore-01128,N,None,explicit,VkSemaphoreGetWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32), semaphore must not currently have its payload replaced by an imported payload as described below in Importing Semaphore Payloads unless that imported payload's handle type was included in VkExternalSemaphoreProperties::exportFromImportedHandleTypes for handleType.
VUID-VkSemaphoreGetWin32HandleInfoKHR-semaphore-parameter,Y,None,implicit,VkSemaphoreGetWin32HandleInfoKHR,(VK_KHR_external_semaphore_win32), semaphore must be a valid VkSemaphore handle
VUID-VkShaderModuleCreateInfo-codeSize-01085,N,None,explicit,VkShaderModuleCreateInfo,core, codeSize must be greater than 0
VUID-VkShaderModuleCreateInfo-codeSize-01086,N,None,explicit,VkShaderModuleCreateInfo,!(VK_NV_glsl_shader), codeSize must be a multiple of 4
VUID-VkShaderModuleCreateInfo-flags-zerobitmask,Y,None,implicit,VkShaderModuleCreateInfo,core, flags must be 0
VUID-VkShaderModuleCreateInfo-pCode-01087,N,None,explicit,VkShaderModuleCreateInfo,!(VK_NV_glsl_shader)," pCode must point to valid SPIR-V code, formatted and packed as described by the Khronos SPIR-V Specification"
VUID-VkShaderModuleCreateInfo-pCode-01088,N,None,explicit,VkShaderModuleCreateInfo,!(VK_NV_glsl_shader), pCode must adhere to the validation rules described by the Validation Rules within a Module section of the SPIR-V Environment appendix
VUID-VkShaderModuleCreateInfo-pCode-01089,N,None,explicit,VkShaderModuleCreateInfo,core, pCode must declare the Shader capability for SPIR-V code
VUID-VkShaderModuleCreateInfo-pCode-01090,N,None,explicit,VkShaderModuleCreateInfo,core," pCode must not declare any capability that is not supported by the API, as described by the Capabilities section of the SPIR-V Environment appendix"
VUID-VkShaderModuleCreateInfo-pCode-01091,N,None,explicit,VkShaderModuleCreateInfo,core," If pCode declares any of the capabilities listed as optional in the SPIR-V Environment appendix, the corresponding feature(s) must be enabled."
VUID-VkShaderModuleCreateInfo-pCode-01376,Y,InvalidSPIRVCodeSize,explicit,VkShaderModuleCreateInfo,(VK_NV_glsl_shader)," If pCode points to SPIR-V code, codeSize must be a multiple of 4"
VUID-VkShaderModuleCreateInfo-pCode-01377,N,None,explicit,VkShaderModuleCreateInfo,(VK_NV_glsl_shader)," pCode must point to either valid SPIR-V code, formatted and packed as described by the Khronos SPIR-V Specification or valid GLSL code which must be written to the GL_KHR_vulkan_glsl extension specification"
VUID-VkShaderModuleCreateInfo-pCode-01378,N,None,explicit,VkShaderModuleCreateInfo,(VK_NV_glsl_shader)," If pCode points to SPIR-V code, that code must adhere to the validation rules described by the Validation Rules within a Module section of the SPIR-V Environment appendix"
VUID-VkShaderModuleCreateInfo-pCode-01379,N,None,explicit,VkShaderModuleCreateInfo,(VK_NV_glsl_shader)," If pCode points to GLSL code, it must be valid GLSL code written to the GL_KHR_vulkan_glsl GLSL extension specification"
VUID-VkShaderModuleCreateInfo-pCode-parameter,Y,None,implicit,VkShaderModuleCreateInfo,core, pCode must be a valid pointer to an array of (codeSize/4) uint32_t values
VUID-VkShaderModuleCreateInfo-pNext-pNext,Y,None,implicit,VkShaderModuleCreateInfo,core, pNext must be NULL or a pointer to a valid instance of VkShaderModuleValidationCacheCreateInfoEXT
VUID-VkShaderModuleCreateInfo-sType-sType,Y,None,implicit,VkShaderModuleCreateInfo,core, sType must be VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO
VUID-VkShaderModuleValidationCacheCreateInfoEXT-sType-sType,N,None,implicit,VkShaderModuleValidationCacheCreateInfoEXT,(VK_EXT_validation_cache), sType must be VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT
VUID-VkShaderModuleValidationCacheCreateInfoEXT-validationCache-parameter,N,None,implicit,VkShaderModuleValidationCacheCreateInfoEXT,(VK_EXT_validation_cache), validationCache must be a valid VkValidationCacheEXT handle
VUID-VkShadingRatePaletteNV-pShadingRatePaletteEntries-parameter,N,None,implicit,VkShadingRatePaletteNV,(VK_NV_shading_rate_image), pShadingRatePaletteEntries must be a valid pointer to an array of shadingRatePaletteEntryCount valid VkShadingRatePaletteEntryNV values
VUID-VkShadingRatePaletteNV-shadingRatePaletteEntryCount-02071,Y,ShadingRateImageNV,explicit,VkShadingRatePaletteNV,(VK_NV_shading_rate_image)," shadingRatePaletteEntryCount must be between 1 and VkPhysicalDeviceShadingRateImagePropertiesNV::shadingRatePaletteSize, inclusive"
VUID-VkShadingRatePaletteNV-shadingRatePaletteEntryCount-arraylength,N,None,implicit,VkShadingRatePaletteNV,(VK_NV_shading_rate_image), shadingRatePaletteEntryCount must be greater than 0
VUID-VkSharedPresentSurfaceCapabilitiesKHR-sType-sType,N,None,implicit,VkSharedPresentSurfaceCapabilitiesKHR,(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)+(VK_KHR_shared_presentable_image), sType must be VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR
VUID-VkSparseBufferMemoryBindInfo-bindCount-arraylength,Y,None,implicit,VkSparseBufferMemoryBindInfo,core, bindCount must be greater than 0
VUID-VkSparseBufferMemoryBindInfo-buffer-parameter,Y,None,implicit,VkSparseBufferMemoryBindInfo,core, buffer must be a valid VkBuffer handle
VUID-VkSparseBufferMemoryBindInfo-pBinds-parameter,Y,None,implicit,VkSparseBufferMemoryBindInfo,core, pBinds must be a valid pointer to an array of bindCount valid VkSparseMemoryBind structures
VUID-VkSparseImageFormatProperties2-pNext-pNext,Y,None,implicit,VkSparseImageFormatProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", pNext must be NULL
VUID-VkSparseImageFormatProperties2-sType-sType,Y,None,implicit,VkSparseImageFormatProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", sType must be VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2
VUID-VkSparseImageMemoryBind-extent-01108,N,None,explicit,VkSparseImageMemoryBind,core," extent.width must either be a multiple of the sparse image block width of the image, or else (extent.width + offset.x) must equal the width of the image subresource"
VUID-VkSparseImageMemoryBind-extent-01110,N,None,explicit,VkSparseImageMemoryBind,core," extent.height must either be a multiple of the sparse image block height of the image, or else (extent.height + offset.y) must equal the height of the image subresource"
VUID-VkSparseImageMemoryBind-extent-01112,N,None,explicit,VkSparseImageMemoryBind,core," extent.depth must either be a multiple of the sparse image block depth of the image, or else (extent.depth + offset.z) must equal the depth of the image subresource"
VUID-VkSparseImageMemoryBind-flags-parameter,Y,None,implicit,VkSparseImageMemoryBind,core, flags must be a valid combination of VkSparseMemoryBindFlagBits values
VUID-VkSparseImageMemoryBind-memory-01104,N,None,explicit,VkSparseImageMemoryBind,core," If the sparse aliased residency feature is not enabled, and if any other resources are bound to ranges of memory, the range of memory being bound must not overlap with those bound ranges"
VUID-VkSparseImageMemoryBind-memory-01105,N,None,explicit,VkSparseImageMemoryBind,core," memory and memoryOffset must match the memory requirements of the calling command's image, as described in section Resource Memory Association"
VUID-VkSparseImageMemoryBind-memory-parameter,Y,None,implicit,VkSparseImageMemoryBind,core," If memory is not VK_NULL_HANDLE, memory must be a valid VkDeviceMemory handle"
VUID-VkSparseImageMemoryBind-offset-01107,N,None,explicit,VkSparseImageMemoryBind,core, offset.x must be a multiple of the sparse image block width (VkSparseImageFormatProperties::imageGranularity.width) of the image
VUID-VkSparseImageMemoryBind-offset-01109,N,None,explicit,VkSparseImageMemoryBind,core, offset.y must be a multiple of the sparse image block height (VkSparseImageFormatProperties::imageGranularity.height) of the image
VUID-VkSparseImageMemoryBind-offset-01111,N,None,explicit,VkSparseImageMemoryBind,core, offset.z must be a multiple of the sparse image block depth (VkSparseImageFormatProperties::imageGranularity.depth) of the image
VUID-VkSparseImageMemoryBind-subresource-01106,N,None,explicit,VkSparseImageMemoryBind,core, subresource must be a valid image subresource for image (see Image Views)
VUID-VkSparseImageMemoryBind-subresource-parameter,N,None,implicit,VkSparseImageMemoryBind,core, subresource must be a valid VkImageSubresource structure
VUID-VkSparseImageMemoryBindInfo-bindCount-arraylength,Y,None,implicit,VkSparseImageMemoryBindInfo,core, bindCount must be greater than 0
VUID-VkSparseImageMemoryBindInfo-image-parameter,Y,None,implicit,VkSparseImageMemoryBindInfo,core, image must be a valid VkImage handle
VUID-VkSparseImageMemoryBindInfo-pBinds-parameter,Y,None,implicit,VkSparseImageMemoryBindInfo,core, pBinds must be a valid pointer to an array of bindCount valid VkSparseImageMemoryBind structures
VUID-VkSparseImageMemoryBindInfo-subresource-01722,N,None,explicit,VkSparseImageMemoryBindInfo,core, The subresource.mipLevel member of each element of pBinds must be less than the mipLevels specified in VkImageCreateInfo when image was created
VUID-VkSparseImageMemoryBindInfo-subresource-01723,N,None,explicit,VkSparseImageMemoryBindInfo,core, The subresource.arrayLayer member of each element of pBinds must be less than the arrayLayers specified in VkImageCreateInfo when image was created
VUID-VkSparseImageMemoryRequirements2-pNext-pNext,Y,None,implicit,VkSparseImageMemoryRequirements2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", pNext must be NULL
VUID-VkSparseImageMemoryRequirements2-sType-sType,Y,None,implicit,VkSparseImageMemoryRequirements2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", sType must be VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2
VUID-VkSparseImageOpaqueMemoryBindInfo-bindCount-arraylength,Y,None,implicit,VkSparseImageOpaqueMemoryBindInfo,core, bindCount must be greater than 0
VUID-VkSparseImageOpaqueMemoryBindInfo-image-parameter,Y,None,implicit,VkSparseImageOpaqueMemoryBindInfo,core, image must be a valid VkImage handle
VUID-VkSparseImageOpaqueMemoryBindInfo-pBinds-01103,N,None,explicit,VkSparseImageOpaqueMemoryBindInfo,core," If the flags member of any element of pBinds contains VK_SPARSE_MEMORY_BIND_METADATA_BIT, the binding range defined must be within the mip tail region of the metadata aspect of image"
VUID-VkSparseImageOpaqueMemoryBindInfo-pBinds-parameter,Y,None,implicit,VkSparseImageOpaqueMemoryBindInfo,core, pBinds must be a valid pointer to an array of bindCount valid VkSparseMemoryBind structures
VUID-VkSparseMemoryBind-flags-parameter,Y,None,implicit,VkSparseMemoryBind,core, flags must be a valid combination of VkSparseMemoryBindFlagBits values
VUID-VkSparseMemoryBind-memory-01096,N,None,explicit,VkSparseMemoryBind,core," If memory is not VK_NULL_HANDLE, memory and memoryOffset must match the memory requirements of the resource, as described in section Resource Memory Association"
VUID-VkSparseMemoryBind-memory-01097,N,None,explicit,VkSparseMemoryBind,core," If memory is not VK_NULL_HANDLE, memory must not have been created with a memory type that reports VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT bit set"
VUID-VkSparseMemoryBind-memory-parameter,Y,None,implicit,VkSparseMemoryBind,core," If memory is not VK_NULL_HANDLE, memory must be a valid VkDeviceMemory handle"
VUID-VkSparseMemoryBind-memoryOffset-01101,N,None,explicit,VkSparseMemoryBind,core, memoryOffset must be less than the size of memory
VUID-VkSparseMemoryBind-resourceOffset-01099,N,None,explicit,VkSparseMemoryBind,core, resourceOffset must be less than the size of the resource
VUID-VkSparseMemoryBind-size-01098,N,None,explicit,VkSparseMemoryBind,core, size must be greater than 0
VUID-VkSparseMemoryBind-size-01100,N,None,explicit,VkSparseMemoryBind,core, size must be less than or equal to the size of the resource minus resourceOffset
VUID-VkSparseMemoryBind-size-01102,N,None,explicit,VkSparseMemoryBind,core, size must be less than or equal to the size of memory minus memoryOffset
VUID-VkSpecializationInfo-offset-00773,N,None,explicit,VkSpecializationInfo,core, The offset member of each element of pMapEntries must be less than dataSize
VUID-VkSpecializationInfo-pData-parameter,Y,None,implicit,VkSpecializationInfo,core," If dataSize is not 0, pData must be a valid pointer to an array of dataSize bytes"
VUID-VkSpecializationInfo-pMapEntries-00774,Y,None,explicit,VkSpecializationInfo,core, The size member of each element of pMapEntries must be less than or equal to dataSize minus offset
VUID-VkSpecializationInfo-pMapEntries-parameter,Y,None,implicit,VkSpecializationInfo,core," If mapEntryCount is not 0, pMapEntries must be a valid pointer to an array of mapEntryCount valid VkSpecializationMapEntry structures"
VUID-VkSpecializationMapEntry-constantID-00776,N,None,explicit,VkSpecializationMapEntry,core," For a constantID specialization constant declared in a shader, size must match the byte size of the constantID. If the specialization constant is of type boolean, size must be the byte size of VkBool32"
VUID-VkStencilOpState-compareOp-parameter,N,None,implicit,VkStencilOpState,core, compareOp must be a valid VkCompareOp value
VUID-VkStencilOpState-depthFailOp-parameter,Y,None,implicit,VkStencilOpState,core, depthFailOp must be a valid VkStencilOp value
VUID-VkStencilOpState-failOp-parameter,Y,None,implicit,VkStencilOpState,core, failOp must be a valid VkStencilOp value
VUID-VkStencilOpState-passOp-parameter,Y,None,implicit,VkStencilOpState,core, passOp must be a valid VkStencilOp value
VUID-VkSubmitInfo-commonparent,Y,None,implicit,VkSubmitInfo,core," Each of the elements of pCommandBuffers, the elements of pSignalSemaphores, and the elements of pWaitSemaphores that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkSubmitInfo-pCommandBuffers-00075,N,None,explicit,VkSubmitInfo,core, Each element of pCommandBuffers must not have been allocated with VK_COMMAND_BUFFER_LEVEL_SECONDARY
VUID-VkSubmitInfo-pCommandBuffers-parameter,Y,None,implicit,VkSubmitInfo,core," If commandBufferCount is not 0, pCommandBuffers must be a valid pointer to an array of commandBufferCount valid VkCommandBuffer handles"
VUID-VkSubmitInfo-pNext-pNext,Y,None,implicit,VkSubmitInfo,core," Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkD3D12FenceSubmitInfoKHR, VkDeviceGroupSubmitInfo, VkProtectedSubmitInfo, VkWin32KeyedMutexAcquireReleaseInfoKHR, or VkWin32KeyedMutexAcquireReleaseInfoNV"
VUID-VkSubmitInfo-pSignalSemaphores-parameter,Y,None,implicit,VkSubmitInfo,core," If signalSemaphoreCount is not 0, pSignalSemaphores must be a valid pointer to an array of signalSemaphoreCount valid VkSemaphore handles"
VUID-VkSubmitInfo-pWaitDstStageMask-00076,Y,None,explicit,VkSubmitInfo,core," If the geometry shaders feature is not enabled, each element of pWaitDstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"
VUID-VkSubmitInfo-pWaitDstStageMask-00077,Y,None,explicit,VkSubmitInfo,core," If the tessellation shaders feature is not enabled, each element of pWaitDstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"
VUID-VkSubmitInfo-pWaitDstStageMask-00078,N,None,explicit,VkSubmitInfo,core, Each element of pWaitDstStageMask must not include VK_PIPELINE_STAGE_HOST_BIT.
VUID-VkSubmitInfo-pWaitDstStageMask-02089,Y,MeshShaderDisabledNV,explicit,VkSubmitInfo,(VK_NV_mesh_shader)," If the mesh shaders feature is not enabled, each element of pWaitDstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV"
VUID-VkSubmitInfo-pWaitDstStageMask-02090,Y,MeshShaderDisabledNV,explicit,VkSubmitInfo,(VK_NV_mesh_shader)," If the task shaders feature is not enabled, each element of pWaitDstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV"
VUID-VkSubmitInfo-pWaitDstStageMask-parameter,N,None,implicit,VkSubmitInfo,core," If waitSemaphoreCount is not 0, pWaitDstStageMask must be a valid pointer to an array of waitSemaphoreCount valid combinations of VkPipelineStageFlagBits values"
VUID-VkSubmitInfo-pWaitDstStageMask-requiredbitmask,N,None,implicit,VkSubmitInfo,core, Each element of pWaitDstStageMask must not be 0
VUID-VkSubmitInfo-pWaitSemaphores-parameter,Y,None,implicit,VkSubmitInfo,core," If waitSemaphoreCount is not 0, pWaitSemaphores must be a valid pointer to an array of waitSemaphoreCount valid VkSemaphore handles"
VUID-VkSubmitInfo-sType-sType,Y,RequiredParameter,implicit,VkSubmitInfo,core, sType must be VK_STRUCTURE_TYPE_SUBMIT_INFO
VUID-VkSubmitInfo-sType-unique,N,None,implicit,VkSubmitInfo,core, Each sType member in the pNext chain must be unique
VUID-VkSubpassBeginInfoKHR-contents-parameter,Y,None,implicit,VkSubpassBeginInfoKHR,(VK_KHR_create_renderpass2), contents must be a valid VkSubpassContents value
VUID-VkSubpassBeginInfoKHR-pNext-pNext,Y,None,implicit,VkSubpassBeginInfoKHR,(VK_KHR_create_renderpass2), pNext must be NULL
VUID-VkSubpassBeginInfoKHR-sType-sType,Y,None,implicit,VkSubpassBeginInfoKHR,(VK_KHR_create_renderpass2), sType must be VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR
VUID-VkSubpassDependency-dependencyFlags-00870,N,None,explicit,VkSubpassDependency,"(VK_VERSION_1_1,VK_KHR_multiview)"," If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT, then both srcSubpass and dstSubpass must not equal VK_SUBPASS_EXTERNAL"
VUID-VkSubpassDependency-dependencyFlags-00871,N,None,explicit,VkSubpassDependency,"(VK_VERSION_1_1,VK_KHR_multiview)"," If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT, then the render pass must have multiview enabled"
VUID-VkSubpassDependency-dependencyFlags-parameter,Y,None,implicit,VkSubpassDependency,core, dependencyFlags must be a valid combination of VkDependencyFlagBits values
VUID-VkSubpassDependency-dstAccessMask-00869,Y,None,explicit,VkSubpassDependency,core," Any access flag included in dstAccessMask must be supported by one of the pipeline stages in dstStageMask, as specified in the table of supported access types"
VUID-VkSubpassDependency-dstAccessMask-parameter,Y,None,implicit,VkSubpassDependency,core, dstAccessMask must be a valid combination of VkAccessFlagBits values
VUID-VkSubpassDependency-dstStageMask-00861,Y,None,explicit,VkSubpassDependency,core," If the geometry shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"
VUID-VkSubpassDependency-dstStageMask-00863,Y,None,explicit,VkSubpassDependency,core," If the tessellation shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"
VUID-VkSubpassDependency-dstStageMask-02101,Y,None,explicit,VkSubpassDependency,(VK_NV_mesh_shader)," If the mesh shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV"
VUID-VkSubpassDependency-dstStageMask-02102,Y,None,explicit,VkSubpassDependency,(VK_NV_mesh_shader)," If the task shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV"
VUID-VkSubpassDependency-dstStageMask-parameter,N,None,implicit,VkSubpassDependency,core, dstStageMask must be a valid combination of VkPipelineStageFlagBits values
VUID-VkSubpassDependency-dstStageMask-requiredbitmask,Y,None,implicit,VkSubpassDependency,core, dstStageMask must not be 0
VUID-VkSubpassDependency-dstSubpass-00859,N,None,explicit,VkSubpassDependency,core," If dstSubpass is not VK_SUBPASS_EXTERNAL, dstStageMask must not include VK_PIPELINE_STAGE_HOST_BIT"
VUID-VkSubpassDependency-srcAccessMask-00868,Y,None,explicit,VkSubpassDependency,core," Any access flag included in srcAccessMask must be supported by one of the pipeline stages in srcStageMask, as specified in the table of supported access types"
VUID-VkSubpassDependency-srcAccessMask-parameter,Y,None,implicit,VkSubpassDependency,core, srcAccessMask must be a valid combination of VkAccessFlagBits values
VUID-VkSubpassDependency-srcStageMask-00860,Y,None,explicit,VkSubpassDependency,core," If the geometry shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"
VUID-VkSubpassDependency-srcStageMask-00862,Y,None,explicit,VkSubpassDependency,core," If the tessellation shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"
VUID-VkSubpassDependency-srcStageMask-02099,Y,None,explicit,VkSubpassDependency,(VK_NV_mesh_shader)," If the mesh shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV"
VUID-VkSubpassDependency-srcStageMask-02100,Y,None,explicit,VkSubpassDependency,(VK_NV_mesh_shader)," If the task shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV"
VUID-VkSubpassDependency-srcStageMask-parameter,N,None,implicit,VkSubpassDependency,core, srcStageMask must be a valid combination of VkPipelineStageFlagBits values
VUID-VkSubpassDependency-srcStageMask-requiredbitmask,Y,None,implicit,VkSubpassDependency,core, srcStageMask must not be 0
VUID-VkSubpassDependency-srcSubpass-00858,N,None,explicit,VkSubpassDependency,core," If srcSubpass is not VK_SUBPASS_EXTERNAL, srcStageMask must not include VK_PIPELINE_STAGE_HOST_BIT"
VUID-VkSubpassDependency-srcSubpass-00864,N,None,explicit,VkSubpassDependency,core," srcSubpass must be less than or equal to dstSubpass, unless one of them is VK_SUBPASS_EXTERNAL, to avoid cyclic dependencies and ensure a valid execution order"
VUID-VkSubpassDependency-srcSubpass-00865,N,None,explicit,VkSubpassDependency,core, srcSubpass and dstSubpass must not both be equal to VK_SUBPASS_EXTERNAL
VUID-VkSubpassDependency-srcSubpass-00867,N,None,explicit,VkSubpassDependency,core," If srcSubpass is equal to dstSubpass and not all of the stages in srcStageMask and dstStageMask are framebuffer-space stages, the logically latest pipeline stage in srcStageMask must be logically earlier than or equal to the logically earliest pipeline stage in dstStageMask"
VUID-VkSubpassDependency-srcSubpass-00872,N,None,explicit,VkSubpassDependency,"(VK_VERSION_1_1,VK_KHR_multiview)"," If srcSubpass equals dstSubpass and that subpass has more than one bit set in the view mask, then dependencyFlags must include VK_DEPENDENCY_VIEW_LOCAL_BIT"
VUID-VkSubpassDependency-srcSubpass-01989,N,None,explicit,VkSubpassDependency,core," If srcSubpass is equal to dstSubpass, srcStageMask and dstStageMask must not set any bits that are neither VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT, nor one of the graphics pipeline stages"
VUID-VkSubpassDependency-srcSubpass-02243,N,None,explicit,VkSubpassDependency,core," If srcSubpass equals dstSubpass, and srcStageMask and dstStageMask both include a framebuffer-space stage, then dependencyFlags must include VK_DEPENDENCY_BY_REGION_BIT"
VUID-VkSubpassDependency2KHR-dependencyFlags-03090,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)," If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT, srcSubpass must not be equal to VK_SUBPASS_EXTERNAL"
VUID-VkSubpassDependency2KHR-dependencyFlags-03091,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)," If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT, dstSubpass must not be equal to VK_SUBPASS_EXTERNAL"
VUID-VkSubpassDependency2KHR-dependencyFlags-03092,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)," If dependencyFlags does not include VK_DEPENDENCY_VIEW_LOCAL_BIT, viewOffset must be 0"
VUID-VkSubpassDependency2KHR-dependencyFlags-parameter,Y,None,implicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2), dependencyFlags must be a valid combination of VkDependencyFlagBits values
VUID-VkSubpassDependency2KHR-dstAccessMask-03089,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)," Any access flag included in dstAccessMask must be supported by one of the pipeline stages in dstStageMask, as specified in the table of supported access types"
VUID-VkSubpassDependency2KHR-dstAccessMask-parameter,Y,None,implicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2), dstAccessMask must be a valid combination of VkAccessFlagBits values
VUID-VkSubpassDependency2KHR-dstStageMask-02105,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)+(VK_NV_mesh_shader)," If the mesh shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV"
VUID-VkSubpassDependency2KHR-dstStageMask-02106,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)+(VK_NV_mesh_shader)," If the task shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV"
VUID-VkSubpassDependency2KHR-dstStageMask-03081,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)," If the geometry shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"
VUID-VkSubpassDependency2KHR-dstStageMask-03083,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)," If the tessellation shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"
VUID-VkSubpassDependency2KHR-dstStageMask-parameter,N,None,implicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2), dstStageMask must be a valid combination of VkPipelineStageFlagBits values
VUID-VkSubpassDependency2KHR-dstStageMask-requiredbitmask,Y,None,implicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2), dstStageMask must not be 0
VUID-VkSubpassDependency2KHR-dstSubpass-03079,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)," If dstSubpass is not VK_SUBPASS_EXTERNAL, dstStageMask must not include VK_PIPELINE_STAGE_HOST_BIT"
VUID-VkSubpassDependency2KHR-sType-sType,Y,None,implicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2), sType must be VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR
VUID-VkSubpassDependency2KHR-srcAccessMask-03088,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)," Any access flag included in srcAccessMask must be supported by one of the pipeline stages in srcStageMask, as specified in the table of supported access types"
VUID-VkSubpassDependency2KHR-srcAccessMask-parameter,Y,None,implicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2), srcAccessMask must be a valid combination of VkAccessFlagBits values
VUID-VkSubpassDependency2KHR-srcStageMask-02103,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)+(VK_NV_mesh_shader)," If the mesh shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV"
VUID-VkSubpassDependency2KHR-srcStageMask-02104,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)+(VK_NV_mesh_shader)," If the task shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV"
VUID-VkSubpassDependency2KHR-srcStageMask-03080,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)," If the geometry shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"
VUID-VkSubpassDependency2KHR-srcStageMask-03082,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)," If the tessellation shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"
VUID-VkSubpassDependency2KHR-srcStageMask-parameter,N,None,implicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2), srcStageMask must be a valid combination of VkPipelineStageFlagBits values
VUID-VkSubpassDependency2KHR-srcStageMask-requiredbitmask,Y,None,implicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2), srcStageMask must not be 0
VUID-VkSubpassDependency2KHR-srcSubpass-02244,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)," If srcSubpass is equal to dstSubpass, srcStageMask and dstStageMask must not set any bits that are neither VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT, nor one of the graphics pipeline stages"
VUID-VkSubpassDependency2KHR-srcSubpass-02245,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)," If srcSubpass equals dstSubpass, and srcStageMask and dstStageMask both include a framebuffer-space stage, then dependencyFlags must include VK_DEPENDENCY_BY_REGION_BIT"
VUID-VkSubpassDependency2KHR-srcSubpass-03078,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)," If srcSubpass is not VK_SUBPASS_EXTERNAL, srcStageMask must not include VK_PIPELINE_STAGE_HOST_BIT"
VUID-VkSubpassDependency2KHR-srcSubpass-03084,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)," srcSubpass must be less than or equal to dstSubpass, unless one of them is VK_SUBPASS_EXTERNAL, to avoid cyclic dependencies and ensure a valid execution order"
VUID-VkSubpassDependency2KHR-srcSubpass-03085,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2), srcSubpass and dstSubpass must not both be equal to VK_SUBPASS_EXTERNAL
VUID-VkSubpassDependency2KHR-srcSubpass-03087,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)," If srcSubpass is equal to dstSubpass and not all of the stages in srcStageMask and dstStageMask are framebuffer-space stages, the logically latest pipeline stage in srcStageMask must be logically earlier than or equal to the logically earliest pipeline stage in dstStageMask"
VUID-VkSubpassDependency2KHR-viewOffset-03093,N,None,explicit,VkSubpassDependency2KHR,(VK_KHR_create_renderpass2)," If viewOffset is not 0, srcSubpass must not be equal to dstSubpass."
VUID-VkSubpassDescription-None-00852,N,None,explicit,VkSubpassDescription,core," If any input attachments are VK_ATTACHMENT_UNUSED, then any pipelines bound during the subpass must not access those input attachments from the fragment shader"
VUID-VkSubpassDescription-attachment-00853,Y,CreateRenderPassAttachments,explicit,VkSubpassDescription,core, The attachment member of each element of pPreserveAttachments must not be VK_ATTACHMENT_UNUSED
VUID-VkSubpassDescription-colorAttachmentCount-00845,Y,CreateRenderPassAttachments,explicit,VkSubpassDescription,core, colorAttachmentCount must be less than or equal to VkPhysicalDeviceLimits::maxColorAttachments
VUID-VkSubpassDescription-flags-00856,N,None,explicit,VkSubpassDescription,(VK_NVX_multiview_per_view_attributes)," If flags includes VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX, it must also include VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX."
VUID-VkSubpassDescription-flags-parameter,Y,None,implicit,VkSubpassDescription,core, flags must be a valid combination of VkSubpassDescriptionFlagBits values
VUID-VkSubpassDescription-layout-00855,Y,"RenderPassAttachmentUsedTwiceMismatchingLayout, CreateRenderPassAttachments",explicit,VkSubpassDescription,core," If any attachment is used as both an input attachment and a color or depth/stencil attachment, then each use must use the same layout"
VUID-VkSubpassDescription-loadOp-00846,Y,CreateRenderPassAttachments,explicit,VkSubpassDescription,core," If the first use of an attachment in this render pass is as an input attachment, and the attachment is not also used as a color or depth/stencil attachment in the same subpass, then loadOp must not be VK_ATTACHMENT_LOAD_OP_CLEAR"
VUID-VkSubpassDescription-pColorAttachments-01417,N,None,explicit,VkSubpassDescription,core, All attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have the same sample count
VUID-VkSubpassDescription-pColorAttachments-01506,Y,AMDMixedAttachmentSamplesValidateRenderPass,explicit,VkSubpassDescription,(VK_AMD_mixed_attachment_samples), All attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have a sample count that is smaller than or equal to the sample count of pDepthStencilAttachment if it is not VK_ATTACHMENT_UNUSED
VUID-VkSubpassDescription-pColorAttachments-parameter,Y,None,implicit,VkSubpassDescription,core," If colorAttachmentCount is not 0, pColorAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference structures"
VUID-VkSubpassDescription-pDepthStencilAttachment-01418,N,None,explicit,VkSubpassDescription,!(VK_AMD_mixed_attachment_samples)+!(VK_NV_framebuffer_mixed_samples)," If pDepthStencilAttachment is not VK_ATTACHMENT_UNUSED and any attachments in pColorAttachments are not VK_ATTACHMENT_UNUSED, they must have the same sample count"
VUID-VkSubpassDescription-pDepthStencilAttachment-parameter,N,None,implicit,VkSubpassDescription,core," If pDepthStencilAttachment is not NULL, pDepthStencilAttachment must be a valid pointer to a valid VkAttachmentReference structure"
VUID-VkSubpassDescription-pInputAttachments-parameter,Y,None,implicit,VkSubpassDescription,core," If inputAttachmentCount is not 0, pInputAttachments must be a valid pointer to an array of inputAttachmentCount valid VkAttachmentReference structures"
VUID-VkSubpassDescription-pPreserveAttachments-00854,Y,"RenderPassAttachmentUsedTwicePreserveAndColor, CreateRenderPassAttachments",explicit,VkSubpassDescription,core, Each element of pPreserveAttachments must not also be an element of any other member of the subpass description
VUID-VkSubpassDescription-pPreserveAttachments-parameter,Y,None,implicit,VkSubpassDescription,core," If preserveAttachmentCount is not 0, pPreserveAttachments must be a valid pointer to an array of preserveAttachmentCount uint32_t values"
VUID-VkSubpassDescription-pResolveAttachments-00847,Y,CreateRenderPassAttachments,explicit,VkSubpassDescription,core," If pResolveAttachments is not NULL, for each resolve attachment that does not have the value VK_ATTACHMENT_UNUSED, the corresponding color attachment must not have the value VK_ATTACHMENT_UNUSED"
VUID-VkSubpassDescription-pResolveAttachments-00848,Y,CreateRenderPassAttachments,explicit,VkSubpassDescription,core," If pResolveAttachments is not NULL, the sample count of each element of pColorAttachments must be anything other than VK_SAMPLE_COUNT_1_BIT"
VUID-VkSubpassDescription-pResolveAttachments-00849,Y,CreateRenderPassAttachments,explicit,VkSubpassDescription,core, Each element of pResolveAttachments must have a sample count of VK_SAMPLE_COUNT_1_BIT
VUID-VkSubpassDescription-pResolveAttachments-00850,Y,CreateRenderPassAttachments,explicit,VkSubpassDescription,core, Each element of pResolveAttachments must have the same VkFormat as its corresponding color attachment
VUID-VkSubpassDescription-pResolveAttachments-parameter,N,None,implicit,VkSubpassDescription,core," If colorAttachmentCount is not 0, and pResolveAttachments is not NULL, pResolveAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference structures"
VUID-VkSubpassDescription-pipelineBindPoint-00844,Y,None,explicit,VkSubpassDescription,core, pipelineBindPoint must be VK_PIPELINE_BIND_POINT_GRAPHICS
VUID-VkSubpassDescription-pipelineBindPoint-parameter,Y,None,implicit,VkSubpassDescription,core, pipelineBindPoint must be a valid VkPipelineBindPoint value
VUID-VkSubpassDescription2KHR-None-03072,N,None,explicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2)," If any input attachments are VK_ATTACHMENT_UNUSED, then any pipelines bound during the subpass must not access those input attachments from the fragment shader"
VUID-VkSubpassDescription2KHR-aspectMask-03175,N,None,explicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2), The aspectMask member of any element of pInputAttachments must be a valid combination of VkImageAspectFlagBits
VUID-VkSubpassDescription2KHR-aspectMask-03176,N,None,explicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2), The aspectMask member of any element of pInputAttachments must not be 0
VUID-VkSubpassDescription2KHR-attachment-03073,N,None,explicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2), The attachment member of any element of pPreserveAttachments must not be VK_ATTACHMENT_UNUSED
VUID-VkSubpassDescription2KHR-colorAttachmentCount-03063,N,None,explicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2), colorAttachmentCount must be less than or equal to VkPhysicalDeviceLimits::maxColorAttachments
VUID-VkSubpassDescription2KHR-flags-03076,N,None,explicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2)+(VK_NVX_multiview_per_view_attributes)," If flags includes VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX, it must also include VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX."
VUID-VkSubpassDescription2KHR-flags-parameter,Y,None,implicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2), flags must be a valid combination of VkSubpassDescriptionFlagBits values
VUID-VkSubpassDescription2KHR-layout-03075,N,None,explicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2)," If any attachment is used as both an input attachment and a color or depth/stencil attachment, then each use must use the same layout"
VUID-VkSubpassDescription2KHR-loadOp-03064,N,None,explicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2)," If the first use of an attachment in this render pass is as an input attachment, and the attachment is not also used as a color or depth/stencil attachment in the same subpass, then loadOp must not be VK_ATTACHMENT_LOAD_OP_CLEAR"
VUID-VkSubpassDescription2KHR-pColorAttachments-03069,N,None,explicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2), All attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have the same sample count
VUID-VkSubpassDescription2KHR-pColorAttachments-03070,N,None,explicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2)+(VK_AMD_mixed_attachment_samples), All attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have a sample count that is smaller than or equal to the sample count of pDepthStencilAttachment if it is not VK_ATTACHMENT_UNUSED
VUID-VkSubpassDescription2KHR-pColorAttachments-parameter,Y,None,implicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2)," If colorAttachmentCount is not 0, pColorAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference2KHR structures"
VUID-VkSubpassDescription2KHR-pDepthStencilAttachment-03071,N,None,explicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2)+!(VK_AMD_mixed_attachment_samples)+!(VK_NV_framebuffer_mixed_samples)," If pDepthStencilAttachment is not VK_ATTACHMENT_UNUSED and any attachments in pColorAttachments are not VK_ATTACHMENT_UNUSED, they must have the same sample count"
VUID-VkSubpassDescription2KHR-pDepthStencilAttachment-parameter,Y,None,implicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2)," If pDepthStencilAttachment is not NULL, pDepthStencilAttachment must be a valid pointer to a valid VkAttachmentReference2KHR structure"
VUID-VkSubpassDescription2KHR-pInputAttachments-parameter,Y,None,implicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2)," If inputAttachmentCount is not 0, pInputAttachments must be a valid pointer to an array of inputAttachmentCount valid VkAttachmentReference2KHR structures"
VUID-VkSubpassDescription2KHR-pPreserveAttachments-03074,N,None,explicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2), Any given element of pPreserveAttachments must not also be an element of any other member of the subpass description
VUID-VkSubpassDescription2KHR-pPreserveAttachments-parameter,Y,None,implicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2)," If preserveAttachmentCount is not 0, pPreserveAttachments must be a valid pointer to an array of preserveAttachmentCount uint32_t values"
VUID-VkSubpassDescription2KHR-pResolveAttachments-03065,N,None,explicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2)," If pResolveAttachments is not NULL, for each resolve attachment that does not have the value VK_ATTACHMENT_UNUSED, the corresponding color attachment must not have the value VK_ATTACHMENT_UNUSED"
VUID-VkSubpassDescription2KHR-pResolveAttachments-03066,N,None,explicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2)," If pResolveAttachments is not NULL, the sample count of each element of pColorAttachments must be anything other than VK_SAMPLE_COUNT_1_BIT"
VUID-VkSubpassDescription2KHR-pResolveAttachments-03067,N,None,explicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2), Any given element of pResolveAttachments must have a sample count of VK_SAMPLE_COUNT_1_BIT
VUID-VkSubpassDescription2KHR-pResolveAttachments-03068,N,None,explicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2), Any given element of pResolveAttachments must have the same VkFormat as its corresponding color attachment
VUID-VkSubpassDescription2KHR-pResolveAttachments-parameter,Y,None,implicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2)," If colorAttachmentCount is not 0, and pResolveAttachments is not NULL, pResolveAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference2KHR structures"
VUID-VkSubpassDescription2KHR-pipelineBindPoint-03062,N,None,explicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2), pipelineBindPoint must be VK_PIPELINE_BIND_POINT_GRAPHICS
VUID-VkSubpassDescription2KHR-pipelineBindPoint-parameter,Y,None,implicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2), pipelineBindPoint must be a valid VkPipelineBindPoint value
VUID-VkSubpassDescription2KHR-sType-sType,Y,None,implicit,VkSubpassDescription2KHR,(VK_KHR_create_renderpass2), sType must be VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR
VUID-VkSubpassEndInfoKHR-pNext-pNext,Y,None,implicit,VkSubpassEndInfoKHR,(VK_KHR_create_renderpass2), pNext must be NULL
VUID-VkSubpassEndInfoKHR-sType-sType,Y,None,implicit,VkSubpassEndInfoKHR,(VK_KHR_create_renderpass2), sType must be VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR
VUID-VkSubpassSampleLocationsEXT-sampleLocationsInfo-parameter,N,None,implicit,VkSubpassSampleLocationsEXT,(VK_EXT_sample_locations), sampleLocationsInfo must be a valid VkSampleLocationsInfoEXT structure
VUID-VkSubpassSampleLocationsEXT-subpassIndex-01532,N,None,explicit,VkSubpassSampleLocationsEXT,(VK_EXT_sample_locations), subpassIndex must be less than the subpassCount specified in VkRenderPassCreateInfo the render pass specified by VkRenderPassBeginInfo::renderPass was created with
VUID-VkSurfaceCapabilities2EXT-pNext-pNext,Y,None,implicit,VkSurfaceCapabilities2EXT,(VK_KHR_surface)+(VK_EXT_display_surface_counter), pNext must be NULL
VUID-VkSurfaceCapabilities2EXT-sType-sType,Y,None,implicit,VkSurfaceCapabilities2EXT,(VK_KHR_surface)+(VK_EXT_display_surface_counter), sType must be VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT
VUID-VkSurfaceCapabilities2EXT-supportedSurfaceCounters-01246,N,None,explicit,VkSurfaceCapabilities2EXT,(VK_KHR_surface)+(VK_EXT_display_surface_counter), supportedSurfaceCounters must not include VK_SURFACE_COUNTER_VBLANK_EXT unless the surface queried is a display surface.
VUID-VkSurfaceCapabilities2KHR-pNext-pNext,Y,None,implicit,VkSurfaceCapabilities2KHR,(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2), pNext must be NULL or a pointer to a valid instance of VkSharedPresentSurfaceCapabilitiesKHR
VUID-VkSurfaceCapabilities2KHR-sType-sType,Y,None,implicit,VkSurfaceCapabilities2KHR,(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2), sType must be VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR
VUID-VkSurfaceFormat2KHR-pNext-pNext,Y,None,implicit,VkSurfaceFormat2KHR,(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2), pNext must be NULL
VUID-VkSurfaceFormat2KHR-sType-sType,Y,None,implicit,VkSurfaceFormat2KHR,(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2), sType must be VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR
VUID-VkSwapchainCounterCreateInfoEXT-sType-sType,N,None,implicit,VkSwapchainCounterCreateInfoEXT,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_display_control), sType must be VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT
VUID-VkSwapchainCounterCreateInfoEXT-surfaceCounters-01244,N,None,explicit,VkSwapchainCounterCreateInfoEXT,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_display_control)," The bits in surfaceCounters must be supported by VkSwapchainCreateInfoKHR::surface, as reported by vkGetPhysicalDeviceSurfaceCapabilities2EXT."
VUID-VkSwapchainCounterCreateInfoEXT-surfaceCounters-parameter,Y,None,implicit,VkSwapchainCounterCreateInfoEXT,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_display_control), surfaceCounters must be a valid combination of VkSurfaceCounterFlagBitsEXT values
VUID-VkSwapchainCreateInfoKHR-commonparent,Y,None,implicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," Both of oldSwapchain, and surface that are valid handles must have been created, allocated, or retrieved from the same VkInstance"
VUID-VkSwapchainCreateInfoKHR-compositeAlpha-01280,Y,None,explicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), compositeAlpha must be one of the bits present in the supportedCompositeAlpha member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface
VUID-VkSwapchainCreateInfoKHR-compositeAlpha-parameter,Y,None,implicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), compositeAlpha must be a valid VkCompositeAlphaFlagBitsKHR value
VUID-VkSwapchainCreateInfoKHR-flags-parameter,Y,None,implicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), flags must be a valid combination of VkSwapchainCreateFlagBitsKHR values
VUID-VkSwapchainCreateInfoKHR-imageArrayLayers-01275,Y,None,explicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), imageArrayLayers must be greater than 0 and less than or equal to the maxImageArrayLayers member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface
VUID-VkSwapchainCreateInfoKHR-imageColorSpace-parameter,Y,None,implicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), imageColorSpace must be a valid VkColorSpaceKHR value
VUID-VkSwapchainCreateInfoKHR-imageExtent-01274,Y,None,explicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," imageExtent must be between minImageExtent and maxImageExtent, inclusive, where minImageExtent and maxImageExtent are members of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface"
VUID-VkSwapchainCreateInfoKHR-imageExtent-01689,Y,None,explicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), imageExtent members width and height must both be non-zero
VUID-VkSwapchainCreateInfoKHR-imageFormat-01273,Y,None,explicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," imageFormat and imageColorSpace must match the format and colorSpace members, respectively, of one of the VkSurfaceFormatKHR structures returned by vkGetPhysicalDeviceSurfaceFormatsKHR for the surface"
VUID-VkSwapchainCreateInfoKHR-imageFormat-01778,N,None,explicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," imageFormat, imageUsage, imageExtent, and imageArrayLayers must be supported for VK_IMAGE_TYPE_2D VK_IMAGE_TILING_OPTIMAL images as reported by vkGetPhysicalDeviceImageFormatProperties."
VUID-VkSwapchainCreateInfoKHR-imageFormat-parameter,Y,None,implicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), imageFormat must be a valid VkFormat value
VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01277,Y,None,explicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," If imageSharingMode is VK_SHARING_MODE_CONCURRENT, pQueueFamilyIndices must be a valid pointer to an array of queueFamilyIndexCount uint32_t values"
VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01278,Y,None,explicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," If imageSharingMode is VK_SHARING_MODE_CONCURRENT, queueFamilyIndexCount must be greater than 1"
VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01393,N,None,explicit,VkSwapchainCreateInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+!(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)"," If imageSharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the physicalDevice that was used to create device"
VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01428,N,None,explicit,VkSwapchainCreateInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)"," If imageSharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by either vkGetPhysicalDeviceQueueFamilyProperties or vkGetPhysicalDeviceQueueFamilyProperties2 for the physicalDevice that was used to create device"
VUID-VkSwapchainCreateInfoKHR-imageSharingMode-parameter,Y,None,implicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), imageSharingMode must be a valid VkSharingMode value
VUID-VkSwapchainCreateInfoKHR-imageUsage-01276,Y,None,explicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+!(VK_KHR_shared_presentable_image), imageUsage must be a subset of the supported usage flags present in the supportedUsageFlags member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface
VUID-VkSwapchainCreateInfoKHR-imageUsage-01384,N,None,explicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_shared_presentable_image)," If presentMode is VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR, imageUsage must be a subset of the supported usage flags present in the sharedPresentSupportedUsageFlags member of the VkSharedPresentSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilities2KHR for surface"
VUID-VkSwapchainCreateInfoKHR-imageUsage-parameter,N,None,implicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), imageUsage must be a valid combination of VkImageUsageFlagBits values
VUID-VkSwapchainCreateInfoKHR-imageUsage-requiredbitmask,Y,None,implicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), imageUsage must not be 0
VUID-VkSwapchainCreateInfoKHR-minImageCount-01271,Y,None,explicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), minImageCount must be greater than or equal to the value returned in the minImageCount member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface
VUID-VkSwapchainCreateInfoKHR-minImageCount-01272,Y,None,explicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), minImageCount must be less than or equal to the value returned in the maxImageCount member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface if the returned maxImageCount is not zero
VUID-VkSwapchainCreateInfoKHR-minImageCount-01383,Y,None,explicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_shared_presentable_image), minImageCount must be 1 if presentMode is either VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR
VUID-VkSwapchainCreateInfoKHR-oldSwapchain-01933,N,None,explicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," If oldSwapchain is not VK_NULL_HANDLE, oldSwapchain must be a non-retired swapchain associated with native window referred to by surface"
VUID-VkSwapchainCreateInfoKHR-oldSwapchain-parameter,Y,None,implicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," If oldSwapchain is not VK_NULL_HANDLE, oldSwapchain must be a valid VkSwapchainKHR handle"
VUID-VkSwapchainCreateInfoKHR-oldSwapchain-parent,Y,None,implicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," If oldSwapchain is a valid handle, it must have been created, allocated, or retrieved from surface"
VUID-VkSwapchainCreateInfoKHR-pNext-pNext,Y,None,implicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupSwapchainCreateInfoKHR or VkSwapchainCounterCreateInfoEXT
VUID-VkSwapchainCreateInfoKHR-physicalDeviceCount-01429,N,None,explicit,VkSwapchainCreateInfoKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)"," If the logical device was created with VkDeviceGroupDeviceCreateInfo::physicalDeviceCount equal to 1, flags must not contain VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR"
VUID-VkSwapchainCreateInfoKHR-preTransform-01279,Y,None,explicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), preTransform must be one of the bits present in the supportedTransforms member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface
VUID-VkSwapchainCreateInfoKHR-preTransform-parameter,Y,None,implicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), preTransform must be a valid VkSurfaceTransformFlagBitsKHR value
VUID-VkSwapchainCreateInfoKHR-presentMode-01281,Y,None,explicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), presentMode must be one of the VkPresentModeKHR values returned by vkGetPhysicalDeviceSurfacePresentModesKHR for the surface
VUID-VkSwapchainCreateInfoKHR-presentMode-01427,N,None,explicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_shared_presentable_image)," If presentMode is VK_PRESENT_MODE_IMMEDIATE_KHR, VK_PRESENT_MODE_MAILBOX_KHR, VK_PRESENT_MODE_FIFO_KHR or VK_PRESENT_MODE_FIFO_RELAXED_KHR, imageUsage must be a subset of the supported usage flags present in the supportedUsageFlags member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for surface"
VUID-VkSwapchainCreateInfoKHR-presentMode-parameter,Y,None,implicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), presentMode must be a valid VkPresentModeKHR value
VUID-VkSwapchainCreateInfoKHR-sType-sType,Y,None,implicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), sType must be VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR
VUID-VkSwapchainCreateInfoKHR-sType-unique,N,None,implicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), Each sType member in the pNext chain must be unique
VUID-VkSwapchainCreateInfoKHR-surface-01270,Y,None,explicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), surface must be a surface that is supported by the device as determined using vkGetPhysicalDeviceSurfaceSupportKHR
VUID-VkSwapchainCreateInfoKHR-surface-parameter,Y,None,implicit,VkSwapchainCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_swapchain), surface must be a valid VkSurfaceKHR handle
VUID-VkValidationCacheCreateInfoEXT-flags-zerobitmask,Y,None,implicit,VkValidationCacheCreateInfoEXT,(VK_EXT_validation_cache), flags must be 0
VUID-VkValidationCacheCreateInfoEXT-initialDataSize-01534,N,None,explicit,VkValidationCacheCreateInfoEXT,(VK_EXT_validation_cache)," If initialDataSize is not 0, it must be equal to the size of pInitialData, as returned by vkGetValidationCacheDataEXT when pInitialData was originally retrieved"
VUID-VkValidationCacheCreateInfoEXT-initialDataSize-01535,N,None,explicit,VkValidationCacheCreateInfoEXT,(VK_EXT_validation_cache)," If initialDataSize is not 0, pInitialData must have been retrieved from a previous call to vkGetValidationCacheDataEXT"
VUID-VkValidationCacheCreateInfoEXT-pInitialData-parameter,Y,None,implicit,VkValidationCacheCreateInfoEXT,(VK_EXT_validation_cache)," If initialDataSize is not 0, pInitialData must be a valid pointer to an array of initialDataSize bytes"
VUID-VkValidationCacheCreateInfoEXT-pNext-pNext,Y,None,implicit,VkValidationCacheCreateInfoEXT,(VK_EXT_validation_cache), pNext must be NULL
VUID-VkValidationCacheCreateInfoEXT-sType-sType,Y,None,implicit,VkValidationCacheCreateInfoEXT,(VK_EXT_validation_cache), sType must be VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT
VUID-VkValidationFlagsEXT-disabledValidationCheckCount-arraylength,N,None,implicit,VkValidationFlagsEXT,(VK_EXT_validation_flags), disabledValidationCheckCount must be greater than 0
VUID-VkValidationFlagsEXT-pDisabledValidationChecks-parameter,N,None,implicit,VkValidationFlagsEXT,(VK_EXT_validation_flags), pDisabledValidationChecks must be a valid pointer to an array of disabledValidationCheckCount valid VkValidationCheckEXT values
VUID-VkValidationFlagsEXT-sType-sType,N,None,implicit,VkValidationFlagsEXT,(VK_EXT_validation_flags), sType must be VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT
VUID-VkVertexInputAttributeDescription-binding-00621,Y,VUID_VkVertexInputAttributeDescription_binding_00621,explicit,VkVertexInputAttributeDescription,core, binding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings
VUID-VkVertexInputAttributeDescription-format-00623,Y,CreatePipelineBadVertexAttributeFormat,explicit,VkVertexInputAttributeDescription,core," format must be allowed as a vertex buffer format, as specified by the VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT flag in VkFormatProperties::bufferFeatures returned by vkGetPhysicalDeviceFormatProperties"
VUID-VkVertexInputAttributeDescription-format-parameter,N,None,implicit,VkVertexInputAttributeDescription,core, format must be a valid VkFormat value
VUID-VkVertexInputAttributeDescription-location-00620,Y,VUID_VkVertexInputAttributeDescription_location_00620,explicit,VkVertexInputAttributeDescription,core, location must be less than VkPhysicalDeviceLimits::maxVertexInputAttributes
VUID-VkVertexInputAttributeDescription-offset-00622,Y,VUID_VkVertexInputAttributeDescription_offset_00622,explicit,VkVertexInputAttributeDescription,core, offset must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputAttributeOffset
VUID-VkVertexInputBindingDescription-binding-00618,Y,VUID_VkVertexInputBindingDescription_binding_00618,explicit,VkVertexInputBindingDescription,core, binding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings
VUID-VkVertexInputBindingDescription-inputRate-parameter,N,None,implicit,VkVertexInputBindingDescription,core, inputRate must be a valid VkVertexInputRate value
VUID-VkVertexInputBindingDescription-stride-00619,Y,VUID_VkVertexInputBindingDescription_stride_00619,explicit,VkVertexInputBindingDescription,core, stride must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindingStride
VUID-VkVertexInputBindingDivisorDescriptionEXT-binding-01869,N,None,explicit,VkVertexInputBindingDivisorDescriptionEXT,(VK_EXT_vertex_attribute_divisor), binding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings
VUID-VkVertexInputBindingDivisorDescriptionEXT-divisor-01870,N,None,explicit,VkVertexInputBindingDivisorDescriptionEXT,(VK_EXT_vertex_attribute_divisor)," divisor must be a value between 0 and VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::maxVertexAttribDivisor, inclusive."
VUID-VkVertexInputBindingDivisorDescriptionEXT-inputRate-01871,N,None,explicit,VkVertexInputBindingDivisorDescriptionEXT,(VK_EXT_vertex_attribute_divisor), VkVertexInputBindingDescription::inputRate must be of type VK_VERTEX_INPUT_RATE_INSTANCE for this binding.
VUID-VkVertexInputBindingDivisorDescriptionEXT-vertexAttributeInstanceRateDivisor-02229,N,None,explicit,VkVertexInputBindingDivisorDescriptionEXT,(VK_EXT_vertex_attribute_divisor)," If the vertexAttributeInstanceRateDivisor feature is not enabled, divisor must be 1"
VUID-VkVertexInputBindingDivisorDescriptionEXT-vertexAttributeInstanceRateZeroDivisor-02228,N,None,explicit,VkVertexInputBindingDivisorDescriptionEXT,(VK_EXT_vertex_attribute_divisor)," If the vertexAttributeInstanceRateZeroDivisor feature is not enabled, divisor must not be 0"
VUID-VkViSurfaceCreateInfoNN-flags-zerobitmask,Y,None,implicit,VkViSurfaceCreateInfoNN,(VK_KHR_surface)+(VK_NN_vi_surface), flags must be 0
VUID-VkViSurfaceCreateInfoNN-pNext-pNext,Y,None,implicit,VkViSurfaceCreateInfoNN,(VK_KHR_surface)+(VK_NN_vi_surface), pNext must be NULL
VUID-VkViSurfaceCreateInfoNN-sType-sType,Y,None,implicit,VkViSurfaceCreateInfoNN,(VK_KHR_surface)+(VK_NN_vi_surface), sType must be VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN
VUID-VkViSurfaceCreateInfoNN-window-01318,N,None,explicit,VkViSurfaceCreateInfoNN,(VK_KHR_surface)+(VK_NN_vi_surface), window must be a valid nn::vi::NativeWindowHandle
VUID-VkViewport-height-01772,Y,SetDynViewportParamTests,explicit,VkViewport,"!(VK_VERSION_1_1,VK_KHR_maintenance1,VK_AMD_negative_viewport_height)", height must be greater than 0.0
VUID-VkViewport-height-01773,Y,SetDynViewportParamTests,explicit,VkViewport,core, The absolute value of height must be less than or equal to VkPhysicalDeviceLimits::maxViewportDimensions[1]
VUID-VkViewport-maxDepth-01235,Y,SetDynViewportParamTests,explicit,VkViewport,(VK_EXT_depth_range_unrestricted)," Unless VK_EXT_depth_range_unrestricted extension is enabled maxDepth must be between 0.0 and 1.0, inclusive"
VUID-VkViewport-maxDepth-01235,Y,SetDynViewportParamTests,explicit,VkViewport,!(VK_EXT_depth_range_unrestricted)," maxDepth must be between 0.0 and 1.0, inclusive"
VUID-VkViewport-minDepth-01234,Y,SetDynViewportParamTests,explicit,VkViewport,(VK_EXT_depth_range_unrestricted)," Unless VK_EXT_depth_range_unrestricted extension is enabled minDepth must be between 0.0 and 1.0, inclusive"
VUID-VkViewport-minDepth-01234,Y,SetDynViewportParamTests,explicit,VkViewport,!(VK_EXT_depth_range_unrestricted)," minDepth must be between 0.0 and 1.0, inclusive"
VUID-VkViewport-width-01770,Y,SetDynViewportParamTests,explicit,VkViewport,core, width must be greater than 0.0
VUID-VkViewport-width-01771,Y,SetDynViewportParamTests,explicit,VkViewport,core, width must be less than or equal to VkPhysicalDeviceLimits::maxViewportDimensions[0]
VUID-VkViewport-x-01232,Y,SetDynViewportParamTests,explicit,VkViewport,core, (x + width) must be less than or equal to viewportBoundsRange[1]
VUID-VkViewport-x-01774,Y,SetDynViewportParamTests,explicit,VkViewport,core, x must be greater than or equal to viewportBoundsRange[0]
VUID-VkViewport-y-01233,Y,SetDynViewportParamTests,explicit,VkViewport,core, (y + height) must be less than or equal to viewportBoundsRange[1]
VUID-VkViewport-y-01775,Y,SetDynViewportParamTests,explicit,VkViewport,core, y must be greater than or equal to viewportBoundsRange[0]
VUID-VkViewport-y-01776,Y,SetDynViewportParamTests,explicit,VkViewport,"(VK_VERSION_1_1,VK_KHR_maintenance1,VK_AMD_negative_viewport_height)", y must be less than or equal to viewportBoundsRange[1]
VUID-VkViewport-y-01777,Y,SetDynViewportParamTests,explicit,VkViewport,"(VK_VERSION_1_1,VK_KHR_maintenance1,VK_AMD_negative_viewport_height)", (y + height) must be greater than or equal to viewportBoundsRange[0]
VUID-VkViewportSwizzleNV-w-parameter,N,None,implicit,VkViewportSwizzleNV,(VK_NV_viewport_swizzle), w must be a valid VkViewportCoordinateSwizzleNV value
VUID-VkViewportSwizzleNV-x-parameter,N,None,implicit,VkViewportSwizzleNV,(VK_NV_viewport_swizzle), x must be a valid VkViewportCoordinateSwizzleNV value
VUID-VkViewportSwizzleNV-y-parameter,N,None,implicit,VkViewportSwizzleNV,(VK_NV_viewport_swizzle), y must be a valid VkViewportCoordinateSwizzleNV value
VUID-VkViewportSwizzleNV-z-parameter,N,None,implicit,VkViewportSwizzleNV,(VK_NV_viewport_swizzle), z must be a valid VkViewportCoordinateSwizzleNV value
VUID-VkWaylandSurfaceCreateInfoKHR-display-01304,N,None,explicit,VkWaylandSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_wayland_surface), display must point to a valid Wayland wl_display.
VUID-VkWaylandSurfaceCreateInfoKHR-flags-zerobitmask,Y,None,implicit,VkWaylandSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_wayland_surface), flags must be 0
VUID-VkWaylandSurfaceCreateInfoKHR-pNext-pNext,Y,None,implicit,VkWaylandSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_wayland_surface), pNext must be NULL
VUID-VkWaylandSurfaceCreateInfoKHR-sType-sType,Y,None,implicit,VkWaylandSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_wayland_surface), sType must be VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR
VUID-VkWaylandSurfaceCreateInfoKHR-surface-01305,N,None,explicit,VkWaylandSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_wayland_surface), surface must point to a valid Wayland wl_surface.
VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-commonparent,N,None,implicit,VkWin32KeyedMutexAcquireReleaseInfoKHR,(VK_KHR_win32_keyed_mutex)," Both of the elements of pAcquireSyncs, and the elements of pReleaseSyncs that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireKeys-parameter,Y,None,implicit,VkWin32KeyedMutexAcquireReleaseInfoKHR,(VK_KHR_win32_keyed_mutex)," If acquireCount is not 0, pAcquireKeys must be a valid pointer to an array of acquireCount uint64_t values"
VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireSyncs-00081,N,None,explicit,VkWin32KeyedMutexAcquireReleaseInfoKHR,(VK_KHR_win32_keyed_mutex), Each member of pAcquireSyncs and pReleaseSyncs must be a device memory object imported by setting VkImportMemoryWin32HandleInfoKHR::handleType to VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT.
VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireSyncs-parameter,Y,None,implicit,VkWin32KeyedMutexAcquireReleaseInfoKHR,(VK_KHR_win32_keyed_mutex)," If acquireCount is not 0, pAcquireSyncs must be a valid pointer to an array of acquireCount valid VkDeviceMemory handles"
VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireTimeouts-parameter,Y,None,implicit,VkWin32KeyedMutexAcquireReleaseInfoKHR,(VK_KHR_win32_keyed_mutex)," If acquireCount is not 0, pAcquireTimeouts must be a valid pointer to an array of acquireCount uint32_t values"
VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pReleaseKeys-parameter,Y,None,implicit,VkWin32KeyedMutexAcquireReleaseInfoKHR,(VK_KHR_win32_keyed_mutex)," If releaseCount is not 0, pReleaseKeys must be a valid pointer to an array of releaseCount uint64_t values"
VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pReleaseSyncs-parameter,Y,None,implicit,VkWin32KeyedMutexAcquireReleaseInfoKHR,(VK_KHR_win32_keyed_mutex)," If releaseCount is not 0, pReleaseSyncs must be a valid pointer to an array of releaseCount valid VkDeviceMemory handles"
VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-sType-sType,N,None,implicit,VkWin32KeyedMutexAcquireReleaseInfoKHR,(VK_KHR_win32_keyed_mutex), sType must be VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR
VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-commonparent,N,None,implicit,VkWin32KeyedMutexAcquireReleaseInfoNV,(VK_NV_win32_keyed_mutex)," Both of the elements of pAcquireSyncs, and the elements of pReleaseSyncs that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pAcquireKeys-parameter,Y,None,implicit,VkWin32KeyedMutexAcquireReleaseInfoNV,(VK_NV_win32_keyed_mutex)," If acquireCount is not 0, pAcquireKeys must be a valid pointer to an array of acquireCount uint64_t values"
VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pAcquireSyncs-parameter,Y,None,implicit,VkWin32KeyedMutexAcquireReleaseInfoNV,(VK_NV_win32_keyed_mutex)," If acquireCount is not 0, pAcquireSyncs must be a valid pointer to an array of acquireCount valid VkDeviceMemory handles"
VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pAcquireTimeoutMilliseconds-parameter,Y,None,implicit,VkWin32KeyedMutexAcquireReleaseInfoNV,(VK_NV_win32_keyed_mutex)," If acquireCount is not 0, pAcquireTimeoutMilliseconds must be a valid pointer to an array of acquireCount uint32_t values"
VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pReleaseKeys-parameter,Y,None,implicit,VkWin32KeyedMutexAcquireReleaseInfoNV,(VK_NV_win32_keyed_mutex)," If releaseCount is not 0, pReleaseKeys must be a valid pointer to an array of releaseCount uint64_t values"
VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pReleaseSyncs-parameter,Y,None,implicit,VkWin32KeyedMutexAcquireReleaseInfoNV,(VK_NV_win32_keyed_mutex)," If releaseCount is not 0, pReleaseSyncs must be a valid pointer to an array of releaseCount valid VkDeviceMemory handles"
VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-sType-sType,N,None,implicit,VkWin32KeyedMutexAcquireReleaseInfoNV,(VK_NV_win32_keyed_mutex), sType must be VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV
VUID-VkWin32SurfaceCreateInfoKHR-flags-zerobitmask,Y,None,implicit,VkWin32SurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_win32_surface), flags must be 0
VUID-VkWin32SurfaceCreateInfoKHR-hinstance-01307,N,None,explicit,VkWin32SurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_win32_surface), hinstance must be a valid Win32 HINSTANCE.
VUID-VkWin32SurfaceCreateInfoKHR-hwnd-01308,Y,None,explicit,VkWin32SurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_win32_surface), hwnd must be a valid Win32 HWND.
VUID-VkWin32SurfaceCreateInfoKHR-pNext-pNext,Y,None,implicit,VkWin32SurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_win32_surface), pNext must be NULL
VUID-VkWin32SurfaceCreateInfoKHR-sType-sType,Y,None,implicit,VkWin32SurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_win32_surface), sType must be VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR
VUID-VkWriteDescriptorSet-commonparent,Y,None,implicit,VkWriteDescriptorSet,core," Both of dstSet, and the elements of pTexelBufferView that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-VkWriteDescriptorSet-descriptorCount-00317,N,None,explicit,VkWriteDescriptorSet,core," All consecutive bindings updated via a single VkWriteDescriptorSet structure, except those with a descriptorCount of zero, must have identical descriptorType and stageFlags."
VUID-VkWriteDescriptorSet-descriptorCount-00318,N,None,explicit,VkWriteDescriptorSet,core," All consecutive bindings updated via a single VkWriteDescriptorSet structure, except those with a descriptorCount of zero, must all either use immutable samplers or must all not use immutable samplers."
VUID-VkWriteDescriptorSet-descriptorCount-03048,N,None,explicit,VkWriteDescriptorSet,(VK_EXT_descriptor_indexing)," All consecutive bindings updated via a single VkWriteDescriptorSet structure, except those with a descriptorCount of zero, must have identical VkDescriptorBindingFlagBitsEXT."
VUID-VkWriteDescriptorSet-descriptorCount-arraylength,Y,None,implicit,VkWriteDescriptorSet,core, descriptorCount must be greater than 0
VUID-VkWriteDescriptorSet-descriptorType-00319,Y,None,explicit,VkWriteDescriptorSet,core, descriptorType must match the type of dstBinding within dstSet
VUID-VkWriteDescriptorSet-descriptorType-00322,Y,None,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, pImageInfo must be a valid pointer to an array of descriptorCount valid VkDescriptorImageInfo structures"
VUID-VkWriteDescriptorSet-descriptorType-00323,Y,InvalidBufferViewObject,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, pTexelBufferView must be a valid pointer to an array of descriptorCount valid VkBufferView handles"
VUID-VkWriteDescriptorSet-descriptorType-00324,Y,WriteDescriptorSetIntegrityCheck,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, pBufferInfo must be a valid pointer to an array of descriptorCount valid VkDescriptorBufferInfo structures"
VUID-VkWriteDescriptorSet-descriptorType-00325,Y,SampleDescriptorUpdateError,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and dstSet was not allocated with a layout that included immutable samplers for dstBinding with descriptorType, the sampler member of each element of pImageInfo must be a valid VkSampler object"
VUID-VkWriteDescriptorSet-descriptorType-00326,Y,"DSUsageBitsErrors, ImageViewDescriptorUpdateError",explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the imageView and imageLayout members of each element of pImageInfo must be a valid VkImageView and VkImageLayout, respectively"
VUID-VkWriteDescriptorSet-descriptorType-00327,Y,DSBufferLimitErrors,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the offset member of each element of pBufferInfo must be a multiple of VkPhysicalDeviceLimits::minUniformBufferOffsetAlignment"
VUID-VkWriteDescriptorSet-descriptorType-00328,Y,DSBufferLimitErrors,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the offset member of each element of pBufferInfo must be a multiple of VkPhysicalDeviceLimits::minStorageBufferOffsetAlignment"
VUID-VkWriteDescriptorSet-descriptorType-00329,Y,None,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, and the buffer member of any element of pBufferInfo is the handle of a non-sparse buffer, then that buffer must be bound completely and contiguously to a single VkDeviceMemory object"
VUID-VkWriteDescriptorSet-descriptorType-00330,Y,DSUsageBitsErrors,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the buffer member of each element of pBufferInfo must have been created with VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT set"
VUID-VkWriteDescriptorSet-descriptorType-00331,Y,DSUsageBitsErrors,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the buffer member of each element of pBufferInfo must have been created with VK_BUFFER_USAGE_STORAGE_BUFFER_BIT set"
VUID-VkWriteDescriptorSet-descriptorType-00332,Y,DSBufferLimitErrors,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the range member of each element of pBufferInfo, or the effective range if range is VK_WHOLE_SIZE, must be less than or equal to VkPhysicalDeviceLimits::maxUniformBufferRange"
VUID-VkWriteDescriptorSet-descriptorType-00333,Y,DSBufferLimitErrors,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the range member of each element of pBufferInfo, or the effective range if range is VK_WHOLE_SIZE, must be less than or equal to VkPhysicalDeviceLimits::maxStorageBufferRange"
VUID-VkWriteDescriptorSet-descriptorType-00334,Y,DSUsageBitsErrors,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, the VkBuffer that each element of pTexelBufferView was created from must have been created with VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT set"
VUID-VkWriteDescriptorSet-descriptorType-00335,Y,DSUsageBitsErrors,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, the VkBuffer that each element of pTexelBufferView was created from must have been created with VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set"
VUID-VkWriteDescriptorSet-descriptorType-00336,N,None,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the imageView member of each element of pImageInfo must have been created with the identity swizzle"
VUID-VkWriteDescriptorSet-descriptorType-00337,N,None,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the imageView member of each element of pImageInfo must have been created with VK_IMAGE_USAGE_SAMPLED_BIT set"
VUID-VkWriteDescriptorSet-descriptorType-00338,N,None,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the imageView member of each element of pImageInfo must have been created with VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT set"
VUID-VkWriteDescriptorSet-descriptorType-00339,N,None,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, the imageView member of each element of pImageInfo must have been created with VK_IMAGE_USAGE_STORAGE_BIT set"
VUID-VkWriteDescriptorSet-descriptorType-01402,N,None,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, for each descriptor that will be accessed via load or store operations the imageLayout member for corresponding elements of pImageInfo must be VK_IMAGE_LAYOUT_GENERAL"
VUID-VkWriteDescriptorSet-descriptorType-01403,N,None,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the imageLayout member of each element of pImageInfo must be VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL"
VUID-VkWriteDescriptorSet-descriptorType-01946,N,None,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, then the imageView member of each pImageInfo element must have been created without a VkSamplerYcbcrConversionInfo structure in its pNext chain"
VUID-VkWriteDescriptorSet-descriptorType-01947,N,None,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and if any element of pImageInfo has a imageView member that was created with a VkSamplerYcbcrConversionInfo structure in its pNext chain, then dstSet must have been allocated with a layout that included immutable samplers for dstBinding"
VUID-VkWriteDescriptorSet-descriptorType-01948,N,None,explicit,VkWriteDescriptorSet,core," If descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and dstSet was allocated with a layout that included immutable samplers for dstBinding, then the imageView member of each element of pImageInfo which corresponds to an immutable sampler that enables sampler Y'CBCR conversion must have been created with a VkSamplerYcbcrConversionInfo structure in its pNext chain with an identically defined VkSamplerYcbcrConversionInfo to the corresponding immutable sampler"
VUID-VkWriteDescriptorSet-descriptorType-02219,Y,InlineUniformBlockEXT,explicit,VkWriteDescriptorSet,(VK_EXT_inline_uniform_block)," If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, dstArrayElement must be an integer multiple of 4"
VUID-VkWriteDescriptorSet-descriptorType-02220,Y,InlineUniformBlockEXT,explicit,VkWriteDescriptorSet,(VK_EXT_inline_uniform_block)," If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, descriptorCount must be an integer multiple of 4"
VUID-VkWriteDescriptorSet-descriptorType-02221,Y,InlineUniformBlockEXT,explicit,VkWriteDescriptorSet,(VK_EXT_inline_uniform_block)," If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, the pNext chain must include a VkWriteDescriptorSetInlineUniformBlockEXT structure whose dataSize member equals descriptorCount"
VUID-VkWriteDescriptorSet-descriptorType-parameter,Y,None,implicit,VkWriteDescriptorSet,core, descriptorType must be a valid VkDescriptorType value
VUID-VkWriteDescriptorSet-dstArrayElement-00321,Y,"WriteDescriptorSetIntegrityCheck, DSUpdateOutOfBounds",explicit,VkWriteDescriptorSet,core," The sum of dstArrayElement and descriptorCount must be less than or equal to the number of array elements in the descriptor set binding specified by dstBinding, and all applicable consecutive bindings, as described by consecutive binding updates"
VUID-VkWriteDescriptorSet-dstBinding-00315,Y,InvalidDSUpdateIndex,explicit,VkWriteDescriptorSet,core, dstBinding must be less than or equal to the maximum value of binding of all VkDescriptorSetLayoutBinding structures specified when dstSet's descriptor set layout was created
VUID-VkWriteDescriptorSet-dstBinding-00316,Y,DSUpdateEmptyBinding,explicit,VkWriteDescriptorSet,core, dstBinding must be a binding with a non-zero descriptorCount
VUID-VkWriteDescriptorSet-dstSet-00320,Y,UpdateDestroyDescriptorSetLayout,explicit,VkWriteDescriptorSet,core, dstSet must be a valid VkDescriptorSet handle
VUID-VkWriteDescriptorSet-pNext-pNext,Y,None,implicit,VkWriteDescriptorSet,core, Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDescriptorAccelerationStructureInfoNVX or VkWriteDescriptorSetInlineUniformBlockEXT
VUID-VkWriteDescriptorSet-sType-sType,Y,None,implicit,VkWriteDescriptorSet,core, sType must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET
VUID-VkWriteDescriptorSet-sType-unique,N,None,implicit,VkWriteDescriptorSet,core, Each sType member in the pNext chain must be unique
VUID-VkWriteDescriptorSetInlineUniformBlockEXT-dataSize-02222,Y,None,explicit,VkWriteDescriptorSetInlineUniformBlockEXT,(VK_EXT_inline_uniform_block), dataSize must be an integer multiple of 4
VUID-VkWriteDescriptorSetInlineUniformBlockEXT-dataSize-arraylength,Y,None,implicit,VkWriteDescriptorSetInlineUniformBlockEXT,(VK_EXT_inline_uniform_block), dataSize must be greater than 0
VUID-VkWriteDescriptorSetInlineUniformBlockEXT-pData-parameter,Y,None,implicit,VkWriteDescriptorSetInlineUniformBlockEXT,(VK_EXT_inline_uniform_block), pData must be a valid pointer to an array of dataSize bytes
VUID-VkWriteDescriptorSetInlineUniformBlockEXT-sType-sType,N,None,implicit,VkWriteDescriptorSetInlineUniformBlockEXT,(VK_EXT_inline_uniform_block), sType must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT
VUID-VkXcbSurfaceCreateInfoKHR-connection-01310,N,None,explicit,VkXcbSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_xcb_surface), connection must point to a valid X11 xcb_connection_t.
VUID-VkXcbSurfaceCreateInfoKHR-flags-zerobitmask,Y,None,implicit,VkXcbSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_xcb_surface), flags must be 0
VUID-VkXcbSurfaceCreateInfoKHR-pNext-pNext,Y,None,implicit,VkXcbSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_xcb_surface), pNext must be NULL
VUID-VkXcbSurfaceCreateInfoKHR-sType-sType,Y,None,implicit,VkXcbSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_xcb_surface), sType must be VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR
VUID-VkXcbSurfaceCreateInfoKHR-window-01311,N,None,explicit,VkXcbSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_xcb_surface), window must be a valid X11 xcb_window_t.
VUID-VkXlibSurfaceCreateInfoKHR-dpy-01313,N,None,explicit,VkXlibSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_xlib_surface), dpy must point to a valid Xlib Display.
VUID-VkXlibSurfaceCreateInfoKHR-flags-zerobitmask,Y,None,implicit,VkXlibSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_xlib_surface), flags must be 0
VUID-VkXlibSurfaceCreateInfoKHR-pNext-pNext,Y,None,implicit,VkXlibSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_xlib_surface), pNext must be NULL
VUID-VkXlibSurfaceCreateInfoKHR-sType-sType,Y,None,implicit,VkXlibSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_xlib_surface), sType must be VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR
VUID-VkXlibSurfaceCreateInfoKHR-window-01314,N,None,explicit,VkXlibSurfaceCreateInfoKHR,(VK_KHR_surface)+(VK_KHR_xlib_surface), window must be a valid Xlib Window.
VUID-vkAcquireNextImage2KHR-device-parameter,Y,None,implicit,vkAcquireNextImage2KHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", device must be a valid VkDevice handle
VUID-vkAcquireNextImage2KHR-pAcquireInfo-parameter,Y,None,implicit,vkAcquireNextImage2KHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", pAcquireInfo must be a valid pointer to a valid VkAcquireNextImageInfoKHR structure
VUID-vkAcquireNextImage2KHR-pImageIndex-parameter,Y,None,implicit,vkAcquireNextImage2KHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", pImageIndex must be a valid pointer to a uint32_t value
VUID-vkAcquireNextImage2KHR-swapchain-01803,N,None,explicit,vkAcquireNextImage2KHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)"," If the number of currently acquired images is greater than the difference between the number of images in the swapchain member of pAcquireInfo and the value of VkSurfaceCapabilitiesKHR::minImageCount as returned by a call to vkGetPhysicalDeviceSurfaceCapabilities2KHR with the surface used to create swapchain, the timeout member of pAcquireInfo must not be UINT64_MAX"
VUID-vkAcquireNextImageKHR-commonparent,Y,None,implicit,vkAcquireNextImageKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," Both of device, and swapchain that are valid handles must have been created, allocated, or retrieved from the same VkInstance"
VUID-vkAcquireNextImageKHR-device-parameter,Y,None,implicit,vkAcquireNextImageKHR,(VK_KHR_surface)+(VK_KHR_swapchain), device must be a valid VkDevice handle
VUID-vkAcquireNextImageKHR-fence-01287,N,None,explicit,vkAcquireNextImageKHR,(VK_KHR_surface)+(VK_KHR_swapchain), If fence is not VK_NULL_HANDLE it must be unsignaled and must not be associated with any other queue command that has not yet completed execution on that queue
VUID-vkAcquireNextImageKHR-fence-parameter,Y,None,implicit,vkAcquireNextImageKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle"
VUID-vkAcquireNextImageKHR-fence-parent,Y,None,implicit,vkAcquireNextImageKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," If fence is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkAcquireNextImageKHR-pImageIndex-parameter,Y,None,implicit,vkAcquireNextImageKHR,(VK_KHR_surface)+(VK_KHR_swapchain), pImageIndex must be a valid pointer to a uint32_t value
VUID-vkAcquireNextImageKHR-semaphore-01286,Y,None,explicit,vkAcquireNextImageKHR,(VK_KHR_surface)+(VK_KHR_swapchain), If semaphore is not VK_NULL_HANDLE it must be unsignaled
VUID-vkAcquireNextImageKHR-semaphore-01779,N,None,explicit,vkAcquireNextImageKHR,(VK_KHR_surface)+(VK_KHR_swapchain), If semaphore is not VK_NULL_HANDLE it must not have any uncompleted signal or wait operations pending
VUID-vkAcquireNextImageKHR-semaphore-01780,Y,None,explicit,vkAcquireNextImageKHR,(VK_KHR_surface)+(VK_KHR_swapchain), semaphore and fence must not both be equal to VK_NULL_HANDLE
VUID-vkAcquireNextImageKHR-semaphore-parameter,Y,None,implicit,vkAcquireNextImageKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," If semaphore is not VK_NULL_HANDLE, semaphore must be a valid VkSemaphore handle"
VUID-vkAcquireNextImageKHR-semaphore-parent,Y,None,implicit,vkAcquireNextImageKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," If semaphore is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkAcquireNextImageKHR-swapchain-01285,Y,None,explicit,vkAcquireNextImageKHR,(VK_KHR_surface)+(VK_KHR_swapchain), swapchain must not be in the retired state
VUID-vkAcquireNextImageKHR-swapchain-01802,N,None,explicit,vkAcquireNextImageKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," If the number of currently acquired images is greater than the difference between the number of images in swapchain and the value of VkSurfaceCapabilitiesKHR::minImageCount as returned by a call to vkGetPhysicalDeviceSurfaceCapabilities2KHR with the surface used to create swapchain, timeout must not be UINT64_MAX"
VUID-vkAcquireNextImageKHR-swapchain-parameter,Y,None,implicit,vkAcquireNextImageKHR,(VK_KHR_surface)+(VK_KHR_swapchain), swapchain must be a valid VkSwapchainKHR handle
VUID-vkAcquireXlibDisplayEXT-display-parameter,Y,None,implicit,vkAcquireXlibDisplayEXT,(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_direct_mode_display)+(VK_EXT_acquire_xlib_display), display must be a valid VkDisplayKHR handle
VUID-vkAcquireXlibDisplayEXT-dpy-parameter,Y,None,implicit,vkAcquireXlibDisplayEXT,(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_direct_mode_display)+(VK_EXT_acquire_xlib_display), dpy must be a valid pointer to a Display value
VUID-vkAcquireXlibDisplayEXT-physicalDevice-parameter,Y,None,implicit,vkAcquireXlibDisplayEXT,(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_direct_mode_display)+(VK_EXT_acquire_xlib_display), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkAllocateCommandBuffers-device-parameter,Y,None,implicit,vkAllocateCommandBuffers,core, device must be a valid VkDevice handle
VUID-vkAllocateCommandBuffers-pAllocateInfo-parameter,Y,None,implicit,vkAllocateCommandBuffers,core, pAllocateInfo must be a valid pointer to a valid VkCommandBufferAllocateInfo structure
VUID-vkAllocateCommandBuffers-pCommandBuffers-parameter,Y,None,implicit,vkAllocateCommandBuffers,core, pCommandBuffers must be a valid pointer to an array of pAllocateInfo::commandBufferCount VkCommandBuffer handles
VUID-vkAllocateDescriptorSets-device-parameter,Y,None,implicit,vkAllocateDescriptorSets,core, device must be a valid VkDevice handle
VUID-vkAllocateDescriptorSets-pAllocateInfo-parameter,Y,None,implicit,vkAllocateDescriptorSets,core, pAllocateInfo must be a valid pointer to a valid VkDescriptorSetAllocateInfo structure
VUID-vkAllocateDescriptorSets-pDescriptorSets-parameter,Y,None,implicit,vkAllocateDescriptorSets,core, pDescriptorSets must be a valid pointer to an array of pAllocateInfo::descriptorSetCount VkDescriptorSet handles
VUID-vkAllocateMemory-device-parameter,Y,None,implicit,vkAllocateMemory,core, device must be a valid VkDevice handle
VUID-vkAllocateMemory-pAllocateInfo-01713,N,None,explicit,vkAllocateMemory,core, pAllocateInfo->allocationSize must be less than or equal to VkPhysicalDeviceMemoryProperties::memoryHeaps[pAllocateInfo->memoryTypeIndex].size as returned by vkGetPhysicalDeviceMemoryProperties for the VkPhysicalDevice that device was created from.
VUID-vkAllocateMemory-pAllocateInfo-01714,N,None,explicit,vkAllocateMemory,core, pAllocateInfo->memoryTypeIndex must be less than VkPhysicalDeviceMemoryProperties::memoryTypeCount as returned by vkGetPhysicalDeviceMemoryProperties for the VkPhysicalDevice that device was created from.
VUID-vkAllocateMemory-pAllocateInfo-parameter,Y,None,implicit,vkAllocateMemory,core, pAllocateInfo must be a valid pointer to a valid VkMemoryAllocateInfo structure
VUID-vkAllocateMemory-pAllocator-parameter,N,None,implicit,vkAllocateMemory,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkAllocateMemory-pMemory-parameter,Y,None,implicit,vkAllocateMemory,core, pMemory must be a valid pointer to a VkDeviceMemory handle
VUID-vkBeginCommandBuffer-commandBuffer-00049,Y,None,explicit,vkBeginCommandBuffer,core, commandBuffer must not be in the recording or pending state.
VUID-vkBeginCommandBuffer-commandBuffer-00050,Y,CommandBufferResetErrors,explicit,vkBeginCommandBuffer,core," If commandBuffer was allocated from a VkCommandPool which did not have the VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT flag set, commandBuffer must be in the initial state."
VUID-vkBeginCommandBuffer-commandBuffer-00051,Y,None,explicit,vkBeginCommandBuffer,core," If commandBuffer is a secondary command buffer, the pInheritanceInfo member of pBeginInfo must be a valid VkCommandBufferInheritanceInfo structure"
VUID-vkBeginCommandBuffer-commandBuffer-00052,Y,None,explicit,vkBeginCommandBuffer,core," If commandBuffer is a secondary command buffer and either the occlusionQueryEnable member of the pInheritanceInfo member of pBeginInfo is VK_FALSE, or the precise occlusion queries feature is not enabled, the queryFlags member of the pInheritanceInfo member pBeginInfo must not contain VK_QUERY_CONTROL_PRECISE_BIT"
VUID-vkBeginCommandBuffer-commandBuffer-parameter,Y,None,implicit,vkBeginCommandBuffer,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkBeginCommandBuffer-pBeginInfo-parameter,Y,None,implicit,vkBeginCommandBuffer,core, pBeginInfo must be a valid pointer to a valid VkCommandBufferBeginInfo structure
VUID-vkBindAccelerationStructureMemoryNVX-bindInfoCount-arraylength,N,None,implicit,vkBindAccelerationStructureMemoryNVX,(VK_NVX_raytracing), bindInfoCount must be greater than 0
VUID-vkBindAccelerationStructureMemoryNVX-device-parameter,Y,None,implicit,vkBindAccelerationStructureMemoryNVX,(VK_NVX_raytracing), device must be a valid VkDevice handle
VUID-vkBindAccelerationStructureMemoryNVX-pBindInfos-parameter,Y,None,implicit,vkBindAccelerationStructureMemoryNVX,(VK_NVX_raytracing), pBindInfos must be a valid pointer to an array of bindInfoCount valid VkBindAccelerationStructureMemoryInfoNVX structures
VUID-vkBindBufferMemory-None-01898,N,None,explicit,vkBindBufferMemory,(VK_VERSION_1_1)," If buffer was created with the VK_BUFFER_CREATE_PROTECTED_BIT bit set, the buffer must be bound to a memory object allocated with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT"
VUID-vkBindBufferMemory-None-01899,N,None,explicit,vkBindBufferMemory,(VK_VERSION_1_1)," If buffer was created with the VK_BUFFER_CREATE_PROTECTED_BIT bit not set, the buffer must not be bound to a memory object created with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT"
VUID-vkBindBufferMemory-buffer-01029,Y,BindInvalidMemory,explicit,vkBindBufferMemory,core, buffer must not already be backed by a memory object
VUID-vkBindBufferMemory-buffer-01030,Y,BindInvalidMemory,explicit,vkBindBufferMemory,core, buffer must not have been created with any sparse memory binding flags
VUID-vkBindBufferMemory-buffer-01038,N,None,explicit,vkBindBufferMemory,(VK_NV_dedicated_allocation)," If buffer was created with VkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must have been created with VkDedicatedAllocationMemoryAllocateInfoNV::buffer equal to a buffer handle created with identical creation parameters to buffer and memoryOffset must be zero"
VUID-vkBindBufferMemory-buffer-01039,N,None,explicit,vkBindBufferMemory,"(VK_NV_dedicated_allocation)+!(VK_VERSION_1_1,VK_KHR_dedicated_allocation)"," If buffer was not created with VkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must not have been allocated dedicated for a specific buffer or image"
VUID-vkBindBufferMemory-buffer-01444,N,None,explicit,vkBindBufferMemory,"(VK_VERSION_1_1,VK_KHR_dedicated_allocation)"," If buffer requires a dedicated allocation(as reported by vkGetBufferMemoryRequirements2 in VkMemoryDedicatedRequirements::requiresDedicatedAllocation for buffer), memory must have been created with VkMemoryDedicatedAllocateInfo::buffer equal to buffer"
VUID-vkBindBufferMemory-buffer-parameter,Y,VertexBufferInvalid,implicit,vkBindBufferMemory,core, buffer must be a valid VkBuffer handle
VUID-vkBindBufferMemory-buffer-parent,Y,None,implicit,vkBindBufferMemory,core," buffer must have been created, allocated, or retrieved from device"
VUID-vkBindBufferMemory-device-parameter,Y,None,implicit,vkBindBufferMemory,core, device must be a valid VkDevice handle
VUID-vkBindBufferMemory-memory-01035,Y,BindInvalidMemory,explicit,vkBindBufferMemory,core, memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer
VUID-vkBindBufferMemory-memory-01508,Y,DedicatedAllocation,explicit,vkBindBufferMemory,"(VK_VERSION_1_1,VK_KHR_dedicated_allocation)"," If the VkMemoryAllocateInfo provided when memory was allocated included an instance of VkMemoryDedicatedAllocateInfo in its pNext chain, and VkMemoryDedicatedAllocateInfo::buffer was not VK_NULL_HANDLE, then buffer must equal VkMemoryDedicatedAllocateInfo::buffer, and memoryOffset must be zero."
VUID-vkBindBufferMemory-memory-parameter,Y,BindInvalidMemory,implicit,vkBindBufferMemory,core, memory must be a valid VkDeviceMemory handle
VUID-vkBindBufferMemory-memory-parent,Y,None,implicit,vkBindBufferMemory,core," memory must have been created, allocated, or retrieved from device"
VUID-vkBindBufferMemory-memoryOffset-01031,Y,BindInvalidMemory,explicit,vkBindBufferMemory,core, memoryOffset must be less than the size of memory
VUID-vkBindBufferMemory-memoryOffset-01036,Y,"VertexBufferInvalid, BindInvalidMemory",explicit,vkBindBufferMemory,core, memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer
VUID-vkBindBufferMemory-size-01037,Y,"DedicatedAllocation, BindInvalidMemory",explicit,vkBindBufferMemory,core, The size member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer must be less than or equal to the size of memory minus memoryOffset
VUID-vkBindBufferMemory2-bindInfoCount-arraylength,N,None,implicit,vkBindBufferMemory2,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", bindInfoCount must be greater than 0
VUID-vkBindBufferMemory2-device-parameter,Y,None,implicit,vkBindBufferMemory2,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", device must be a valid VkDevice handle
VUID-vkBindBufferMemory2-pBindInfos-parameter,Y,None,implicit,vkBindBufferMemory2,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", pBindInfos must be a valid pointer to an array of bindInfoCount valid VkBindBufferMemoryInfo structures
VUID-vkBindImageMemory-None-01901,N,None,explicit,vkBindImageMemory,(VK_VERSION_1_1)," If image was created with the VK_IMAGE_CREATE_PROTECTED_BIT bit set, the image must be bound to a memory object allocated with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT"
VUID-vkBindImageMemory-None-01902,N,None,explicit,vkBindImageMemory,(VK_VERSION_1_1)," If image was created with the VK_IMAGE_CREATE_PROTECTED_BIT bit not set, the image must not be bound to a memory object created with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT"
VUID-vkBindImageMemory-device-parameter,Y,None,implicit,vkBindImageMemory,core, device must be a valid VkDevice handle
VUID-vkBindImageMemory-image-01044,Y,BindInvalidMemory,explicit,vkBindImageMemory,core, image must not already be backed by a memory object
VUID-vkBindImageMemory-image-01045,Y,BindInvalidMemory,explicit,vkBindImageMemory,core, image must not have been created with any sparse memory binding flags
VUID-vkBindImageMemory-image-01050,N,None,explicit,vkBindImageMemory,(VK_NV_dedicated_allocation)," If image was created with VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must have been created with VkDedicatedAllocationMemoryAllocateInfoNV::image equal to an image handle created with identical creation parameters to image and memoryOffset must be zero"
VUID-vkBindImageMemory-image-01051,N,None,explicit,vkBindImageMemory,"(VK_NV_dedicated_allocation)+!(VK_VERSION_1_1,VK_KHR_dedicated_allocation)"," If image was not created with VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must not have been allocated dedicated for a specific buffer or image"
VUID-vkBindImageMemory-image-01445,N,None,explicit,vkBindImageMemory,"(VK_VERSION_1_1,VK_KHR_dedicated_allocation)"," If image requires a dedicated allocation (as reported by vkGetImageMemoryRequirements2 in VkMemoryDedicatedRequirements::requiresDedicatedAllocation for image), memory must have been created with VkMemoryDedicatedAllocateInfo::image equal to image"
VUID-vkBindImageMemory-image-01608,N,None,explicit,vkBindImageMemory,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", image must not have been created with the VK_IMAGE_CREATE_DISJOINT_BIT set.
VUID-vkBindImageMemory-image-parameter,Y,BindMemoryToDestroyedObject,implicit,vkBindImageMemory,core, image must be a valid VkImage handle
VUID-vkBindImageMemory-image-parent,Y,None,implicit,vkBindImageMemory,core," image must have been created, allocated, or retrieved from device"
VUID-vkBindImageMemory-memory-01047,Y,BindInvalidMemory,explicit,vkBindImageMemory,core, memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with image
VUID-vkBindImageMemory-memory-01509,Y,DedicatedAllocation,explicit,vkBindImageMemory,"(VK_VERSION_1_1,VK_KHR_dedicated_allocation)"," If the VkMemoryAllocateInfo provided when memory was allocated included an instance of VkMemoryDedicatedAllocateInfo in its pNext chain, and VkMemoryDedicatedAllocateInfo::image was not VK_NULL_HANDLE, then image must equal VkMemoryDedicatedAllocateInfo::image and memoryOffset must be zero."
VUID-vkBindImageMemory-memory-parameter,Y,BindInvalidMemory,implicit,vkBindImageMemory,core, memory must be a valid VkDeviceMemory handle
VUID-vkBindImageMemory-memory-parent,Y,None,implicit,vkBindImageMemory,core," memory must have been created, allocated, or retrieved from device"
VUID-vkBindImageMemory-memoryOffset-01046,Y,BindInvalidMemory,explicit,vkBindImageMemory,core, memoryOffset must be less than the size of memory
VUID-vkBindImageMemory-memoryOffset-01048,Y,BindInvalidMemory,explicit,vkBindImageMemory,core, memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with image
VUID-vkBindImageMemory-size-01049,Y,"DedicatedAllocation, BindInvalidMemory",explicit,vkBindImageMemory,core, The size member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with image must be less than or equal to the size of memory minus memoryOffset
VUID-vkBindImageMemory2-bindInfoCount-arraylength,N,None,implicit,vkBindImageMemory2,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", bindInfoCount must be greater than 0
VUID-vkBindImageMemory2-device-parameter,Y,None,implicit,vkBindImageMemory2,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", device must be a valid VkDevice handle
VUID-vkBindImageMemory2-pBindInfos-parameter,Y,None,implicit,vkBindImageMemory2,"(VK_VERSION_1_1,VK_KHR_bind_memory2)", pBindInfos must be a valid pointer to an array of bindInfoCount valid VkBindImageMemoryInfo structures
VUID-vkCmdBeginConditionalRenderingEXT-None-01980,N,None,explicit,vkCmdBeginConditionalRenderingEXT,(VK_EXT_conditional_rendering), Conditional rendering must not already be active
VUID-vkCmdBeginConditionalRenderingEXT-commandBuffer-cmdpool,N,None,implicit,vkCmdBeginConditionalRenderingEXT,(VK_EXT_conditional_rendering)," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdBeginConditionalRenderingEXT-commandBuffer-parameter,Y,None,implicit,vkCmdBeginConditionalRenderingEXT,(VK_EXT_conditional_rendering), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdBeginConditionalRenderingEXT-commandBuffer-recording,N,None,implicit,vkCmdBeginConditionalRenderingEXT,(VK_EXT_conditional_rendering), commandBuffer must be in the recording state
VUID-vkCmdBeginConditionalRenderingEXT-pConditionalRenderingBegin-parameter,Y,None,implicit,vkCmdBeginConditionalRenderingEXT,(VK_EXT_conditional_rendering), pConditionalRenderingBegin must be a valid pointer to a valid VkConditionalRenderingBeginInfoEXT structure
VUID-vkCmdBeginDebugUtilsLabelEXT-commandBuffer-cmdpool,N,None,implicit,vkCmdBeginDebugUtilsLabelEXT,(VK_EXT_debug_utils)," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdBeginDebugUtilsLabelEXT-commandBuffer-parameter,N,None,implicit,vkCmdBeginDebugUtilsLabelEXT,(VK_EXT_debug_utils), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdBeginDebugUtilsLabelEXT-commandBuffer-recording,N,None,implicit,vkCmdBeginDebugUtilsLabelEXT,(VK_EXT_debug_utils), commandBuffer must be in the recording state
VUID-vkCmdBeginDebugUtilsLabelEXT-pLabelInfo-parameter,Y,None,implicit,vkCmdBeginDebugUtilsLabelEXT,(VK_EXT_debug_utils), pLabelInfo must be a valid pointer to a valid VkDebugUtilsLabelEXT structure
VUID-vkCmdBeginQuery-None-00807,N,None,explicit,vkCmdBeginQuery,core, All queries used by the command must be unavailable
VUID-vkCmdBeginQuery-commandBuffer-01885,N,None,explicit,vkCmdBeginQuery,(VK_VERSION_1_1), commandBuffer must not be a protected command buffer
VUID-vkCmdBeginQuery-commandBuffer-cmdpool,Y,None,implicit,vkCmdBeginQuery,core," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdBeginQuery-commandBuffer-parameter,Y,None,implicit,vkCmdBeginQuery,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdBeginQuery-commandBuffer-recording,Y,None,implicit,vkCmdBeginQuery,core, commandBuffer must be in the recording state
VUID-vkCmdBeginQuery-commonparent,Y,None,implicit,vkCmdBeginQuery,core," Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdBeginQuery-flags-parameter,Y,None,implicit,vkCmdBeginQuery,core, flags must be a valid combination of VkQueryControlFlagBits values
VUID-vkCmdBeginQuery-query-00802,N,None,explicit,vkCmdBeginQuery,core, query must be less than the number of queries in queryPool
VUID-vkCmdBeginQuery-query-00808,N,None,explicit,vkCmdBeginQuery,"(VK_VERSION_1_1,VK_KHR_multiview)"," If vkCmdBeginQuery is called within a render pass instance, the sum of query and the number of bits set in the current subpass's view mask must be less than or equal to the number of queries in queryPool"
VUID-vkCmdBeginQuery-queryPool-01922,N,None,explicit,vkCmdBeginQuery,core, queryPool must have been created with a queryType that differs from that of any queries that are active within commandBuffer
VUID-vkCmdBeginQuery-queryPool-parameter,Y,None,implicit,vkCmdBeginQuery,core, queryPool must be a valid VkQueryPool handle
VUID-vkCmdBeginQuery-queryType-00800,N,None,explicit,vkCmdBeginQuery,core," If the precise occlusion queries feature is not enabled, or the queryType used to create queryPool was not VK_QUERY_TYPE_OCCLUSION, flags must not contain VK_QUERY_CONTROL_PRECISE_BIT"
VUID-vkCmdBeginQuery-queryType-00803,N,None,explicit,vkCmdBeginQuery,core," If the queryType used to create queryPool was VK_QUERY_TYPE_OCCLUSION, the VkCommandPool that commandBuffer was allocated from must support graphics operations"
VUID-vkCmdBeginQuery-queryType-00804,N,None,explicit,vkCmdBeginQuery,core," If the queryType used to create queryPool was VK_QUERY_TYPE_PIPELINE_STATISTICS and any of the pipelineStatistics indicate graphics operations, the VkCommandPool that commandBuffer was allocated from must support graphics operations"
VUID-vkCmdBeginQuery-queryType-00805,N,None,explicit,vkCmdBeginQuery,core," If the queryType used to create queryPool was VK_QUERY_TYPE_PIPELINE_STATISTICS and any of the pipelineStatistics indicate compute operations, the VkCommandPool that commandBuffer was allocated from must support compute operations"
VUID-vkCmdBeginRenderPass-bufferlevel,Y,None,implicit,vkCmdBeginRenderPass,core, commandBuffer must be a primary VkCommandBuffer
VUID-vkCmdBeginRenderPass-commandBuffer-cmdpool,Y,None,implicit,vkCmdBeginRenderPass,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdBeginRenderPass-commandBuffer-parameter,Y,None,implicit,vkCmdBeginRenderPass,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdBeginRenderPass-commandBuffer-recording,Y,None,implicit,vkCmdBeginRenderPass,core, commandBuffer must be in the recording state
VUID-vkCmdBeginRenderPass-contents-parameter,Y,None,implicit,vkCmdBeginRenderPass,core, contents must be a valid VkSubpassContents value
VUID-vkCmdBeginRenderPass-initialLayout-00895,N,None,explicit,vkCmdBeginRenderPass,core, If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT set
VUID-vkCmdBeginRenderPass-initialLayout-00896,N,None,explicit,vkCmdBeginRenderPass,"!(VK_VERSION_1_1,VK_KHR_maintenance2)"," If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set"
VUID-vkCmdBeginRenderPass-initialLayout-00897,N,None,explicit,vkCmdBeginRenderPass,core, If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with VK_IMAGE_USAGE_SAMPLED_BIT or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT set
VUID-vkCmdBeginRenderPass-initialLayout-00898,N,None,explicit,vkCmdBeginRenderPass,core, If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL then the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT set
VUID-vkCmdBeginRenderPass-initialLayout-00899,N,None,explicit,vkCmdBeginRenderPass,core, If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT set
VUID-vkCmdBeginRenderPass-initialLayout-00900,N,None,explicit,vkCmdBeginRenderPass,core," If any of the initialLayout members of the VkAttachmentDescription structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is not VK_IMAGE_LAYOUT_UNDEFINED, then each such initialLayout must be equal to the current layout of the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin"
VUID-vkCmdBeginRenderPass-initialLayout-01758,N,None,explicit,vkCmdBeginRenderPass,"(VK_VERSION_1_1,VK_KHR_maintenance2)"," If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set"
VUID-vkCmdBeginRenderPass-pRenderPassBegin-parameter,Y,None,implicit,vkCmdBeginRenderPass,core, pRenderPassBegin must be a valid pointer to a valid VkRenderPassBeginInfo structure
VUID-vkCmdBeginRenderPass-renderpass,Y,None,implicit,vkCmdBeginRenderPass,core, This command must only be called outside of a render pass instance
VUID-vkCmdBeginRenderPass-srcStageMask-00901,N,None,explicit,vkCmdBeginRenderPass,core, The srcStageMask and dstStageMask members of any element of the pDependencies member of VkRenderPassCreateInfo used to create renderPass must be supported by the capabilities of the queue family identified by the queueFamilyIndex member of the VkCommandPoolCreateInfo used to create the command pool which commandBuffer was allocated from.
VUID-vkCmdBeginRenderPass2KHR-bufferlevel,N,None,implicit,vkCmdBeginRenderPass2KHR,(VK_KHR_create_renderpass2), commandBuffer must be a primary VkCommandBuffer
VUID-vkCmdBeginRenderPass2KHR-commandBuffer-cmdpool,N,None,implicit,vkCmdBeginRenderPass2KHR,(VK_KHR_create_renderpass2), The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdBeginRenderPass2KHR-commandBuffer-parameter,Y,None,implicit,vkCmdBeginRenderPass2KHR,(VK_KHR_create_renderpass2), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdBeginRenderPass2KHR-commandBuffer-recording,N,None,implicit,vkCmdBeginRenderPass2KHR,(VK_KHR_create_renderpass2), commandBuffer must be in the recording state
VUID-vkCmdBeginRenderPass2KHR-initialLayout-03094,N,None,explicit,vkCmdBeginRenderPass2KHR,(VK_KHR_create_renderpass2), If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT set
VUID-vkCmdBeginRenderPass2KHR-initialLayout-03095,N,None,explicit,vkCmdBeginRenderPass2KHR,(VK_KHR_create_renderpass2)+!(VK_KHR_maintenance2)," If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set"
VUID-vkCmdBeginRenderPass2KHR-initialLayout-03096,N,None,explicit,vkCmdBeginRenderPass2KHR,(VK_KHR_create_renderpass2)+(VK_KHR_maintenance2)," If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set"
VUID-vkCmdBeginRenderPass2KHR-initialLayout-03097,N,None,explicit,vkCmdBeginRenderPass2KHR,(VK_KHR_create_renderpass2), If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with VK_IMAGE_USAGE_SAMPLED_BIT or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT set
VUID-vkCmdBeginRenderPass2KHR-initialLayout-03098,N,None,explicit,vkCmdBeginRenderPass2KHR,(VK_KHR_create_renderpass2), If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL then the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT set
VUID-vkCmdBeginRenderPass2KHR-initialLayout-03099,N,None,explicit,vkCmdBeginRenderPass2KHR,(VK_KHR_create_renderpass2), If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT set
VUID-vkCmdBeginRenderPass2KHR-initialLayout-03100,N,None,explicit,vkCmdBeginRenderPass2KHR,(VK_KHR_create_renderpass2)," If any of the initialLayout members of the VkAttachmentDescription structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is not VK_IMAGE_LAYOUT_UNDEFINED, then each such initialLayout must be equal to the current layout of the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin"
VUID-vkCmdBeginRenderPass2KHR-pRenderPassBegin-parameter,Y,None,implicit,vkCmdBeginRenderPass2KHR,(VK_KHR_create_renderpass2), pRenderPassBegin must be a valid pointer to a valid VkRenderPassBeginInfo structure
VUID-vkCmdBeginRenderPass2KHR-pSubpassBeginInfo-parameter,Y,None,implicit,vkCmdBeginRenderPass2KHR,(VK_KHR_create_renderpass2), pSubpassBeginInfo must be a valid pointer to a valid VkSubpassBeginInfoKHR structure
VUID-vkCmdBeginRenderPass2KHR-renderpass,N,None,implicit,vkCmdBeginRenderPass2KHR,(VK_KHR_create_renderpass2), This command must only be called outside of a render pass instance
VUID-vkCmdBeginRenderPass2KHR-srcStageMask-03101,N,None,explicit,vkCmdBeginRenderPass2KHR,(VK_KHR_create_renderpass2), The srcStageMask and dstStageMask members of any element of the pDependencies member of VkRenderPassCreateInfo used to create renderPass must be supported by the capabilities of the queue family identified by the queueFamilyIndex member of the VkCommandPoolCreateInfo used to create the command pool which commandBuffer was allocated from.
VUID-vkCmdBindDescriptorSets-commandBuffer-cmdpool,Y,None,implicit,vkCmdBindDescriptorSets,core," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdBindDescriptorSets-commandBuffer-parameter,Y,None,implicit,vkCmdBindDescriptorSets,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdBindDescriptorSets-commandBuffer-recording,Y,None,implicit,vkCmdBindDescriptorSets,core, commandBuffer must be in the recording state
VUID-vkCmdBindDescriptorSets-commonparent,Y,None,implicit,vkCmdBindDescriptorSets,core," Each of commandBuffer, layout, and the elements of pDescriptorSets must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdBindDescriptorSets-descriptorSetCount-arraylength,N,None,implicit,vkCmdBindDescriptorSets,core, descriptorSetCount must be greater than 0
VUID-vkCmdBindDescriptorSets-dynamicOffsetCount-00359,Y,None,explicit,vkCmdBindDescriptorSets,core, dynamicOffsetCount must be equal to the total number of dynamic descriptors in pDescriptorSets
VUID-vkCmdBindDescriptorSets-firstSet-00360,N,None,explicit,vkCmdBindDescriptorSets,core, The sum of firstSet and descriptorSetCount must be less than or equal to VkPipelineLayoutCreateInfo::setLayoutCount provided when layout was created
VUID-vkCmdBindDescriptorSets-layout-parameter,Y,DescriptorSetCompatibility,implicit,vkCmdBindDescriptorSets,core, layout must be a valid VkPipelineLayout handle
VUID-vkCmdBindDescriptorSets-pDescriptorSets-00358,Y,None,explicit,vkCmdBindDescriptorSets,core," Each element of pDescriptorSets must have been allocated with a VkDescriptorSetLayout that matches (is the same as, or identically defined as) the VkDescriptorSetLayout at set n in layout, where n is the sum of firstSet and the index into pDescriptorSets"
VUID-vkCmdBindDescriptorSets-pDescriptorSets-01979,N,None,explicit,vkCmdBindDescriptorSets,core," For each dynamic uniform or storage buffer binding in pDescriptorSets, the sum of the effective offset, as defined above, and the range of the binding must be less than or equal to the size of the buffer"
VUID-vkCmdBindDescriptorSets-pDescriptorSets-parameter,Y,InvalidDescriptorSet,implicit,vkCmdBindDescriptorSets,core, pDescriptorSets must be a valid pointer to an array of descriptorSetCount valid VkDescriptorSet handles
VUID-vkCmdBindDescriptorSets-pDynamicOffsets-01971,Y,None,explicit,vkCmdBindDescriptorSets,core, Each element of pDynamicOffsets which corresponds to a descriptor binding with type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must be a multiple of VkPhysicalDeviceLimits::minUniformBufferOffsetAlignment
VUID-vkCmdBindDescriptorSets-pDynamicOffsets-01972,Y,None,explicit,vkCmdBindDescriptorSets,core, Each element of pDynamicOffsets which corresponds to a descriptor binding with type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must be a multiple of VkPhysicalDeviceLimits::minStorageBufferOffsetAlignment
VUID-vkCmdBindDescriptorSets-pDynamicOffsets-parameter,Y,None,implicit,vkCmdBindDescriptorSets,core," If dynamicOffsetCount is not 0, pDynamicOffsets must be a valid pointer to an array of dynamicOffsetCount uint32_t values"
VUID-vkCmdBindDescriptorSets-pipelineBindPoint-00361,N,None,explicit,vkCmdBindDescriptorSets,core, pipelineBindPoint must be supported by the commandBuffer's parent VkCommandPool's queue family
VUID-vkCmdBindDescriptorSets-pipelineBindPoint-parameter,Y,None,implicit,vkCmdBindDescriptorSets,core, pipelineBindPoint must be a valid VkPipelineBindPoint value
VUID-vkCmdBindIndexBuffer-buffer-00433,Y,None,explicit,vkCmdBindIndexBuffer,core, buffer must have been created with the VK_BUFFER_USAGE_INDEX_BUFFER_BIT flag
VUID-vkCmdBindIndexBuffer-buffer-00434,Y,None,explicit,vkCmdBindIndexBuffer,core, If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdBindIndexBuffer-buffer-parameter,Y,None,implicit,vkCmdBindIndexBuffer,core, buffer must be a valid VkBuffer handle
VUID-vkCmdBindIndexBuffer-commandBuffer-cmdpool,Y,None,implicit,vkCmdBindIndexBuffer,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdBindIndexBuffer-commandBuffer-parameter,Y,None,implicit,vkCmdBindIndexBuffer,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdBindIndexBuffer-commandBuffer-recording,Y,None,implicit,vkCmdBindIndexBuffer,core, commandBuffer must be in the recording state
VUID-vkCmdBindIndexBuffer-commonparent,Y,None,implicit,vkCmdBindIndexBuffer,core," Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdBindIndexBuffer-indexType-parameter,Y,None,implicit,vkCmdBindIndexBuffer,core, indexType must be a valid VkIndexType value
VUID-vkCmdBindIndexBuffer-offset-00431,N,None,explicit,vkCmdBindIndexBuffer,core, offset must be less than the size of buffer
VUID-vkCmdBindIndexBuffer-offset-00432,Y,None,explicit,vkCmdBindIndexBuffer,core," The sum of offset and the address of the range of VkDeviceMemory object that is backing buffer, must be a multiple of the type indicated by indexType"
VUID-vkCmdBindPipeline-commandBuffer-cmdpool,Y,None,implicit,vkCmdBindPipeline,core," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdBindPipeline-commandBuffer-parameter,Y,None,implicit,vkCmdBindPipeline,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdBindPipeline-commandBuffer-recording,Y,None,implicit,vkCmdBindPipeline,core, commandBuffer must be in the recording state
VUID-vkCmdBindPipeline-commonparent,Y,None,implicit,vkCmdBindPipeline,core," Both of commandBuffer, and pipeline must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdBindPipeline-pipeline-00781,N,None,explicit,vkCmdBindPipeline,core," If the variable multisample rate feature is not supported, pipeline is a graphics pipeline, the current subpass has no attachments, and this is not the first call to this function with a graphics pipeline after transitioning to the current subpass, then the sample count specified by this pipeline must match that set in the previous pipeline"
VUID-vkCmdBindPipeline-pipeline-parameter,Y,"InvalidPipeline, PipelineNotBound",implicit,vkCmdBindPipeline,core, pipeline must be a valid VkPipeline handle
VUID-vkCmdBindPipeline-pipelineBindPoint-00777,N,None,explicit,vkCmdBindPipeline,core," If pipelineBindPoint is VK_PIPELINE_BIND_POINT_COMPUTE, the VkCommandPool that commandBuffer was allocated from must support compute operations"
VUID-vkCmdBindPipeline-pipelineBindPoint-00778,N,None,explicit,vkCmdBindPipeline,core," If pipelineBindPoint is VK_PIPELINE_BIND_POINT_GRAPHICS, the VkCommandPool that commandBuffer was allocated from must support graphics operations"
VUID-vkCmdBindPipeline-pipelineBindPoint-00779,N,None,explicit,vkCmdBindPipeline,core," If pipelineBindPoint is VK_PIPELINE_BIND_POINT_COMPUTE, pipeline must be a compute pipeline"
VUID-vkCmdBindPipeline-pipelineBindPoint-00780,N,None,explicit,vkCmdBindPipeline,core," If pipelineBindPoint is VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline must be a graphics pipeline"
VUID-vkCmdBindPipeline-pipelineBindPoint-parameter,Y,None,implicit,vkCmdBindPipeline,core, pipelineBindPoint must be a valid VkPipelineBindPoint value
VUID-vkCmdBindPipeline-variableSampleLocations-01525,N,None,explicit,vkCmdBindPipeline,(VK_EXT_sample_locations)," If VkPhysicalDeviceSampleLocationsPropertiesEXT::variableSampleLocations is VK_FALSE, and pipeline is a graphics pipeline created with a VkPipelineSampleLocationsStateCreateInfoEXT structure having its sampleLocationsEnable member set to VK_TRUE but without VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT enabled then the current render pass instance must have been begun by specifying a VkRenderPassSampleLocationsBeginInfoEXT structure whose pPostSubpassSampleLocations member contains an element with a subpassIndex matching the current subpass index and the sampleLocationsInfo member of that element must match the sampleLocationsInfo specified in VkPipelineSampleLocationsStateCreateInfoEXT when the pipeline was created"
VUID-vkCmdBindShadingRateImageNV-None-02058,Y,None,explicit,vkCmdBindShadingRateImageNV,(VK_NV_shading_rate_image), The shading rate image feature must be enabled.
VUID-vkCmdBindShadingRateImageNV-commandBuffer-cmdpool,Y,None,implicit,vkCmdBindShadingRateImageNV,(VK_NV_shading_rate_image), The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdBindShadingRateImageNV-commandBuffer-parameter,Y,None,implicit,vkCmdBindShadingRateImageNV,(VK_NV_shading_rate_image), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdBindShadingRateImageNV-commandBuffer-recording,Y,None,implicit,vkCmdBindShadingRateImageNV,(VK_NV_shading_rate_image), commandBuffer must be in the recording state
VUID-vkCmdBindShadingRateImageNV-commonparent,Y,None,implicit,vkCmdBindShadingRateImageNV,(VK_NV_shading_rate_image)," Both of commandBuffer, and imageView must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdBindShadingRateImageNV-imageLayout-02063,Y,ShadingRateImageNV,explicit,vkCmdBindShadingRateImageNV,(VK_NV_shading_rate_image)," If imageView is not VK_NULL_HANDLE, imageLayout must be VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV or VK_IMAGE_LAYOUT_GENERAL."
VUID-vkCmdBindShadingRateImageNV-imageLayout-parameter,Y,None,implicit,vkCmdBindShadingRateImageNV,(VK_NV_shading_rate_image), imageLayout must be a valid VkImageLayout value
VUID-vkCmdBindShadingRateImageNV-imageView-02059,Y,None,explicit,vkCmdBindShadingRateImageNV,(VK_NV_shading_rate_image)," If imageView is not VK_NULL_HANDLE, it must be a valid VkImageView handle of type VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY."
VUID-vkCmdBindShadingRateImageNV-imageView-02060,Y,ShadingRateImageNV,explicit,vkCmdBindShadingRateImageNV,(VK_NV_shading_rate_image)," If imageView is not VK_NULL_HANDLE, it must have a format of VK_FORMAT_R8_UINT."
VUID-vkCmdBindShadingRateImageNV-imageView-02061,Y,ShadingRateImageNV,explicit,vkCmdBindShadingRateImageNV,(VK_NV_shading_rate_image)," If imageView is not VK_NULL_HANDLE, the image must have been created with VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV set"
VUID-vkCmdBindShadingRateImageNV-imageView-02062,Y,ShadingRateImageNV,explicit,vkCmdBindShadingRateImageNV,(VK_NV_shading_rate_image)," If imageView is not VK_NULL_HANDLE, imageLayout must match the actual VkImageLayout of each subresource accessible from imageView at the time the subresource is accessed."
VUID-vkCmdBindShadingRateImageNV-imageView-parameter,Y,None,implicit,vkCmdBindShadingRateImageNV,(VK_NV_shading_rate_image), imageView must be a valid VkImageView handle
VUID-vkCmdBindVertexBuffers-bindingCount-arraylength,Y,None,implicit,vkCmdBindVertexBuffers,core, bindingCount must be greater than 0
VUID-vkCmdBindVertexBuffers-commandBuffer-cmdpool,Y,None,implicit,vkCmdBindVertexBuffers,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdBindVertexBuffers-commandBuffer-parameter,Y,None,implicit,vkCmdBindVertexBuffers,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdBindVertexBuffers-commandBuffer-recording,Y,None,implicit,vkCmdBindVertexBuffers,core, commandBuffer must be in the recording state
VUID-vkCmdBindVertexBuffers-commonparent,Y,None,implicit,vkCmdBindVertexBuffers,core," Both of commandBuffer, and the elements of pBuffers must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdBindVertexBuffers-firstBinding-00624,N,None,explicit,vkCmdBindVertexBuffers,core, firstBinding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings
VUID-vkCmdBindVertexBuffers-firstBinding-00625,N,None,explicit,vkCmdBindVertexBuffers,core, The sum of firstBinding and bindingCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindings
VUID-vkCmdBindVertexBuffers-pBuffers-00627,Y,None,explicit,vkCmdBindVertexBuffers,core, All elements of pBuffers must have been created with the VK_BUFFER_USAGE_VERTEX_BUFFER_BIT flag
VUID-vkCmdBindVertexBuffers-pBuffers-00628,Y,None,explicit,vkCmdBindVertexBuffers,core, Each element of pBuffers that is non-sparse must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdBindVertexBuffers-pBuffers-parameter,Y,None,implicit,vkCmdBindVertexBuffers,core, pBuffers must be a valid pointer to an array of bindingCount valid VkBuffer handles
VUID-vkCmdBindVertexBuffers-pOffsets-00626,Y,BadVertexBufferOffset,explicit,vkCmdBindVertexBuffers,core, All elements of pOffsets must be less than the size of the corresponding element in pBuffers
VUID-vkCmdBindVertexBuffers-pOffsets-parameter,Y,None,implicit,vkCmdBindVertexBuffers,core, pOffsets must be a valid pointer to an array of bindingCount VkDeviceSize values
VUID-vkCmdBlitImage-commandBuffer-01834,N,None,explicit,vkCmdBlitImage,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, then srcImage must not be a protected image"
VUID-vkCmdBlitImage-commandBuffer-01835,N,None,explicit,vkCmdBlitImage,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, then dstImage must not be a protected image"
VUID-vkCmdBlitImage-commandBuffer-01836,N,None,explicit,vkCmdBlitImage,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, then dstImage must not be an unprotected image"
VUID-vkCmdBlitImage-commandBuffer-cmdpool,Y,None,implicit,vkCmdBlitImage,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdBlitImage-commandBuffer-parameter,Y,None,implicit,vkCmdBlitImage,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdBlitImage-commandBuffer-recording,Y,None,implicit,vkCmdBlitImage,core, commandBuffer must be in the recording state
VUID-vkCmdBlitImage-commonparent,Y,None,implicit,vkCmdBlitImage,core," Each of commandBuffer, dstImage, and srcImage must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdBlitImage-dstImage-00224,Y,None,explicit,vkCmdBlitImage,core, dstImage must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag
VUID-vkCmdBlitImage-dstImage-00225,Y,None,explicit,vkCmdBlitImage,core, If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdBlitImage-dstImage-00234,Y,"ImageSampleCounts, MiscBlitImageTests",explicit,vkCmdBlitImage,core, dstImage must have been created with a samples value of VK_SAMPLE_COUNT_1_BIT
VUID-vkCmdBlitImage-dstImage-01562,N,None,explicit,vkCmdBlitImage,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", dstImage must not use a format listed in Formats requiring sampler Y'CBCR conversion for VK_IMAGE_ASPECT_COLOR_BIT image views
VUID-vkCmdBlitImage-dstImage-02000,Y,"BlitImageFormatTypes, BlitToDepthImageTests",explicit,vkCmdBlitImage,core, The format features of dstImage must contain VK_FORMAT_FEATURE_BLIT_DST_BIT.
VUID-vkCmdBlitImage-dstImage-parameter,Y,None,implicit,vkCmdBlitImage,core, dstImage must be a valid VkImage handle
VUID-vkCmdBlitImage-dstImageLayout-00226,Y,BlitImageLayout,explicit,vkCmdBlitImage,core, dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice
VUID-vkCmdBlitImage-dstImageLayout-00227,Y,BlitImageLayout,explicit,vkCmdBlitImage,!(VK_KHR_shared_presentable_image), dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL
VUID-vkCmdBlitImage-dstImageLayout-01399,Y,None,explicit,vkCmdBlitImage,(VK_KHR_shared_presentable_image)," dstImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL"
VUID-vkCmdBlitImage-dstImageLayout-parameter,Y,None,implicit,vkCmdBlitImage,core, dstImageLayout must be a valid VkImageLayout value
VUID-vkCmdBlitImage-dstSubresource-01706,Y,MiscBlitImageTests,explicit,vkCmdBlitImage,core, The dstSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created
VUID-vkCmdBlitImage-dstSubresource-01708,Y,MiscBlitImageTests,explicit,vkCmdBlitImage,core, The dstSubresource.baseArrayLayer + dstSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created
VUID-vkCmdBlitImage-filter-00237,Y,BlitImageFilters,explicit,vkCmdBlitImage,(VK_IMG_filter_cubic)," If filter is VK_FILTER_CUBIC_IMG, srcImage must have a VkImageType of VK_IMAGE_TYPE_2D"
VUID-vkCmdBlitImage-filter-02001,Y,BlitImageFilters,explicit,vkCmdBlitImage,core," If filter is VK_FILTER_LINEAR, then the format features of srcImage must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT."
VUID-vkCmdBlitImage-filter-02002,Y,BlitImageFilters,explicit,vkCmdBlitImage,(VK_IMG_filter_cubic)," If filter is VK_FILTER_CUBIC_IMG, then the format features of srcImage must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG."
VUID-vkCmdBlitImage-filter-parameter,Y,None,implicit,vkCmdBlitImage,core, filter must be a valid VkFilter value
VUID-vkCmdBlitImage-pRegions-00215,Y,"MiscBlitImageTests, BlitImageOffsets",explicit,vkCmdBlitImage,core, The source region specified by each element of pRegions must be a region that is contained within srcImage
VUID-vkCmdBlitImage-pRegions-00216,Y,"MiscBlitImageTests, BlitImageOffsets",explicit,vkCmdBlitImage,core, The destination region specified by each element of pRegions must be a region that is contained within dstImage
VUID-vkCmdBlitImage-pRegions-00217,N,None,explicit,vkCmdBlitImage,core," The union of all destination regions, specified by the elements of pRegions, must not overlap in memory with any texel that may be sampled during the blit operation"
VUID-vkCmdBlitImage-pRegions-parameter,Y,None,implicit,vkCmdBlitImage,core, pRegions must be a valid pointer to an array of regionCount valid VkImageBlit structures
VUID-vkCmdBlitImage-regionCount-arraylength,Y,None,implicit,vkCmdBlitImage,core, regionCount must be greater than 0
VUID-vkCmdBlitImage-renderpass,Y,None,implicit,vkCmdBlitImage,core, This command must only be called outside of a render pass instance
VUID-vkCmdBlitImage-srcImage-00219,Y,None,explicit,vkCmdBlitImage,core, srcImage must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag
VUID-vkCmdBlitImage-srcImage-00220,Y,None,explicit,vkCmdBlitImage,core, If srcImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdBlitImage-srcImage-00228,Y,"ImageSampleCounts, MiscBlitImageTests",explicit,vkCmdBlitImage,core, The sample count of srcImage and dstImage must both be equal to VK_SAMPLE_COUNT_1_BIT
VUID-vkCmdBlitImage-srcImage-00229,Y,BlitImageFormatTypes,explicit,vkCmdBlitImage,core," If either of srcImage or dstImage was created with a signed integer VkFormat, the other must also have been created with a signed integer VkFormat"
VUID-vkCmdBlitImage-srcImage-00230,Y,BlitImageFormatTypes,explicit,vkCmdBlitImage,core," If either of srcImage or dstImage was created with an unsigned integer VkFormat, the other must also have been created with an unsigned integer VkFormat"
VUID-vkCmdBlitImage-srcImage-00231,Y,BlitImageFormatTypes,explicit,vkCmdBlitImage,core," If either of srcImage or dstImage was created with a depth/stencil format, the other must have exactly the same format"
VUID-vkCmdBlitImage-srcImage-00232,Y,None,explicit,vkCmdBlitImage,core," If srcImage was created with a depth/stencil format, filter must be VK_FILTER_NEAREST"
VUID-vkCmdBlitImage-srcImage-00233,Y,"ImageSampleCounts, MiscBlitImageTests",explicit,vkCmdBlitImage,core, srcImage must have been created with a samples value of VK_SAMPLE_COUNT_1_BIT
VUID-vkCmdBlitImage-srcImage-01561,N,None,explicit,vkCmdBlitImage,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", srcImage must not use a format listed in Formats requiring sampler Y'CBCR conversion for VK_IMAGE_ASPECT_COLOR_BIT image views
VUID-vkCmdBlitImage-srcImage-01999,Y,BlitImageFormatTypes,explicit,vkCmdBlitImage,core, The format features of srcImage must contain VK_FORMAT_FEATURE_BLIT_SRC_BIT.
VUID-vkCmdBlitImage-srcImage-parameter,Y,None,implicit,vkCmdBlitImage,core, srcImage must be a valid VkImage handle
VUID-vkCmdBlitImage-srcImageLayout-00221,Y,BlitImageLayout,explicit,vkCmdBlitImage,core, srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice
VUID-vkCmdBlitImage-srcImageLayout-00222,Y,BlitImageLayout,explicit,vkCmdBlitImage,!(VK_KHR_shared_presentable_image), srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL
VUID-vkCmdBlitImage-srcImageLayout-01398,Y,None,explicit,vkCmdBlitImage,(VK_KHR_shared_presentable_image)," srcImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL"
VUID-vkCmdBlitImage-srcImageLayout-parameter,Y,None,implicit,vkCmdBlitImage,core, srcImageLayout must be a valid VkImageLayout value
VUID-vkCmdBlitImage-srcSubresource-01705,Y,MiscBlitImageTests,explicit,vkCmdBlitImage,core, The srcSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created
VUID-vkCmdBlitImage-srcSubresource-01707,Y,MiscBlitImageTests,explicit,vkCmdBlitImage,core, The srcSubresource.baseArrayLayer + srcSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created
VUID-vkCmdBuildAccelerationStructureNVX-cmdBuf-parameter,Y,None,implicit,vkCmdBuildAccelerationStructureNVX,(VK_NVX_raytracing), cmdBuf must be a valid VkCommandBuffer handle
VUID-vkCmdBuildAccelerationStructureNVX-commandBuffer-cmdpool,N,None,implicit,vkCmdBuildAccelerationStructureNVX,(VK_NVX_raytracing)," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdBuildAccelerationStructureNVX-commandBuffer-recording,N,None,implicit,vkCmdBuildAccelerationStructureNVX,(VK_NVX_raytracing), commandBuffer must be in the recording state
VUID-vkCmdBuildAccelerationStructureNVX-commonparent,Y,None,implicit,vkCmdBuildAccelerationStructureNVX,(VK_NVX_raytracing)," Each of cmdBuf, dst, instanceData, scratch, and src that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdBuildAccelerationStructureNVX-dst-parameter,Y,None,implicit,vkCmdBuildAccelerationStructureNVX,(VK_NVX_raytracing), dst must be a valid VkAccelerationStructureNVX handle
VUID-vkCmdBuildAccelerationStructureNVX-flags-parameter,Y,None,implicit,vkCmdBuildAccelerationStructureNVX,(VK_NVX_raytracing), flags must be a valid combination of VkBuildAccelerationStructureFlagBitsNVX values
VUID-vkCmdBuildAccelerationStructureNVX-geometryCount-02241,N,None,explicit,vkCmdBuildAccelerationStructureNVX,(VK_NVX_raytracing), geometryCount must be less than or equal to VkPhysicalDeviceRaytracingPropertiesNVX::maxGeometryCount
VUID-vkCmdBuildAccelerationStructureNVX-instanceData-parameter,Y,None,implicit,vkCmdBuildAccelerationStructureNVX,(VK_NVX_raytracing)," If instanceData is not VK_NULL_HANDLE, instanceData must be a valid VkBuffer handle"
VUID-vkCmdBuildAccelerationStructureNVX-pGeometries-parameter,Y,None,implicit,vkCmdBuildAccelerationStructureNVX,(VK_NVX_raytracing)," If geometryCount is not 0, pGeometries must be a valid pointer to an array of geometryCount valid VkGeometryNVX structures"
VUID-vkCmdBuildAccelerationStructureNVX-scratch-parameter,Y,None,implicit,vkCmdBuildAccelerationStructureNVX,(VK_NVX_raytracing), scratch must be a valid VkBuffer handle
VUID-vkCmdBuildAccelerationStructureNVX-src-parameter,Y,None,implicit,vkCmdBuildAccelerationStructureNVX,(VK_NVX_raytracing)," If src is not VK_NULL_HANDLE, src must be a valid VkAccelerationStructureNVX handle"
VUID-vkCmdBuildAccelerationStructureNVX-type-parameter,Y,None,implicit,vkCmdBuildAccelerationStructureNVX,(VK_NVX_raytracing), type must be a valid VkAccelerationStructureTypeNVX value
VUID-vkCmdClearAttachments-aspectMask-00015,Y,MissingClearAttachment,explicit,vkCmdClearAttachments,core," If the aspectMask member of any element of pAttachments contains VK_IMAGE_ASPECT_COLOR_BIT, the colorAttachment member of that element must refer to a valid color attachment in the current subpass"
VUID-vkCmdClearAttachments-attachmentCount-arraylength,Y,None,implicit,vkCmdClearAttachments,core, attachmentCount must be greater than 0
VUID-vkCmdClearAttachments-baseArrayLayer-00018,N,None,explicit,vkCmdClearAttachments,"(VK_VERSION_1_1,VK_KHR_multiview)"," If the render pass instance this is recorded in uses multiview, then baseArrayLayer must be zero and layerCount must be one."
VUID-vkCmdClearAttachments-commandBuffer-cmdpool,Y,None,implicit,vkCmdClearAttachments,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdClearAttachments-commandBuffer-parameter,Y,None,implicit,vkCmdClearAttachments,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdClearAttachments-commandBuffer-recording,Y,None,implicit,vkCmdClearAttachments,core, commandBuffer must be in the recording state
VUID-vkCmdClearAttachments-layerCount-01934,N,None,explicit,vkCmdClearAttachments,core, The layerCount member of each element of pRects must not be 0
VUID-vkCmdClearAttachments-pAttachments-parameter,Y,None,implicit,vkCmdClearAttachments,core, pAttachments must be a valid pointer to an array of attachmentCount valid VkClearAttachment structures
VUID-vkCmdClearAttachments-pRects-00016,Y,"SecondaryCommandBufferClearColorAttachmentsRenderArea, CmdClearAttachmentTests",explicit,vkCmdClearAttachments,core, The rectangular region specified by each element of pRects must be contained within the render area of the current render pass instance
VUID-vkCmdClearAttachments-pRects-00017,Y,CmdClearAttachmentTests,explicit,vkCmdClearAttachments,core, The layers specified by each element of pRects must be contained within every attachment that pAttachments refers to
VUID-vkCmdClearAttachments-pRects-parameter,Y,None,implicit,vkCmdClearAttachments,core, pRects must be a valid pointer to an array of rectCount VkClearRect structures
VUID-vkCmdClearAttachments-rectCount-arraylength,Y,None,implicit,vkCmdClearAttachments,core, rectCount must be greater than 0
VUID-vkCmdClearAttachments-renderpass,Y,None,implicit,vkCmdClearAttachments,core, This command must only be called inside of a render pass instance
VUID-vkCmdClearColorImage-baseArrayLayer-01472,Y,ClearColorImageWithBadRange,explicit,vkCmdClearColorImage,core, The VkImageSubresourceRange::baseArrayLayer members of the elements of the pRanges array must each be less than the arrayLayers specified in VkImageCreateInfo when image was created
VUID-vkCmdClearColorImage-baseMipLevel-01470,Y,ClearColorImageWithBadRange,explicit,vkCmdClearColorImage,core, The VkImageSubresourceRange::baseMipLevel members of the elements of the pRanges array must each be less than the mipLevels specified in VkImageCreateInfo when image was created
VUID-vkCmdClearColorImage-commandBuffer-01805,N,None,explicit,vkCmdClearColorImage,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, then image must not be a protected image"
VUID-vkCmdClearColorImage-commandBuffer-01806,N,None,explicit,vkCmdClearColorImage,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, then image must not be an unprotected image"
VUID-vkCmdClearColorImage-commandBuffer-cmdpool,Y,None,implicit,vkCmdClearColorImage,core," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdClearColorImage-commandBuffer-parameter,Y,None,implicit,vkCmdClearColorImage,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdClearColorImage-commandBuffer-recording,Y,None,implicit,vkCmdClearColorImage,core, commandBuffer must be in the recording state
VUID-vkCmdClearColorImage-commonparent,Y,None,implicit,vkCmdClearColorImage,core," Both of commandBuffer, and image must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdClearColorImage-image-00002,Y,None,explicit,vkCmdClearColorImage,core, image must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag
VUID-vkCmdClearColorImage-image-00003,Y,None,explicit,vkCmdClearColorImage,core, If image is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdClearColorImage-image-00007,Y,None,explicit,vkCmdClearColorImage,core, image must not have a compressed or depth/stencil format
VUID-vkCmdClearColorImage-image-01545,N,None,explicit,vkCmdClearColorImage,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", image must not use a format listed in Formats requiring sampler Y'CBCR conversion for VK_IMAGE_ASPECT_COLOR_BIT image views
VUID-vkCmdClearColorImage-image-01993,Y,None,explicit,vkCmdClearColorImage,"(VK_VERSION_1_1,VK_KHR_maintenance1)", The format features of image must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT.
VUID-vkCmdClearColorImage-image-parameter,Y,None,implicit,vkCmdClearColorImage,core, image must be a valid VkImage handle
VUID-vkCmdClearColorImage-imageLayout-00004,Y,InvalidImageLayout,explicit,vkCmdClearColorImage,core, imageLayout must specify the layout of the image subresource ranges of image specified in pRanges at the time this command is executed on a VkDevice
VUID-vkCmdClearColorImage-imageLayout-00005,Y,InvalidImageLayout,explicit,vkCmdClearColorImage,!(VK_KHR_shared_presentable_image), imageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL
VUID-vkCmdClearColorImage-imageLayout-01394,N,None,explicit,vkCmdClearColorImage,(VK_KHR_shared_presentable_image)," imageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"
VUID-vkCmdClearColorImage-imageLayout-parameter,Y,None,implicit,vkCmdClearColorImage,core, imageLayout must be a valid VkImageLayout value
VUID-vkCmdClearColorImage-pColor-parameter,Y,None,implicit,vkCmdClearColorImage,core, pColor must be a valid pointer to a valid VkClearColorValue union
VUID-vkCmdClearColorImage-pRanges-01692,Y,ClearColorImageWithBadRange,explicit,vkCmdClearColorImage,core," For each VkImageSubresourceRange element of pRanges, if the levelCount member is not VK_REMAINING_MIP_LEVELS, then baseMipLevel + levelCount must be less than the mipLevels specified in VkImageCreateInfo when image was created"
VUID-vkCmdClearColorImage-pRanges-01693,Y,ClearColorImageWithBadRange,explicit,vkCmdClearColorImage,core," For each VkImageSubresourceRange element of pRanges, if the layerCount member is not VK_REMAINING_ARRAY_LAYERS, then baseArrayLayer + layerCount must be less than the arrayLayers specified in VkImageCreateInfo when image was created"
VUID-vkCmdClearColorImage-pRanges-parameter,Y,None,implicit,vkCmdClearColorImage,core, pRanges must be a valid pointer to an array of rangeCount valid VkImageSubresourceRange structures
VUID-vkCmdClearColorImage-rangeCount-arraylength,Y,None,implicit,vkCmdClearColorImage,core, rangeCount must be greater than 0
VUID-vkCmdClearColorImage-renderpass,Y,None,implicit,vkCmdClearColorImage,core, This command must only be called outside of a render pass instance
VUID-vkCmdClearDepthStencilImage-baseArrayLayer-01476,Y,ClearDepthStencilWithBadRange,explicit,vkCmdClearDepthStencilImage,core, The VkImageSubresourceRange::baseArrayLayer members of the elements of the pRanges array must each be less than the arrayLayers specified in VkImageCreateInfo when image was created
VUID-vkCmdClearDepthStencilImage-baseMipLevel-01474,Y,ClearDepthStencilWithBadRange,explicit,vkCmdClearDepthStencilImage,core, The VkImageSubresourceRange::baseMipLevel members of the elements of the pRanges array must each be less than the mipLevels specified in VkImageCreateInfo when image was created
VUID-vkCmdClearDepthStencilImage-commandBuffer-01807,N,None,explicit,vkCmdClearDepthStencilImage,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, then image must not be a protected image"
VUID-vkCmdClearDepthStencilImage-commandBuffer-01808,N,None,explicit,vkCmdClearDepthStencilImage,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, then image must not be an unprotected image"
VUID-vkCmdClearDepthStencilImage-commandBuffer-cmdpool,Y,None,implicit,vkCmdClearDepthStencilImage,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdClearDepthStencilImage-commandBuffer-parameter,Y,None,implicit,vkCmdClearDepthStencilImage,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdClearDepthStencilImage-commandBuffer-recording,Y,None,implicit,vkCmdClearDepthStencilImage,core, commandBuffer must be in the recording state
VUID-vkCmdClearDepthStencilImage-commonparent,Y,None,implicit,vkCmdClearDepthStencilImage,core," Both of commandBuffer, and image must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdClearDepthStencilImage-image-00009,Y,ClearDepthStencilImageErrors,explicit,vkCmdClearDepthStencilImage,core, image must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag
VUID-vkCmdClearDepthStencilImage-image-00010,Y,None,explicit,vkCmdClearDepthStencilImage,core, If image is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdClearDepthStencilImage-image-00014,Y,None,explicit,vkCmdClearDepthStencilImage,core, image must have a depth/stencil format
VUID-vkCmdClearDepthStencilImage-image-01994,Y,None,explicit,vkCmdClearDepthStencilImage,"(VK_VERSION_1_1,VK_KHR_maintenance1)", The format features of image must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT.
VUID-vkCmdClearDepthStencilImage-image-parameter,Y,None,implicit,vkCmdClearDepthStencilImage,core, image must be a valid VkImage handle
VUID-vkCmdClearDepthStencilImage-imageLayout-00011,Y,InvalidImageLayout,explicit,vkCmdClearDepthStencilImage,core, imageLayout must specify the layout of the image subresource ranges of image specified in pRanges at the time this command is executed on a VkDevice
VUID-vkCmdClearDepthStencilImage-imageLayout-00012,Y,InvalidImageLayout,explicit,vkCmdClearDepthStencilImage,core, imageLayout must be either of VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL
VUID-vkCmdClearDepthStencilImage-imageLayout-parameter,Y,None,implicit,vkCmdClearDepthStencilImage,core, imageLayout must be a valid VkImageLayout value
VUID-vkCmdClearDepthStencilImage-pDepthStencil-parameter,Y,None,implicit,vkCmdClearDepthStencilImage,core, pDepthStencil must be a valid pointer to a valid VkClearDepthStencilValue structure
VUID-vkCmdClearDepthStencilImage-pRanges-01694,Y,ClearDepthStencilWithBadRange,explicit,vkCmdClearDepthStencilImage,core," For each VkImageSubresourceRange element of pRanges, if the levelCount member is not VK_REMAINING_MIP_LEVELS, then baseMipLevel + levelCount must be less than the mipLevels specified in VkImageCreateInfo when image was created"
VUID-vkCmdClearDepthStencilImage-pRanges-01695,Y,ClearDepthStencilWithBadRange,explicit,vkCmdClearDepthStencilImage,core," For each VkImageSubresourceRange element of pRanges, if the layerCount member is not VK_REMAINING_ARRAY_LAYERS, then baseArrayLayer + layerCount must be less than the arrayLayers specified in VkImageCreateInfo when image was created"
VUID-vkCmdClearDepthStencilImage-pRanges-parameter,Y,None,implicit,vkCmdClearDepthStencilImage,core, pRanges must be a valid pointer to an array of rangeCount valid VkImageSubresourceRange structures
VUID-vkCmdClearDepthStencilImage-rangeCount-arraylength,Y,None,implicit,vkCmdClearDepthStencilImage,core, rangeCount must be greater than 0
VUID-vkCmdClearDepthStencilImage-renderpass,Y,ClearDepthStencilImageErrors,implicit,vkCmdClearDepthStencilImage,core, This command must only be called outside of a render pass instance
VUID-vkCmdCopyAccelerationStructureNVX-cmdBuf-parameter,Y,None,implicit,vkCmdCopyAccelerationStructureNVX,(VK_NVX_raytracing), cmdBuf must be a valid VkCommandBuffer handle
VUID-vkCmdCopyAccelerationStructureNVX-commandBuffer-cmdpool,N,None,implicit,vkCmdCopyAccelerationStructureNVX,(VK_NVX_raytracing)," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdCopyAccelerationStructureNVX-commandBuffer-recording,N,None,implicit,vkCmdCopyAccelerationStructureNVX,(VK_NVX_raytracing), commandBuffer must be in the recording state
VUID-vkCmdCopyAccelerationStructureNVX-commonparent,Y,None,implicit,vkCmdCopyAccelerationStructureNVX,(VK_NVX_raytracing)," Each of cmdBuf, dst, and src must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdCopyAccelerationStructureNVX-dst-parameter,Y,None,implicit,vkCmdCopyAccelerationStructureNVX,(VK_NVX_raytracing), dst must be a valid VkAccelerationStructureNVX handle
VUID-vkCmdCopyAccelerationStructureNVX-mode-parameter,Y,None,implicit,vkCmdCopyAccelerationStructureNVX,(VK_NVX_raytracing), mode must be a valid VkCopyAccelerationStructureModeNVX value
VUID-vkCmdCopyAccelerationStructureNVX-src-parameter,Y,None,implicit,vkCmdCopyAccelerationStructureNVX,(VK_NVX_raytracing), src must be a valid VkAccelerationStructureNVX handle
VUID-vkCmdCopyBuffer-commandBuffer-01822,N,None,explicit,vkCmdCopyBuffer,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, then srcBuffer must not be a protected buffer"
VUID-vkCmdCopyBuffer-commandBuffer-01823,N,None,explicit,vkCmdCopyBuffer,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, then dstBuffer must not be a protected buffer"
VUID-vkCmdCopyBuffer-commandBuffer-01824,N,None,explicit,vkCmdCopyBuffer,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, then dstBuffer must not be an unprotected buffer"
VUID-vkCmdCopyBuffer-commandBuffer-cmdpool,Y,None,implicit,vkCmdCopyBuffer,core," The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations"
VUID-vkCmdCopyBuffer-commandBuffer-parameter,Y,None,implicit,vkCmdCopyBuffer,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdCopyBuffer-commandBuffer-recording,Y,None,implicit,vkCmdCopyBuffer,core, commandBuffer must be in the recording state
VUID-vkCmdCopyBuffer-commonparent,Y,None,implicit,vkCmdCopyBuffer,core," Each of commandBuffer, dstBuffer, and srcBuffer must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdCopyBuffer-dstBuffer-00120,Y,None,explicit,vkCmdCopyBuffer,core, dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag
VUID-vkCmdCopyBuffer-dstBuffer-00121,Y,None,explicit,vkCmdCopyBuffer,core, If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdCopyBuffer-dstBuffer-parameter,Y,None,implicit,vkCmdCopyBuffer,core, dstBuffer must be a valid VkBuffer handle
VUID-vkCmdCopyBuffer-dstOffset-00114,N,None,explicit,vkCmdCopyBuffer,core, The dstOffset member of each element of pRegions must be less than the size of dstBuffer
VUID-vkCmdCopyBuffer-pRegions-00117,N,None,explicit,vkCmdCopyBuffer,core," The union of the source regions, and the union of the destination regions, specified by the elements of pRegions, must not overlap in memory"
VUID-vkCmdCopyBuffer-pRegions-parameter,Y,None,implicit,vkCmdCopyBuffer,core, pRegions must be a valid pointer to an array of regionCount valid VkBufferCopy structures
VUID-vkCmdCopyBuffer-regionCount-arraylength,Y,None,implicit,vkCmdCopyBuffer,core, regionCount must be greater than 0
VUID-vkCmdCopyBuffer-renderpass,Y,None,implicit,vkCmdCopyBuffer,core, This command must only be called outside of a render pass instance
VUID-vkCmdCopyBuffer-size-00115,N,None,explicit,vkCmdCopyBuffer,core, The size member of each element of pRegions must be less than or equal to the size of srcBuffer minus srcOffset
VUID-vkCmdCopyBuffer-size-00116,N,None,explicit,vkCmdCopyBuffer,core, The size member of each element of pRegions must be less than or equal to the size of dstBuffer minus dstOffset
VUID-vkCmdCopyBuffer-srcBuffer-00118,Y,None,explicit,vkCmdCopyBuffer,core, srcBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_SRC_BIT usage flag
VUID-vkCmdCopyBuffer-srcBuffer-00119,Y,None,explicit,vkCmdCopyBuffer,core, If srcBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdCopyBuffer-srcBuffer-parameter,Y,None,implicit,vkCmdCopyBuffer,core, srcBuffer must be a valid VkBuffer handle
VUID-vkCmdCopyBuffer-srcOffset-00113,N,None,explicit,vkCmdCopyBuffer,core, The srcOffset member of each element of pRegions must be less than the size of srcBuffer
VUID-vkCmdCopyBufferToImage-commandBuffer-01828,N,None,explicit,vkCmdCopyBufferToImage,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, then srcBuffer must not be a protected buffer"
VUID-vkCmdCopyBufferToImage-commandBuffer-01829,N,None,explicit,vkCmdCopyBufferToImage,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, then dstImage must not be a protected image"
VUID-vkCmdCopyBufferToImage-commandBuffer-01830,N,None,explicit,vkCmdCopyBufferToImage,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, then dstImage must not be an unprotected image"
VUID-vkCmdCopyBufferToImage-commandBuffer-cmdpool,Y,None,implicit,vkCmdCopyBufferToImage,core," The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations"
VUID-vkCmdCopyBufferToImage-commandBuffer-parameter,Y,None,implicit,vkCmdCopyBufferToImage,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdCopyBufferToImage-commandBuffer-recording,Y,ImageBufferCopyTests,implicit,vkCmdCopyBufferToImage,core, commandBuffer must be in the recording state
VUID-vkCmdCopyBufferToImage-commonparent,Y,None,implicit,vkCmdCopyBufferToImage,core," Each of commandBuffer, dstImage, and srcBuffer must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdCopyBufferToImage-dstImage-00177,Y,InvalidUsageBits,explicit,vkCmdCopyBufferToImage,core, dstImage must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag
VUID-vkCmdCopyBufferToImage-dstImage-00178,Y,None,explicit,vkCmdCopyBufferToImage,core, If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdCopyBufferToImage-dstImage-00179,Y,None,explicit,vkCmdCopyBufferToImage,core, dstImage must have a sample count equal to VK_SAMPLE_COUNT_1_BIT
VUID-vkCmdCopyBufferToImage-dstImage-01997,Y,None,explicit,vkCmdCopyBufferToImage,"(VK_VERSION_1_1,VK_KHR_maintenance1)", The format features of dstImage must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT.
VUID-vkCmdCopyBufferToImage-dstImage-parameter,Y,None,implicit,vkCmdCopyBufferToImage,core, dstImage must be a valid VkImage handle
VUID-vkCmdCopyBufferToImage-dstImageLayout-00180,Y,ImageBufferCopyTests,explicit,vkCmdCopyBufferToImage,core, dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice
VUID-vkCmdCopyBufferToImage-dstImageLayout-00181,Y,None,explicit,vkCmdCopyBufferToImage,!(VK_KHR_shared_presentable_image), dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL
VUID-vkCmdCopyBufferToImage-dstImageLayout-01396,Y,None,explicit,vkCmdCopyBufferToImage,(VK_KHR_shared_presentable_image)," dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"
VUID-vkCmdCopyBufferToImage-dstImageLayout-parameter,Y,None,implicit,vkCmdCopyBufferToImage,core, dstImageLayout must be a valid VkImageLayout value
VUID-vkCmdCopyBufferToImage-imageOffset-01793,Y,"MinImageTransferGranularity, CompressedImageMipCopyTests",explicit,vkCmdCopyBufferToImage,core," The imageOffset and imageExtent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer's command pool's queue family, as described in VkQueueFamilyProperties"
VUID-vkCmdCopyBufferToImage-imageSubresource-01701,Y,ImageBufferCopyTests,explicit,vkCmdCopyBufferToImage,core, The imageSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created
VUID-vkCmdCopyBufferToImage-imageSubresource-01702,Y,ImageBufferCopyTests,explicit,vkCmdCopyBufferToImage,core, The imageSubresource.baseArrayLayer + imageSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created
VUID-vkCmdCopyBufferToImage-pRegions-00171,Y,"ImageBufferCopyTests, CompressedImageMipCopyTests",explicit,vkCmdCopyBufferToImage,core," srcBuffer must be large enough to contain all buffer locations that are accessed according to Buffer and Image Addressing, for each element of pRegions"
VUID-vkCmdCopyBufferToImage-pRegions-00172,Y,"ImageBufferCopyTests, MiscImageLayerTests",explicit,vkCmdCopyBufferToImage,core, The image region specified by each element of pRegions must be a region that is contained within dstImage
VUID-vkCmdCopyBufferToImage-pRegions-00173,N,None,explicit,vkCmdCopyBufferToImage,core," The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory"
VUID-vkCmdCopyBufferToImage-pRegions-parameter,Y,None,implicit,vkCmdCopyBufferToImage,core, pRegions must be a valid pointer to an array of regionCount valid VkBufferImageCopy structures
VUID-vkCmdCopyBufferToImage-regionCount-arraylength,Y,None,implicit,vkCmdCopyBufferToImage,core, regionCount must be greater than 0
VUID-vkCmdCopyBufferToImage-renderpass,Y,None,implicit,vkCmdCopyBufferToImage,core, This command must only be called outside of a render pass instance
VUID-vkCmdCopyBufferToImage-srcBuffer-00174,Y,InvalidUsageBits,explicit,vkCmdCopyBufferToImage,core, srcBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_SRC_BIT usage flag
VUID-vkCmdCopyBufferToImage-srcBuffer-00176,Y,None,explicit,vkCmdCopyBufferToImage,core, If srcBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdCopyBufferToImage-srcBuffer-parameter,Y,None,implicit,vkCmdCopyBufferToImage,core, srcBuffer must be a valid VkBuffer handle
VUID-vkCmdCopyImage-None-01549,N,None,explicit,vkCmdCopyImage,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," In a copy to or from a plane of a multi-planar image, the VkFormat of the image and plane must be compatible according to the description of compatible planes for the plane being copied"
VUID-vkCmdCopyImage-aspectMask-01550,N,None,explicit,vkCmdCopyImage,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," When a copy is performed to or from an image with a multi-planar format, the aspectMask of the srcSubresource and/or dstSubresource that refers to the multi-planar image must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT (with VK_IMAGE_ASPECT_PLANE_2_BIT valid only for a VkFormat with three planes)"
VUID-vkCmdCopyImage-commandBuffer-01825,N,None,explicit,vkCmdCopyImage,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, then srcImage must not be a protected image"
VUID-vkCmdCopyImage-commandBuffer-01826,N,None,explicit,vkCmdCopyImage,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, then dstImage must not be a protected image"
VUID-vkCmdCopyImage-commandBuffer-01827,N,None,explicit,vkCmdCopyImage,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, then dstImage must not be an unprotected image"
VUID-vkCmdCopyImage-commandBuffer-cmdpool,Y,None,implicit,vkCmdCopyImage,core," The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations"
VUID-vkCmdCopyImage-commandBuffer-parameter,Y,None,implicit,vkCmdCopyImage,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdCopyImage-commandBuffer-recording,Y,CopyImageAspectMismatch,implicit,vkCmdCopyImage,core, commandBuffer must be in the recording state
VUID-vkCmdCopyImage-commonparent,Y,None,implicit,vkCmdCopyImage,core," Each of commandBuffer, dstImage, and srcImage must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdCopyImage-dstImage-00131,Y,None,explicit,vkCmdCopyImage,core, dstImage must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag
VUID-vkCmdCopyImage-dstImage-00132,Y,None,explicit,vkCmdCopyImage,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdCopyImage-dstImage-01547,N,None,explicit,vkCmdCopyImage,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", If dstImage is non-sparse then the image or disjoint plane that is the destination of the copy must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdCopyImage-dstImage-01996,Y,None,explicit,vkCmdCopyImage,"(VK_VERSION_1_1,VK_KHR_maintenance1)", The format features of dstImage must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT.
VUID-vkCmdCopyImage-dstImage-parameter,Y,None,implicit,vkCmdCopyImage,core, dstImage must be a valid VkImage handle
VUID-vkCmdCopyImage-dstImageLayout-00133,Y,InvalidImageLayout,explicit,vkCmdCopyImage,core, dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice
VUID-vkCmdCopyImage-dstImageLayout-00134,Y,InvalidImageLayout,explicit,vkCmdCopyImage,!(VK_KHR_shared_presentable_image), dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL
VUID-vkCmdCopyImage-dstImageLayout-01395,Y,None,explicit,vkCmdCopyImage,(VK_KHR_shared_presentable_image)," dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"
VUID-vkCmdCopyImage-dstImageLayout-parameter,Y,None,implicit,vkCmdCopyImage,core, dstImageLayout must be a valid VkImageLayout value
VUID-vkCmdCopyImage-dstOffset-01784,Y,"CopyImageCompressedBlockAlignment, MinImageTransferGranularity",explicit,vkCmdCopyImage,core," The dstOffset and extent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer's command pool's queue family, as described in VkQueueFamilyProperties"
VUID-vkCmdCopyImage-dstSubresource-01697,Y,None,explicit,vkCmdCopyImage,core, The dstSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created
VUID-vkCmdCopyImage-dstSubresource-01699,Y,CopyImageTypeExtentMismatchMaintenance1,explicit,vkCmdCopyImage,core, The dstSubresource.baseArrayLayer + dstSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created
VUID-vkCmdCopyImage-pRegions-00122,Y,CopyImageSrcSizeExceeded,explicit,vkCmdCopyImage,core, The source region specified by each element of pRegions must be a region that is contained within srcImage
VUID-vkCmdCopyImage-pRegions-00123,Y,CopyImageDstSizeExceeded,explicit,vkCmdCopyImage,core, The destination region specified by each element of pRegions must be a region that is contained within dstImage
VUID-vkCmdCopyImage-pRegions-00124,Y,None,explicit,vkCmdCopyImage,core," The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory"
VUID-vkCmdCopyImage-pRegions-parameter,Y,None,implicit,vkCmdCopyImage,core, pRegions must be a valid pointer to an array of regionCount valid VkImageCopy structures
VUID-vkCmdCopyImage-regionCount-arraylength,Y,None,implicit,vkCmdCopyImage,core, regionCount must be greater than 0
VUID-vkCmdCopyImage-renderpass,Y,None,implicit,vkCmdCopyImage,core, This command must only be called outside of a render pass instance
VUID-vkCmdCopyImage-srcImage-00126,Y,None,explicit,vkCmdCopyImage,core, srcImage must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag
VUID-vkCmdCopyImage-srcImage-00127,Y,None,explicit,vkCmdCopyImage,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", If srcImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdCopyImage-srcImage-00135,Y,CopyImageFormatSizeMismatch,explicit,vkCmdCopyImage,"!(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," The VkFormat of each of srcImage and dstImage must be compatible, as defined below"
VUID-vkCmdCopyImage-srcImage-00136,Y,CopyImageSampleCountMismatch,explicit,vkCmdCopyImage,core, The sample count of srcImage and dstImage must match
VUID-vkCmdCopyImage-srcImage-01546,N,None,explicit,vkCmdCopyImage,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", If srcImage is non-sparse then the image or disjoint plane to be copied must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdCopyImage-srcImage-01548,N,None,explicit,vkCmdCopyImage,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the VkFormat of each of srcImage and dstImage is not a multi-planar format, the VkFormat of each of srcImage and dstImage must be compatible, as defined below"
VUID-vkCmdCopyImage-srcImage-01995,Y,None,explicit,vkCmdCopyImage,"(VK_VERSION_1_1,VK_KHR_maintenance1)", The format features of srcImage must contain VK_FORMAT_FEATURE_TRANSFER_SRC_BIT.
VUID-vkCmdCopyImage-srcImage-parameter,Y,None,implicit,vkCmdCopyImage,core, srcImage must be a valid VkImage handle
VUID-vkCmdCopyImage-srcImageLayout-00128,Y,InvalidImageLayout,explicit,vkCmdCopyImage,core, srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice
VUID-vkCmdCopyImage-srcImageLayout-00129,Y,InvalidImageLayout,explicit,vkCmdCopyImage,!(VK_KHR_shared_presentable_image), srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL
VUID-vkCmdCopyImage-srcImageLayout-01917,Y,None,explicit,vkCmdCopyImage,(VK_KHR_shared_presentable_image)," srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"
VUID-vkCmdCopyImage-srcImageLayout-parameter,Y,None,implicit,vkCmdCopyImage,core, srcImageLayout must be a valid VkImageLayout value
VUID-vkCmdCopyImage-srcOffset-01783,Y,"CopyImageCompressedBlockAlignment, MinImageTransferGranularity",explicit,vkCmdCopyImage,core," The srcOffset and extent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer's command pool's queue family, as described in VkQueueFamilyProperties"
VUID-vkCmdCopyImage-srcSubresource-01696,Y,None,explicit,vkCmdCopyImage,core, The srcSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created
VUID-vkCmdCopyImage-srcSubresource-01698,Y,"CopyImageTypeExtentMismatchMaintenance1, CopyImageTypeExtentMismatch",explicit,vkCmdCopyImage,core, The srcSubresource.baseArrayLayer + srcSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created
VUID-vkCmdCopyImageToBuffer-commandBuffer-01831,N,None,explicit,vkCmdCopyImageToBuffer,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, then srcImage must not be a protected image"
VUID-vkCmdCopyImageToBuffer-commandBuffer-01832,N,None,explicit,vkCmdCopyImageToBuffer,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, then dstBuffer must not be a protected buffer"
VUID-vkCmdCopyImageToBuffer-commandBuffer-01833,N,None,explicit,vkCmdCopyImageToBuffer,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, then dstBuffer must not be an unprotected buffer"
VUID-vkCmdCopyImageToBuffer-commandBuffer-cmdpool,Y,None,implicit,vkCmdCopyImageToBuffer,core," The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations"
VUID-vkCmdCopyImageToBuffer-commandBuffer-parameter,Y,None,implicit,vkCmdCopyImageToBuffer,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdCopyImageToBuffer-commandBuffer-recording,Y,ImageBufferCopyTests,implicit,vkCmdCopyImageToBuffer,core, commandBuffer must be in the recording state
VUID-vkCmdCopyImageToBuffer-commonparent,Y,None,implicit,vkCmdCopyImageToBuffer,core," Each of commandBuffer, dstBuffer, and srcImage must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdCopyImageToBuffer-dstBuffer-00191,Y,None,explicit,vkCmdCopyImageToBuffer,core, dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag
VUID-vkCmdCopyImageToBuffer-dstBuffer-00192,Y,None,explicit,vkCmdCopyImageToBuffer,core, If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdCopyImageToBuffer-dstBuffer-parameter,Y,None,implicit,vkCmdCopyImageToBuffer,core, dstBuffer must be a valid VkBuffer handle
VUID-vkCmdCopyImageToBuffer-imageOffset-01794,Y,"ImageBufferCopyTests, MinImageTransferGranularity, CompressedImageMipCopyTests",explicit,vkCmdCopyImageToBuffer,core," The imageOffset and imageExtent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer's command pool's queue family, as described in VkQueueFamilyProperties"
VUID-vkCmdCopyImageToBuffer-imageSubresource-01703,Y,ImageBufferCopyTests,explicit,vkCmdCopyImageToBuffer,core, The imageSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created
VUID-vkCmdCopyImageToBuffer-imageSubresource-01704,Y,ImageBufferCopyTests,explicit,vkCmdCopyImageToBuffer,core, The imageSubresource.baseArrayLayer + imageSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created
VUID-vkCmdCopyImageToBuffer-pRegions-00182,Y,ImageBufferCopyTests,explicit,vkCmdCopyImageToBuffer,core, The image region specified by each element of pRegions must be a region that is contained within srcImage
VUID-vkCmdCopyImageToBuffer-pRegions-00183,Y,"ImageBufferCopyTests, CompressedImageMipCopyTests",explicit,vkCmdCopyImageToBuffer,core," dstBuffer must be large enough to contain all buffer locations that are accessed according to Buffer and Image Addressing, for each element of pRegions"
VUID-vkCmdCopyImageToBuffer-pRegions-00184,N,None,explicit,vkCmdCopyImageToBuffer,core," The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory"
VUID-vkCmdCopyImageToBuffer-pRegions-parameter,Y,None,implicit,vkCmdCopyImageToBuffer,core, pRegions must be a valid pointer to an array of regionCount valid VkBufferImageCopy structures
VUID-vkCmdCopyImageToBuffer-regionCount-arraylength,Y,None,implicit,vkCmdCopyImageToBuffer,core, regionCount must be greater than 0
VUID-vkCmdCopyImageToBuffer-renderpass,Y,None,implicit,vkCmdCopyImageToBuffer,core, This command must only be called outside of a render pass instance
VUID-vkCmdCopyImageToBuffer-srcImage-00186,Y,None,explicit,vkCmdCopyImageToBuffer,core, srcImage must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag
VUID-vkCmdCopyImageToBuffer-srcImage-00187,Y,None,explicit,vkCmdCopyImageToBuffer,core, If srcImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdCopyImageToBuffer-srcImage-00188,Y,None,explicit,vkCmdCopyImageToBuffer,core, srcImage must have a sample count equal to VK_SAMPLE_COUNT_1_BIT
VUID-vkCmdCopyImageToBuffer-srcImage-01998,Y,None,explicit,vkCmdCopyImageToBuffer,"(VK_VERSION_1_1,VK_KHR_maintenance1)", The format features of srcImage must contain VK_FORMAT_FEATURE_TRANSFER_SRC_BIT.
VUID-vkCmdCopyImageToBuffer-srcImage-parameter,Y,None,implicit,vkCmdCopyImageToBuffer,core, srcImage must be a valid VkImage handle
VUID-vkCmdCopyImageToBuffer-srcImageLayout-00189,Y,ImageBufferCopyTests,explicit,vkCmdCopyImageToBuffer,core, srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice
VUID-vkCmdCopyImageToBuffer-srcImageLayout-00190,Y,None,explicit,vkCmdCopyImageToBuffer,!(VK_KHR_shared_presentable_image), srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL
VUID-vkCmdCopyImageToBuffer-srcImageLayout-01397,Y,None,explicit,vkCmdCopyImageToBuffer,(VK_KHR_shared_presentable_image)," srcImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL"
VUID-vkCmdCopyImageToBuffer-srcImageLayout-parameter,Y,None,implicit,vkCmdCopyImageToBuffer,core, srcImageLayout must be a valid VkImageLayout value
VUID-vkCmdCopyQueryPoolResults-commandBuffer-cmdpool,Y,None,implicit,vkCmdCopyQueryPoolResults,core," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdCopyQueryPoolResults-commandBuffer-parameter,Y,None,implicit,vkCmdCopyQueryPoolResults,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdCopyQueryPoolResults-commandBuffer-recording,Y,None,implicit,vkCmdCopyQueryPoolResults,core, commandBuffer must be in the recording state
VUID-vkCmdCopyQueryPoolResults-commonparent,Y,None,implicit,vkCmdCopyQueryPoolResults,core," Each of commandBuffer, dstBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdCopyQueryPoolResults-dstBuffer-00824,N,None,explicit,vkCmdCopyQueryPoolResults,core," dstBuffer must have enough storage, from dstOffset, to contain the result of each query, as described here"
VUID-vkCmdCopyQueryPoolResults-dstBuffer-00825,Y,None,explicit,vkCmdCopyQueryPoolResults,core, dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag
VUID-vkCmdCopyQueryPoolResults-dstBuffer-00826,Y,None,explicit,vkCmdCopyQueryPoolResults,core, If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdCopyQueryPoolResults-dstBuffer-parameter,Y,None,implicit,vkCmdCopyQueryPoolResults,core, dstBuffer must be a valid VkBuffer handle
VUID-vkCmdCopyQueryPoolResults-dstOffset-00819,N,None,explicit,vkCmdCopyQueryPoolResults,core, dstOffset must be less than the size of dstBuffer
VUID-vkCmdCopyQueryPoolResults-firstQuery-00820,N,None,explicit,vkCmdCopyQueryPoolResults,core, firstQuery must be less than the number of queries in queryPool
VUID-vkCmdCopyQueryPoolResults-firstQuery-00821,N,None,explicit,vkCmdCopyQueryPoolResults,core, The sum of firstQuery and queryCount must be less than or equal to the number of queries in queryPool
VUID-vkCmdCopyQueryPoolResults-flags-00822,N,None,explicit,vkCmdCopyQueryPoolResults,core, If VK_QUERY_RESULT_64_BIT is not set in flags then dstOffset and stride must be multiples of 4
VUID-vkCmdCopyQueryPoolResults-flags-00823,N,None,explicit,vkCmdCopyQueryPoolResults,core, If VK_QUERY_RESULT_64_BIT is set in flags then dstOffset and stride must be multiples of 8
VUID-vkCmdCopyQueryPoolResults-flags-parameter,Y,None,implicit,vkCmdCopyQueryPoolResults,core, flags must be a valid combination of VkQueryResultFlagBits values
VUID-vkCmdCopyQueryPoolResults-queryPool-parameter,Y,None,implicit,vkCmdCopyQueryPoolResults,core, queryPool must be a valid VkQueryPool handle
VUID-vkCmdCopyQueryPoolResults-queryType-00827,N,None,explicit,vkCmdCopyQueryPoolResults,core," If the queryType used to create queryPool was VK_QUERY_TYPE_TIMESTAMP, flags must not contain VK_QUERY_RESULT_PARTIAL_BIT"
VUID-vkCmdCopyQueryPoolResults-renderpass,Y,None,implicit,vkCmdCopyQueryPoolResults,core, This command must only be called outside of a render pass instance
VUID-vkCmdDebugMarkerBeginEXT-commandBuffer-cmdpool,N,None,implicit,vkCmdDebugMarkerBeginEXT,(VK_EXT_debug_marker)," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdDebugMarkerBeginEXT-commandBuffer-parameter,Y,None,implicit,vkCmdDebugMarkerBeginEXT,(VK_EXT_debug_marker), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdDebugMarkerBeginEXT-commandBuffer-recording,Y,None,implicit,vkCmdDebugMarkerBeginEXT,(VK_EXT_debug_marker), commandBuffer must be in the recording state
VUID-vkCmdDebugMarkerBeginEXT-pMarkerInfo-parameter,Y,None,implicit,vkCmdDebugMarkerBeginEXT,(VK_EXT_debug_marker), pMarkerInfo must be a valid pointer to a valid VkDebugMarkerMarkerInfoEXT structure
VUID-vkCmdDebugMarkerEndEXT-commandBuffer-01239,N,None,explicit,vkCmdDebugMarkerEndEXT,(VK_EXT_debug_marker), There must be an outstanding vkCmdDebugMarkerBeginEXT command prior to the vkCmdDebugMarkerEndEXT on the queue that commandBuffer is submitted to
VUID-vkCmdDebugMarkerEndEXT-commandBuffer-01240,N,None,explicit,vkCmdDebugMarkerEndEXT,(VK_EXT_debug_marker)," If commandBuffer is a secondary command buffer, there must be an outstanding vkCmdDebugMarkerBeginEXT command recorded to commandBuffer that has not previously been ended by a call to vkCmdDebugMarkerEndEXT."
VUID-vkCmdDebugMarkerEndEXT-commandBuffer-cmdpool,N,None,implicit,vkCmdDebugMarkerEndEXT,(VK_EXT_debug_marker)," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdDebugMarkerEndEXT-commandBuffer-parameter,Y,None,implicit,vkCmdDebugMarkerEndEXT,(VK_EXT_debug_marker), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdDebugMarkerEndEXT-commandBuffer-recording,Y,None,implicit,vkCmdDebugMarkerEndEXT,(VK_EXT_debug_marker), commandBuffer must be in the recording state
VUID-vkCmdDebugMarkerInsertEXT-commandBuffer-cmdpool,N,None,implicit,vkCmdDebugMarkerInsertEXT,(VK_EXT_debug_marker)," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdDebugMarkerInsertEXT-commandBuffer-parameter,Y,None,implicit,vkCmdDebugMarkerInsertEXT,(VK_EXT_debug_marker), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdDebugMarkerInsertEXT-commandBuffer-recording,Y,None,implicit,vkCmdDebugMarkerInsertEXT,(VK_EXT_debug_marker), commandBuffer must be in the recording state
VUID-vkCmdDebugMarkerInsertEXT-pMarkerInfo-parameter,Y,None,implicit,vkCmdDebugMarkerInsertEXT,(VK_EXT_debug_marker), pMarkerInfo must be a valid pointer to a valid VkDebugMarkerMarkerInfoEXT structure
VUID-vkCmdDispatch-None-00389,N,None,explicit,vkCmdDispatch,core," For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_COMPUTE, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDispatch-None-00390,N,None,explicit,vkCmdDispatch,core," Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline"
VUID-vkCmdDispatch-None-00391,Y,InvalidPipeline,explicit,vkCmdDispatch,core, A valid compute pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_COMPUTE
VUID-vkCmdDispatch-None-00392,N,None,explicit,vkCmdDispatch,core," For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE, a push constant value must have been set for VK_PIPELINE_BIND_POINT_COMPUTE, with a VkPipelineLayout that is compatible for push constants with the one used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDispatch-None-00393,N,None,explicit,vkCmdDispatch,core," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage"
VUID-vkCmdDispatch-None-00394,N,None,explicit,vkCmdDispatch,core," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage"
VUID-vkCmdDispatch-None-00395,N,None,explicit,vkCmdDispatch,core," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage"
VUID-vkCmdDispatch-None-00396,N,None,explicit,vkCmdDispatch,core," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDispatch-None-00397,N,None,explicit,vkCmdDispatch,core," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDispatch-None-00400,N,None,explicit,vkCmdDispatch,(VK_IMG_filter_cubic)," Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"
VUID-vkCmdDispatch-None-02005,N,None,explicit,vkCmdDispatch,core," If a VkImageView is sampled with with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT."
VUID-vkCmdDispatch-None-02006,N,None,explicit,vkCmdDispatch,(VK_IMG_filter_cubic)," If a VkImageView is sampled with with VK_FILTER_CUBIC_IMG as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG."
VUID-vkCmdDispatch-commandBuffer-01844,N,None,explicit,vkCmdDispatch,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDispatch-commandBuffer-01845,N,None,explicit,vkCmdDispatch,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_POINT_COMPUTE writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer."
VUID-vkCmdDispatch-commandBuffer-01846,N,None,explicit,vkCmdDispatch,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage other than the compute pipeline stage in the VkPipeline object bound to VK_PIPELINE_POINT_COMPUTE reads from any image or buffer, the image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDispatch-commandBuffer-cmdpool,Y,None,implicit,vkCmdDispatch,core, The VkCommandPool that commandBuffer was allocated from must support compute operations
VUID-vkCmdDispatch-commandBuffer-parameter,Y,None,implicit,vkCmdDispatch,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdDispatch-commandBuffer-recording,Y,None,implicit,vkCmdDispatch,core, commandBuffer must be in the recording state
VUID-vkCmdDispatch-flags-02040,N,None,explicit,vkCmdDispatch,(VK_NV_corner_sampled_image), Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
VUID-vkCmdDispatch-groupCountX-00386,Y,CmdDispatchExceedLimits,explicit,vkCmdDispatch,core, groupCountX must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0]
VUID-vkCmdDispatch-groupCountY-00387,Y,CmdDispatchExceedLimits,explicit,vkCmdDispatch,core, groupCountY must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1]
VUID-vkCmdDispatch-groupCountZ-00388,Y,CmdDispatchExceedLimits,explicit,vkCmdDispatch,core, groupCountZ must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2]
VUID-vkCmdDispatch-renderpass,Y,None,implicit,vkCmdDispatch,core, This command must only be called outside of a render pass instance
VUID-vkCmdDispatchBase-None-00420,N,None,explicit,vkCmdDispatchBase,"(VK_VERSION_1_1,VK_KHR_device_group)", All valid usage rules from vkCmdDispatch apply
VUID-vkCmdDispatchBase-baseGroupX-00421,Y,CmdDispatchExceedLimits,explicit,vkCmdDispatchBase,"(VK_VERSION_1_1,VK_KHR_device_group)", baseGroupX must be less than VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0]
VUID-vkCmdDispatchBase-baseGroupX-00422,Y,CmdDispatchExceedLimits,explicit,vkCmdDispatchBase,"(VK_VERSION_1_1,VK_KHR_device_group)", baseGroupX must be less than VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1]
VUID-vkCmdDispatchBase-baseGroupX-00427,N,None,explicit,vkCmdDispatchBase,"(VK_VERSION_1_1,VK_KHR_device_group)"," If any of baseGroupX, baseGroupY, or baseGroupZ are not zero, then the bound compute pipeline must have been created with the VK_PIPELINE_CREATE_DISPATCH_BASE flag."
VUID-vkCmdDispatchBase-baseGroupZ-00423,Y,CmdDispatchExceedLimits,explicit,vkCmdDispatchBase,"(VK_VERSION_1_1,VK_KHR_device_group)", baseGroupZ must be less than VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2]
VUID-vkCmdDispatchBase-commandBuffer-cmdpool,N,None,implicit,vkCmdDispatchBase,"(VK_VERSION_1_1,VK_KHR_device_group)", The VkCommandPool that commandBuffer was allocated from must support compute operations
VUID-vkCmdDispatchBase-commandBuffer-parameter,Y,None,implicit,vkCmdDispatchBase,"(VK_VERSION_1_1,VK_KHR_device_group)", commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdDispatchBase-commandBuffer-recording,N,None,implicit,vkCmdDispatchBase,"(VK_VERSION_1_1,VK_KHR_device_group)", commandBuffer must be in the recording state
VUID-vkCmdDispatchBase-groupCountX-00424,Y,CmdDispatchExceedLimits,explicit,vkCmdDispatchBase,"(VK_VERSION_1_1,VK_KHR_device_group)", groupCountX must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0] minus baseGroupX
VUID-vkCmdDispatchBase-groupCountY-00425,Y,CmdDispatchExceedLimits,explicit,vkCmdDispatchBase,"(VK_VERSION_1_1,VK_KHR_device_group)", groupCountY must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1] minus baseGroupY
VUID-vkCmdDispatchBase-groupCountZ-00426,Y,CmdDispatchExceedLimits,explicit,vkCmdDispatchBase,"(VK_VERSION_1_1,VK_KHR_device_group)", groupCountZ must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2] minus baseGroupZ
VUID-vkCmdDispatchBase-renderpass,N,None,implicit,vkCmdDispatchBase,"(VK_VERSION_1_1,VK_KHR_device_group)", This command must only be called outside of a render pass instance
VUID-vkCmdDispatchIndirect-None-00402,N,None,explicit,vkCmdDispatchIndirect,core," For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_COMPUTE, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDispatchIndirect-None-00403,N,None,explicit,vkCmdDispatchIndirect,core," Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline"
VUID-vkCmdDispatchIndirect-None-00404,Y,InvalidPipeline,explicit,vkCmdDispatchIndirect,core, A valid compute pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_COMPUTE
VUID-vkCmdDispatchIndirect-None-00408,N,None,explicit,vkCmdDispatchIndirect,core," For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE, a push constant value must have been set for VK_PIPELINE_BIND_POINT_COMPUTE, with a VkPipelineLayout that is compatible for push constants with the one used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDispatchIndirect-None-00409,N,None,explicit,vkCmdDispatchIndirect,core," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage"
VUID-vkCmdDispatchIndirect-None-00410,N,None,explicit,vkCmdDispatchIndirect,core," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage"
VUID-vkCmdDispatchIndirect-None-00411,N,None,explicit,vkCmdDispatchIndirect,core," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage"
VUID-vkCmdDispatchIndirect-None-00412,N,None,explicit,vkCmdDispatchIndirect,core," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDispatchIndirect-None-00413,N,None,explicit,vkCmdDispatchIndirect,core," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDispatchIndirect-None-00416,N,None,explicit,vkCmdDispatchIndirect,(VK_IMG_filter_cubic)," Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"
VUID-vkCmdDispatchIndirect-None-02007,N,None,explicit,vkCmdDispatchIndirect,core," If a VkImageView is sampled with with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT."
VUID-vkCmdDispatchIndirect-None-02008,N,None,explicit,vkCmdDispatchIndirect,(VK_IMG_filter_cubic)," If a VkImageView is sampled with with VK_FILTER_CUBIC_IMG as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG."
VUID-vkCmdDispatchIndirect-buffer-00401,Y,None,explicit,vkCmdDispatchIndirect,core, If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdDispatchIndirect-buffer-00405,N,None,explicit,vkCmdDispatchIndirect,core, buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
VUID-vkCmdDispatchIndirect-buffer-parameter,Y,None,implicit,vkCmdDispatchIndirect,core, buffer must be a valid VkBuffer handle
VUID-vkCmdDispatchIndirect-commandBuffer-01847,N,None,explicit,vkCmdDispatchIndirect,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDispatchIndirect-commandBuffer-01848,N,None,explicit,vkCmdDispatchIndirect,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_POINT_COMPUTE writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer."
VUID-vkCmdDispatchIndirect-commandBuffer-01849,N,None,explicit,vkCmdDispatchIndirect,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage other than the compute pipeline stage in the VkPipeline object bound to VK_PIPELINE_POINT_COMPUTE reads from any image or buffer, the image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDispatchIndirect-commandBuffer-cmdpool,Y,None,implicit,vkCmdDispatchIndirect,core, The VkCommandPool that commandBuffer was allocated from must support compute operations
VUID-vkCmdDispatchIndirect-commandBuffer-parameter,Y,None,implicit,vkCmdDispatchIndirect,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdDispatchIndirect-commandBuffer-recording,Y,None,implicit,vkCmdDispatchIndirect,core, commandBuffer must be in the recording state
VUID-vkCmdDispatchIndirect-commonparent,Y,None,implicit,vkCmdDispatchIndirect,core," Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdDispatchIndirect-flags-02041,N,None,explicit,vkCmdDispatchIndirect,(VK_NV_corner_sampled_image), Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
VUID-vkCmdDispatchIndirect-offset-00406,N,None,explicit,vkCmdDispatchIndirect,core, offset must be a multiple of 4
VUID-vkCmdDispatchIndirect-offset-00407,N,None,explicit,vkCmdDispatchIndirect,core, The sum of offset and the size of VkDispatchIndirectCommand must be less than or equal to the size of buffer
VUID-vkCmdDispatchIndirect-renderpass,Y,None,implicit,vkCmdDispatchIndirect,core, This command must only be called outside of a render pass instance
VUID-vkCmdDraw-None-00437,N,None,explicit,vkCmdDraw,core," For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDraw-None-00438,N,None,explicit,vkCmdDraw,core," For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDraw-None-00439,N,None,explicit,vkCmdDraw,core," Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline"
VUID-vkCmdDraw-None-00440,N,None,explicit,vkCmdDraw,core, All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have valid buffers bound
VUID-vkCmdDraw-None-00441,N,None,explicit,vkCmdDraw,core," For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description"
VUID-vkCmdDraw-None-00442,Y,InvalidPipeline,explicit,vkCmdDraw,core, A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
VUID-vkCmdDraw-None-00443,Y,None,explicit,vkCmdDraw,core," If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer"
VUID-vkCmdDraw-None-00444,N,None,explicit,vkCmdDraw,core, Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
VUID-vkCmdDraw-None-00445,N,None,explicit,vkCmdDraw,core," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage"
VUID-vkCmdDraw-None-00446,N,None,explicit,vkCmdDraw,core," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage"
VUID-vkCmdDraw-None-00447,N,None,explicit,vkCmdDraw,core," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage"
VUID-vkCmdDraw-None-00448,N,None,explicit,vkCmdDraw,core," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDraw-None-00449,N,None,explicit,vkCmdDraw,core," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDraw-None-00452,N,None,explicit,vkCmdDraw,(VK_IMG_filter_cubic)," Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"
VUID-vkCmdDraw-None-01499,N,None,explicit,vkCmdDraw,core, Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
VUID-vkCmdDraw-None-02009,N,None,explicit,vkCmdDraw,core," If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT."
VUID-vkCmdDraw-None-02010,N,None,explicit,vkCmdDraw,(VK_IMG_filter_cubic)," If a VkImageView is sampled with VK_FILTER_CUBIC_IMG as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG."
VUID-vkCmdDraw-commandBuffer-01850,N,None,explicit,vkCmdDraw,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDraw-commandBuffer-01851,N,None,explicit,vkCmdDraw,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer."
VUID-vkCmdDraw-commandBuffer-01852,N,None,explicit,vkCmdDraw,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDraw-commandBuffer-cmdpool,Y,None,implicit,vkCmdDraw,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdDraw-commandBuffer-parameter,Y,None,implicit,vkCmdDraw,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdDraw-commandBuffer-recording,Y,None,implicit,vkCmdDraw,core, commandBuffer must be in the recording state
VUID-vkCmdDraw-flags-02042,N,None,explicit,vkCmdDraw,(VK_NV_corner_sampled_image), Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
VUID-vkCmdDraw-maxMultiviewInstanceIndex-00453,N,None,explicit,vkCmdDraw,"(VK_VERSION_1_1,VK_KHR_multiview)"," If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex."
VUID-vkCmdDraw-renderPass-00435,Y,RenderPassIncompatible,explicit,vkCmdDraw,core, The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDraw-renderpass,Y,None,implicit,vkCmdDraw,core, This command must only be called inside of a render pass instance
VUID-vkCmdDraw-sampleLocationsEnable-01512,N,None,explicit,vkCmdDraw,(VK_EXT_sample_locations)," If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set"
VUID-vkCmdDraw-subpass-00436,Y,None,explicit,vkCmdDraw,core, The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawIndexed-None-00456,N,None,explicit,vkCmdDrawIndexed,core," For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawIndexed-None-00457,N,None,explicit,vkCmdDrawIndexed,core," For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawIndexed-None-00458,N,None,explicit,vkCmdDrawIndexed,core," Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline"
VUID-vkCmdDrawIndexed-None-00459,N,None,explicit,vkCmdDrawIndexed,core, All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have valid buffers bound
VUID-vkCmdDrawIndexed-None-00460,N,None,explicit,vkCmdDrawIndexed,core," For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description"
VUID-vkCmdDrawIndexed-None-00461,Y,InvalidPipeline,explicit,vkCmdDrawIndexed,core, A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
VUID-vkCmdDrawIndexed-None-00462,Y,None,explicit,vkCmdDrawIndexed,core," If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer"
VUID-vkCmdDrawIndexed-None-00464,N,None,explicit,vkCmdDrawIndexed,core, Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
VUID-vkCmdDrawIndexed-None-00465,N,None,explicit,vkCmdDrawIndexed,core," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage"
VUID-vkCmdDrawIndexed-None-00466,N,None,explicit,vkCmdDrawIndexed,core," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage"
VUID-vkCmdDrawIndexed-None-00467,N,None,explicit,vkCmdDrawIndexed,core," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage"
VUID-vkCmdDrawIndexed-None-00468,N,None,explicit,vkCmdDrawIndexed,core," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDrawIndexed-None-00469,N,None,explicit,vkCmdDrawIndexed,core," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDrawIndexed-None-00472,N,None,explicit,vkCmdDrawIndexed,(VK_IMG_filter_cubic)," Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"
VUID-vkCmdDrawIndexed-None-01500,N,None,explicit,vkCmdDrawIndexed,core, Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
VUID-vkCmdDrawIndexed-None-02011,N,None,explicit,vkCmdDrawIndexed,core," If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT."
VUID-vkCmdDrawIndexed-None-02012,N,None,explicit,vkCmdDrawIndexed,(VK_IMG_filter_cubic)," If a VkImageView is sampled with VK_FILTER_CUBIC_IMG as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG."
VUID-vkCmdDrawIndexed-commandBuffer-01853,N,None,explicit,vkCmdDrawIndexed,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawIndexed-commandBuffer-01854,N,None,explicit,vkCmdDrawIndexed,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer."
VUID-vkCmdDrawIndexed-commandBuffer-01855,N,None,explicit,vkCmdDrawIndexed,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawIndexed-commandBuffer-cmdpool,Y,None,implicit,vkCmdDrawIndexed,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdDrawIndexed-commandBuffer-parameter,Y,None,implicit,vkCmdDrawIndexed,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdDrawIndexed-commandBuffer-recording,Y,None,implicit,vkCmdDrawIndexed,core, commandBuffer must be in the recording state
VUID-vkCmdDrawIndexed-flags-02043,N,None,explicit,vkCmdDrawIndexed,(VK_NV_corner_sampled_image), Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
VUID-vkCmdDrawIndexed-indexSize-00463,Y,None,explicit,vkCmdDrawIndexed,core," (indexSize * (firstIndex + indexCount) + offset) must be less than or equal to the size of the bound index buffer, with indexSize being based on the type specified by indexType, where the index buffer, indexType, and offset are specified via vkCmdBindIndexBuffer"
VUID-vkCmdDrawIndexed-maxMultiviewInstanceIndex-00473,N,None,explicit,vkCmdDrawIndexed,"(VK_VERSION_1_1,VK_KHR_multiview)"," If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex."
VUID-vkCmdDrawIndexed-renderPass-00454,Y,None,explicit,vkCmdDrawIndexed,core, The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawIndexed-renderpass,Y,None,implicit,vkCmdDrawIndexed,core, This command must only be called inside of a render pass instance
VUID-vkCmdDrawIndexed-sampleLocationsEnable-01513,N,None,explicit,vkCmdDrawIndexed,(VK_EXT_sample_locations)," If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set"
VUID-vkCmdDrawIndexed-subpass-00455,Y,None,explicit,vkCmdDrawIndexed,core, The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawIndexedIndirect-None-00533,N,None,explicit,vkCmdDrawIndexedIndirect,core," For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawIndexedIndirect-None-00534,N,None,explicit,vkCmdDrawIndexedIndirect,core," For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawIndexedIndirect-None-00535,N,None,explicit,vkCmdDrawIndexedIndirect,core," Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline"
VUID-vkCmdDrawIndexedIndirect-None-00536,N,None,explicit,vkCmdDrawIndexedIndirect,core, All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have valid buffers bound
VUID-vkCmdDrawIndexedIndirect-None-00537,Y,InvalidPipeline,explicit,vkCmdDrawIndexedIndirect,core, A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
VUID-vkCmdDrawIndexedIndirect-None-00538,Y,None,explicit,vkCmdDrawIndexedIndirect,core," If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer"
VUID-vkCmdDrawIndexedIndirect-None-00542,N,None,explicit,vkCmdDrawIndexedIndirect,core, Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
VUID-vkCmdDrawIndexedIndirect-None-00543,N,None,explicit,vkCmdDrawIndexedIndirect,core," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage"
VUID-vkCmdDrawIndexedIndirect-None-00544,N,None,explicit,vkCmdDrawIndexedIndirect,core," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage"
VUID-vkCmdDrawIndexedIndirect-None-00545,N,None,explicit,vkCmdDrawIndexedIndirect,core," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage"
VUID-vkCmdDrawIndexedIndirect-None-00546,N,None,explicit,vkCmdDrawIndexedIndirect,core," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDrawIndexedIndirect-None-00547,N,None,explicit,vkCmdDrawIndexedIndirect,core," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDrawIndexedIndirect-None-00550,N,None,explicit,vkCmdDrawIndexedIndirect,(VK_IMG_filter_cubic)," Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"
VUID-vkCmdDrawIndexedIndirect-None-01503,N,None,explicit,vkCmdDrawIndexedIndirect,core, Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
VUID-vkCmdDrawIndexedIndirect-None-02018,N,None,explicit,vkCmdDrawIndexedIndirect,core," If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT."
VUID-vkCmdDrawIndexedIndirect-None-02019,N,None,explicit,vkCmdDrawIndexedIndirect,(VK_IMG_filter_cubic)," If a VkImageView is sampled with VK_FILTER_CUBIC_IMG as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG."
VUID-vkCmdDrawIndexedIndirect-buffer-00526,Y,None,explicit,vkCmdDrawIndexedIndirect,core, If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdDrawIndexedIndirect-buffer-01665,N,None,explicit,vkCmdDrawIndexedIndirect,core, buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
VUID-vkCmdDrawIndexedIndirect-buffer-parameter,Y,None,implicit,vkCmdDrawIndexedIndirect,core, buffer must be a valid VkBuffer handle
VUID-vkCmdDrawIndexedIndirect-commandBuffer-01862,N,None,explicit,vkCmdDrawIndexedIndirect,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawIndexedIndirect-commandBuffer-01863,N,None,explicit,vkCmdDrawIndexedIndirect,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer."
VUID-vkCmdDrawIndexedIndirect-commandBuffer-01864,N,None,explicit,vkCmdDrawIndexedIndirect,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawIndexedIndirect-commandBuffer-cmdpool,Y,None,implicit,vkCmdDrawIndexedIndirect,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdDrawIndexedIndirect-commandBuffer-parameter,Y,None,implicit,vkCmdDrawIndexedIndirect,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdDrawIndexedIndirect-commandBuffer-recording,Y,None,implicit,vkCmdDrawIndexedIndirect,core, commandBuffer must be in the recording state
VUID-vkCmdDrawIndexedIndirect-commonparent,Y,None,implicit,vkCmdDrawIndexedIndirect,core," Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdDrawIndexedIndirect-drawCount-00528,N,None,explicit,vkCmdDrawIndexedIndirect,core," If drawCount is greater than 1, stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndexedIndirectCommand)"
VUID-vkCmdDrawIndexedIndirect-drawCount-00529,N,None,explicit,vkCmdDrawIndexedIndirect,core," If the multi-draw indirect feature is not enabled, drawCount must be 0 or 1"
VUID-vkCmdDrawIndexedIndirect-drawCount-00539,N,None,explicit,vkCmdDrawIndexedIndirect,core," If drawCount is equal to 1, (offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawIndexedIndirect-drawCount-00540,N,None,explicit,vkCmdDrawIndexedIndirect,core," If drawCount is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawIndexedIndirect-drawCount-00541,N,None,explicit,vkCmdDrawIndexedIndirect,core, drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount
VUID-vkCmdDrawIndexedIndirect-firstInstance-00530,N,None,explicit,vkCmdDrawIndexedIndirect,core," If the drawIndirectFirstInstance feature is not enabled, all the firstInstance members of the VkDrawIndexedIndirectCommand structures accessed by this command must be 0"
VUID-vkCmdDrawIndexedIndirect-flags-02047,N,None,explicit,vkCmdDrawIndexedIndirect,(VK_NV_corner_sampled_image), Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
VUID-vkCmdDrawIndexedIndirect-maxMultiviewInstanceIndex-00551,N,None,explicit,vkCmdDrawIndexedIndirect,"(VK_VERSION_1_1,VK_KHR_multiview)"," If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex."
VUID-vkCmdDrawIndexedIndirect-offset-00527,N,None,explicit,vkCmdDrawIndexedIndirect,core, offset must be a multiple of 4
VUID-vkCmdDrawIndexedIndirect-renderPass-00531,Y,None,explicit,vkCmdDrawIndexedIndirect,core, The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawIndexedIndirect-renderpass,Y,None,implicit,vkCmdDrawIndexedIndirect,core, This command must only be called inside of a render pass instance
VUID-vkCmdDrawIndexedIndirect-sampleLocationsEnable-01516,N,None,explicit,vkCmdDrawIndexedIndirect,(VK_EXT_sample_locations)," If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set"
VUID-vkCmdDrawIndexedIndirect-subpass-00532,Y,None,explicit,vkCmdDrawIndexedIndirect,core, The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawIndexedIndirectCountAMD-None-00562,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)," For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawIndexedIndirectCountAMD-None-00563,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)," For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawIndexedIndirectCountAMD-None-00564,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)," Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline"
VUID-vkCmdDrawIndexedIndirectCountAMD-None-00565,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have valid buffers bound
VUID-vkCmdDrawIndexedIndirectCountAMD-None-00566,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
VUID-vkCmdDrawIndexedIndirectCountAMD-None-00567,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)," If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer"
VUID-vkCmdDrawIndexedIndirectCountAMD-None-00571,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
VUID-vkCmdDrawIndexedIndirectCountAMD-None-00572,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage"
VUID-vkCmdDrawIndexedIndirectCountAMD-None-00573,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage"
VUID-vkCmdDrawIndexedIndirectCountAMD-None-00574,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage"
VUID-vkCmdDrawIndexedIndirectCountAMD-None-00575,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDrawIndexedIndirectCountAMD-None-00576,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDrawIndexedIndirectCountAMD-None-01504,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
VUID-vkCmdDrawIndexedIndirectCountAMD-None-02022,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)," If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT."
VUID-vkCmdDrawIndexedIndirectCountAMD-buffer-01666,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdDrawIndexedIndirectCountAMD-buffer-01667,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
VUID-vkCmdDrawIndexedIndirectCountAMD-buffer-parameter,Y,None,implicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), buffer must be a valid VkBuffer handle
VUID-vkCmdDrawIndexedIndirectCountAMD-commandBuffer-01865,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)+(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawIndexedIndirectCountAMD-commandBuffer-01866,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)+(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer."
VUID-vkCmdDrawIndexedIndirectCountAMD-commandBuffer-01867,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)+(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawIndexedIndirectCountAMD-commandBuffer-cmdpool,N,None,implicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdDrawIndexedIndirectCountAMD-commandBuffer-parameter,Y,None,implicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdDrawIndexedIndirectCountAMD-commandBuffer-recording,N,None,implicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), commandBuffer must be in the recording state
VUID-vkCmdDrawIndexedIndirectCountAMD-commonparent,Y,None,implicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)," Each of buffer, commandBuffer, and countBuffer must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdDrawIndexedIndirectCountAMD-countBuffer-00568,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)," If count stored in countBuffer is equal to 1, (offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawIndexedIndirectCountAMD-countBuffer-00569,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)," If count stored in countBuffer is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawIndexedIndirectCountAMD-countBuffer-01668,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), If countBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdDrawIndexedIndirectCountAMD-countBuffer-01669,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), countBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
VUID-vkCmdDrawIndexedIndirectCountAMD-countBuffer-parameter,Y,None,implicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), countBuffer must be a valid VkBuffer handle
VUID-vkCmdDrawIndexedIndirectCountAMD-countBufferOffset-00556,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), countBufferOffset must be a multiple of 4
VUID-vkCmdDrawIndexedIndirectCountAMD-drawCount-00570,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount
VUID-vkCmdDrawIndexedIndirectCountAMD-firstInstance-00559,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)," If the drawIndirectFirstInstance feature is not enabled, all the firstInstance members of the VkDrawIndexedIndirectCommand structures accessed by this command must be 0"
VUID-vkCmdDrawIndexedIndirectCountAMD-flags-02049,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)+(VK_NV_corner_sampled_image), Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
VUID-vkCmdDrawIndexedIndirectCountAMD-maxDrawCount-00558,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)," If maxDrawCount is greater than or equal to 1, (stride {times} (maxDrawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawIndexedIndirectCountAMD-maxMultiviewInstanceIndex-00578,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,"(VK_AMD_draw_indirect_count)+(VK_VERSION_1_1,VK_KHR_multiview)"," If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex."
VUID-vkCmdDrawIndexedIndirectCountAMD-offset-00555,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), offset must be a multiple of 4
VUID-vkCmdDrawIndexedIndirectCountAMD-renderPass-00560,Y,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawIndexedIndirectCountAMD-renderpass,N,None,implicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), This command must only be called inside of a render pass instance
VUID-vkCmdDrawIndexedIndirectCountAMD-sampleLocationsEnable-01517,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count)+(VK_EXT_sample_locations)," If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set"
VUID-vkCmdDrawIndexedIndirectCountAMD-stride-00557,N,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndexedIndirectCommand)
VUID-vkCmdDrawIndexedIndirectCountAMD-subpass-00561,Y,None,explicit,vkCmdDrawIndexedIndirectCountAMD,(VK_AMD_draw_indirect_count), The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawIndexedIndirectCountKHR-None-02020,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)," If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT."
VUID-vkCmdDrawIndexedIndirectCountKHR-None-02021,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)+(VK_IMG_filter_cubic)," If a VkImageView is sampled with VK_FILTER_CUBIC_IMG as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG."
VUID-vkCmdDrawIndexedIndirectCountKHR-None-03147,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)," For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawIndexedIndirectCountKHR-None-03148,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)," For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawIndexedIndirectCountKHR-None-03149,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)," Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline"
VUID-vkCmdDrawIndexedIndirectCountKHR-None-03150,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have valid buffers bound
VUID-vkCmdDrawIndexedIndirectCountKHR-None-03151,Y,InvalidPipeline,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
VUID-vkCmdDrawIndexedIndirectCountKHR-None-03152,Y,DrawIndexedIndirectCountKHR,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)," If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer"
VUID-vkCmdDrawIndexedIndirectCountKHR-None-03156,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
VUID-vkCmdDrawIndexedIndirectCountKHR-None-03157,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage"
VUID-vkCmdDrawIndexedIndirectCountKHR-None-03158,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage"
VUID-vkCmdDrawIndexedIndirectCountKHR-None-03159,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage"
VUID-vkCmdDrawIndexedIndirectCountKHR-None-03160,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDrawIndexedIndirectCountKHR-None-03161,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDrawIndexedIndirectCountKHR-None-03163,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
VUID-vkCmdDrawIndexedIndirectCountKHR-None-03173,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)+(VK_IMG_filter_cubic)," Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"
VUID-vkCmdDrawIndexedIndirectCountKHR-buffer-03136,Y,DrawIndexedIndirectCountKHR,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdDrawIndexedIndirectCountKHR-buffer-03137,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
VUID-vkCmdDrawIndexedIndirectCountKHR-buffer-parameter,Y,None,implicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), buffer must be a valid VkBuffer handle
VUID-vkCmdDrawIndexedIndirectCountKHR-commandBuffer-03165,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)+(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawIndexedIndirectCountKHR-commandBuffer-03166,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)+(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer."
VUID-vkCmdDrawIndexedIndirectCountKHR-commandBuffer-03167,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)+(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawIndexedIndirectCountKHR-commandBuffer-cmdpool,Y,None,implicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdDrawIndexedIndirectCountKHR-commandBuffer-parameter,Y,None,implicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdDrawIndexedIndirectCountKHR-commandBuffer-recording,Y,None,implicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), commandBuffer must be in the recording state
VUID-vkCmdDrawIndexedIndirectCountKHR-commonparent,Y,None,implicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)," Each of buffer, commandBuffer, and countBuffer must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdDrawIndexedIndirectCountKHR-countBuffer-03138,Y,DrawIndexedIndirectCountKHR,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), If countBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdDrawIndexedIndirectCountKHR-countBuffer-03139,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), countBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
VUID-vkCmdDrawIndexedIndirectCountKHR-countBuffer-03153,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)," If count stored in countBuffer is equal to 1, (offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawIndexedIndirectCountKHR-countBuffer-03154,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)," If count stored in countBuffer is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawIndexedIndirectCountKHR-countBuffer-parameter,Y,None,implicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), countBuffer must be a valid VkBuffer handle
VUID-vkCmdDrawIndexedIndirectCountKHR-countBufferOffset-03141,Y,DrawIndexedIndirectCountKHR,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), countBufferOffset must be a multiple of 4
VUID-vkCmdDrawIndexedIndirectCountKHR-drawCount-03155,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount
VUID-vkCmdDrawIndexedIndirectCountKHR-firstInstance-03144,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)," If the drawIndirectFirstInstance feature is not enabled, all the firstInstance members of the VkDrawIndexedIndirectCommand structures accessed by this command must be 0"
VUID-vkCmdDrawIndexedIndirectCountKHR-flags-02048,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)+(VK_NV_corner_sampled_image), Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
VUID-vkCmdDrawIndexedIndirectCountKHR-maxDrawCount-03143,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)," If maxDrawCount is greater than or equal to 1, (stride {times} (maxDrawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawIndexedIndirectCountKHR-maxMultiviewInstanceIndex-03164,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,"(VK_KHR_draw_indirect_count)+(VK_VERSION_1_1,VK_KHR_multiview)"," If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex."
VUID-vkCmdDrawIndexedIndirectCountKHR-offset-03140,Y,DrawIndexedIndirectCountKHR,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), offset must be a multiple of 4
VUID-vkCmdDrawIndexedIndirectCountKHR-renderPass-03145,Y,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawIndexedIndirectCountKHR-renderpass,Y,None,implicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), This command must only be called inside of a render pass instance
VUID-vkCmdDrawIndexedIndirectCountKHR-sampleLocationsEnable-03174,N,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count)+(VK_EXT_sample_locations)," If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set"
VUID-vkCmdDrawIndexedIndirectCountKHR-stride-03142,Y,DrawIndexedIndirectCountKHR,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndexedIndirectCommand)
VUID-vkCmdDrawIndexedIndirectCountKHR-subpass-03146,Y,None,explicit,vkCmdDrawIndexedIndirectCountKHR,(VK_KHR_draw_indirect_count), The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawIndirect-None-00481,N,None,explicit,vkCmdDrawIndirect,core," For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawIndirect-None-00482,N,None,explicit,vkCmdDrawIndirect,core," For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawIndirect-None-00483,N,None,explicit,vkCmdDrawIndirect,core," Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline"
VUID-vkCmdDrawIndirect-None-00484,N,None,explicit,vkCmdDrawIndirect,core, All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have valid buffers bound
VUID-vkCmdDrawIndirect-None-00485,Y,InvalidPipeline,explicit,vkCmdDrawIndirect,core, A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
VUID-vkCmdDrawIndirect-None-00486,Y,None,explicit,vkCmdDrawIndirect,core," If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer"
VUID-vkCmdDrawIndirect-None-00490,N,None,explicit,vkCmdDrawIndirect,core, Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
VUID-vkCmdDrawIndirect-None-00491,N,None,explicit,vkCmdDrawIndirect,core," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage"
VUID-vkCmdDrawIndirect-None-00492,N,None,explicit,vkCmdDrawIndirect,core," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage"
VUID-vkCmdDrawIndirect-None-00493,N,None,explicit,vkCmdDrawIndirect,core," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage"
VUID-vkCmdDrawIndirect-None-00494,N,None,explicit,vkCmdDrawIndirect,core," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDrawIndirect-None-00495,N,None,explicit,vkCmdDrawIndirect,core," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDrawIndirect-None-00498,N,None,explicit,vkCmdDrawIndirect,(VK_IMG_filter_cubic)," Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"
VUID-vkCmdDrawIndirect-None-01501,N,None,explicit,vkCmdDrawIndirect,core, Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
VUID-vkCmdDrawIndirect-None-02013,N,None,explicit,vkCmdDrawIndirect,core," If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT."
VUID-vkCmdDrawIndirect-None-02014,N,None,explicit,vkCmdDrawIndirect,(VK_IMG_filter_cubic)," If a VkImageView is sampled with VK_FILTER_CUBIC_IMG as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG."
VUID-vkCmdDrawIndirect-buffer-00474,Y,None,explicit,vkCmdDrawIndirect,core, If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdDrawIndirect-buffer-01660,N,None,explicit,vkCmdDrawIndirect,core, buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
VUID-vkCmdDrawIndirect-buffer-parameter,Y,None,implicit,vkCmdDrawIndirect,core, buffer must be a valid VkBuffer handle
VUID-vkCmdDrawIndirect-commandBuffer-01856,N,None,explicit,vkCmdDrawIndirect,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawIndirect-commandBuffer-01857,N,None,explicit,vkCmdDrawIndirect,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer."
VUID-vkCmdDrawIndirect-commandBuffer-01858,N,None,explicit,vkCmdDrawIndirect,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawIndirect-commandBuffer-cmdpool,Y,None,implicit,vkCmdDrawIndirect,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdDrawIndirect-commandBuffer-parameter,Y,None,implicit,vkCmdDrawIndirect,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdDrawIndirect-commandBuffer-recording,Y,None,implicit,vkCmdDrawIndirect,core, commandBuffer must be in the recording state
VUID-vkCmdDrawIndirect-commonparent,Y,None,implicit,vkCmdDrawIndirect,core," Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdDrawIndirect-drawCount-00476,N,None,explicit,vkCmdDrawIndirect,core," If drawCount is greater than 1, stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndirectCommand)"
VUID-vkCmdDrawIndirect-drawCount-00477,N,None,explicit,vkCmdDrawIndirect,core," If the multi-draw indirect feature is not enabled, drawCount must be 0 or 1"
VUID-vkCmdDrawIndirect-drawCount-00487,N,None,explicit,vkCmdDrawIndirect,core," If drawCount is equal to 1, (offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawIndirect-drawCount-00488,N,None,explicit,vkCmdDrawIndirect,core," If drawCount is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawIndirect-drawCount-00489,N,None,explicit,vkCmdDrawIndirect,core, drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount
VUID-vkCmdDrawIndirect-firstInstance-00478,N,None,explicit,vkCmdDrawIndirect,core," If the drawIndirectFirstInstance feature is not enabled, all the firstInstance members of the VkDrawIndirectCommand structures accessed by this command must be 0"
VUID-vkCmdDrawIndirect-flags-02044,N,None,explicit,vkCmdDrawIndirect,(VK_NV_corner_sampled_image), Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
VUID-vkCmdDrawIndirect-maxMultiviewInstanceIndex-00499,N,None,explicit,vkCmdDrawIndirect,"(VK_VERSION_1_1,VK_KHR_multiview)"," If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex."
VUID-vkCmdDrawIndirect-offset-00475,N,None,explicit,vkCmdDrawIndirect,core, offset must be a multiple of 4
VUID-vkCmdDrawIndirect-renderPass-00479,Y,None,explicit,vkCmdDrawIndirect,core, The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawIndirect-renderpass,Y,None,implicit,vkCmdDrawIndirect,core, This command must only be called inside of a render pass instance
VUID-vkCmdDrawIndirect-sampleLocationsEnable-01514,N,None,explicit,vkCmdDrawIndirect,(VK_EXT_sample_locations)," If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set"
VUID-vkCmdDrawIndirect-subpass-00480,Y,None,explicit,vkCmdDrawIndirect,core, The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawIndirectCountAMD-None-00509,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)," For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawIndirectCountAMD-None-00510,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)," For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawIndirectCountAMD-None-00511,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)," Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline"
VUID-vkCmdDrawIndirectCountAMD-None-00512,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have valid buffers bound
VUID-vkCmdDrawIndirectCountAMD-None-00513,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
VUID-vkCmdDrawIndirectCountAMD-None-00514,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)," If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer"
VUID-vkCmdDrawIndirectCountAMD-None-00518,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
VUID-vkCmdDrawIndirectCountAMD-None-00519,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage"
VUID-vkCmdDrawIndirectCountAMD-None-00520,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage"
VUID-vkCmdDrawIndirectCountAMD-None-00521,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage"
VUID-vkCmdDrawIndirectCountAMD-None-00522,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDrawIndirectCountAMD-None-00523,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDrawIndirectCountAMD-None-01502,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
VUID-vkCmdDrawIndirectCountAMD-None-02017,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)," If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT."
VUID-vkCmdDrawIndirectCountAMD-buffer-01661,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdDrawIndirectCountAMD-buffer-01662,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
VUID-vkCmdDrawIndirectCountAMD-buffer-parameter,Y,None,implicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), buffer must be a valid VkBuffer handle
VUID-vkCmdDrawIndirectCountAMD-commandBuffer-01859,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)+(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawIndirectCountAMD-commandBuffer-01860,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)+(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer."
VUID-vkCmdDrawIndirectCountAMD-commandBuffer-01861,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)+(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawIndirectCountAMD-commandBuffer-cmdpool,N,None,implicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdDrawIndirectCountAMD-commandBuffer-parameter,Y,None,implicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdDrawIndirectCountAMD-commandBuffer-recording,N,None,implicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), commandBuffer must be in the recording state
VUID-vkCmdDrawIndirectCountAMD-commonparent,Y,None,implicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)," Each of buffer, commandBuffer, and countBuffer must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdDrawIndirectCountAMD-countBuffer-00515,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)," If the count stored in countBuffer is equal to 1, (offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawIndirectCountAMD-countBuffer-00516,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)," If the count stored in countBuffer is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawIndirectCountAMD-countBuffer-00517,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), The count stored in countBuffer must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount
VUID-vkCmdDrawIndirectCountAMD-countBuffer-01663,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), If countBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdDrawIndirectCountAMD-countBuffer-01664,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), countBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
VUID-vkCmdDrawIndirectCountAMD-countBuffer-parameter,Y,None,implicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), countBuffer must be a valid VkBuffer handle
VUID-vkCmdDrawIndirectCountAMD-countBufferOffset-00503,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), countBufferOffset must be a multiple of 4
VUID-vkCmdDrawIndirectCountAMD-firstInstance-00506,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)," If the drawIndirectFirstInstance feature is not enabled, all the firstInstance members of the VkDrawIndirectCommand structures accessed by this command must be 0"
VUID-vkCmdDrawIndirectCountAMD-flags-02046,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)+(VK_NV_corner_sampled_image), Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
VUID-vkCmdDrawIndirectCountAMD-maxDrawCount-00505,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)," If maxDrawCount is greater than or equal to 1, (stride {times} (maxDrawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawIndirectCountAMD-maxMultiviewInstanceIndex-00525,N,None,explicit,vkCmdDrawIndirectCountAMD,"(VK_AMD_draw_indirect_count)+(VK_VERSION_1_1,VK_KHR_multiview)"," If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex."
VUID-vkCmdDrawIndirectCountAMD-offset-00502,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), offset must be a multiple of 4
VUID-vkCmdDrawIndirectCountAMD-renderPass-00507,Y,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawIndirectCountAMD-renderpass,N,None,implicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), This command must only be called inside of a render pass instance
VUID-vkCmdDrawIndirectCountAMD-sampleLocationsEnable-01515,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count)+(VK_EXT_sample_locations)," If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set"
VUID-vkCmdDrawIndirectCountAMD-stride-00504,N,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndirectCommand)
VUID-vkCmdDrawIndirectCountAMD-subpass-00508,Y,None,explicit,vkCmdDrawIndirectCountAMD,(VK_AMD_draw_indirect_count), The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawIndirectCountKHR-None-02015,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)," If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT."
VUID-vkCmdDrawIndirectCountKHR-None-02016,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)+(VK_IMG_filter_cubic)," If a VkImageView is sampled with VK_FILTER_CUBIC_IMG as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG."
VUID-vkCmdDrawIndirectCountKHR-None-03115,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)," For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawIndirectCountKHR-None-03116,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)," For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawIndirectCountKHR-None-03117,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)," Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline"
VUID-vkCmdDrawIndirectCountKHR-None-03118,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have valid buffers bound
VUID-vkCmdDrawIndirectCountKHR-None-03119,Y,InvalidPipeline,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
VUID-vkCmdDrawIndirectCountKHR-None-03120,Y,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)," If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer"
VUID-vkCmdDrawIndirectCountKHR-None-03124,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
VUID-vkCmdDrawIndirectCountKHR-None-03125,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage"
VUID-vkCmdDrawIndirectCountKHR-None-03126,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage"
VUID-vkCmdDrawIndirectCountKHR-None-03127,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)," If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage"
VUID-vkCmdDrawIndirectCountKHR-None-03128,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDrawIndirectCountKHR-None-03129,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set"
VUID-vkCmdDrawIndirectCountKHR-None-03131,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
VUID-vkCmdDrawIndirectCountKHR-None-03170,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)+(VK_IMG_filter_cubic)," Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"
VUID-vkCmdDrawIndirectCountKHR-buffer-03104,Y,DrawIndirectCountKHR,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdDrawIndirectCountKHR-buffer-03105,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
VUID-vkCmdDrawIndirectCountKHR-buffer-parameter,Y,None,implicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), buffer must be a valid VkBuffer handle
VUID-vkCmdDrawIndirectCountKHR-commandBuffer-03133,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)+(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawIndirectCountKHR-commandBuffer-03134,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)+(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer."
VUID-vkCmdDrawIndirectCountKHR-commandBuffer-03135,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)+(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawIndirectCountKHR-commandBuffer-cmdpool,Y,None,implicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdDrawIndirectCountKHR-commandBuffer-parameter,Y,None,implicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdDrawIndirectCountKHR-commandBuffer-recording,Y,None,implicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), commandBuffer must be in the recording state
VUID-vkCmdDrawIndirectCountKHR-commonparent,Y,None,implicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)," Each of buffer, commandBuffer, and countBuffer must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdDrawIndirectCountKHR-countBuffer-03106,Y,DrawIndirectCountKHR,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), If countBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdDrawIndirectCountKHR-countBuffer-03107,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), countBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
VUID-vkCmdDrawIndirectCountKHR-countBuffer-03121,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)," If the count stored in countBuffer is equal to 1, (offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawIndirectCountKHR-countBuffer-03122,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)," If the count stored in countBuffer is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawIndirectCountKHR-countBuffer-03123,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), The count stored in countBuffer must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount
VUID-vkCmdDrawIndirectCountKHR-countBuffer-parameter,Y,None,implicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), countBuffer must be a valid VkBuffer handle
VUID-vkCmdDrawIndirectCountKHR-countBufferOffset-03109,Y,DrawIndirectCountKHR,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), countBufferOffset must be a multiple of 4
VUID-vkCmdDrawIndirectCountKHR-firstInstance-03112,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)," If the drawIndirectFirstInstance feature is not enabled, all the firstInstance members of the VkDrawIndirectCommand structures accessed by this command must be 0"
VUID-vkCmdDrawIndirectCountKHR-flags-02045,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)+(VK_NV_corner_sampled_image), Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
VUID-vkCmdDrawIndirectCountKHR-maxDrawCount-03111,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)," If maxDrawCount is greater than or equal to 1, (stride {times} (maxDrawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawIndirectCountKHR-maxMultiviewInstanceIndex-03132,N,None,explicit,vkCmdDrawIndirectCountKHR,"(VK_KHR_draw_indirect_count)+(VK_VERSION_1_1,VK_KHR_multiview)"," If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex."
VUID-vkCmdDrawIndirectCountKHR-offset-03108,Y,DrawIndirectCountKHR,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), offset must be a multiple of 4
VUID-vkCmdDrawIndirectCountKHR-renderPass-03113,Y,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawIndirectCountKHR-renderpass,Y,None,implicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), This command must only be called inside of a render pass instance
VUID-vkCmdDrawIndirectCountKHR-sampleLocationsEnable-03171,N,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count)+(VK_EXT_sample_locations)," If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set"
VUID-vkCmdDrawIndirectCountKHR-stride-03110,Y,DrawIndirectCountKHR,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndirectCommand)
VUID-vkCmdDrawIndirectCountKHR-subpass-03114,Y,None,explicit,vkCmdDrawIndirectCountKHR,(VK_KHR_draw_indirect_count), The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02186,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader)," For each set n that is statically used by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02187,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader)," For each push constant that is statically used by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02188,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader)," Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the currently bound VkPipeline object, specified via vkCmdBindPipeline"
VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02189,Y,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader), A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02190,Y,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader)," If the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer"
VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02194,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader), Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02195,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader)," If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage"
VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02196,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader)," If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage"
VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02197,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader)," If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage"
VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02198,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader)," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the currently bound descriptor set"
VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02199,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader)," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the currently bound descriptor set"
VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02201,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader), Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
VUID-vkCmdDrawMeshTasksIndirectCountNV-buffer-02176,Y,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader), If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdDrawMeshTasksIndirectCountNV-buffer-02177,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader), buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
VUID-vkCmdDrawMeshTasksIndirectCountNV-buffer-parameter,Y,None,implicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader), buffer must be a valid VkBuffer handle
VUID-vkCmdDrawMeshTasksIndirectCountNV-commandBuffer-02203,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader)+(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawMeshTasksIndirectCountNV-commandBuffer-02204,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader)+(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer."
VUID-vkCmdDrawMeshTasksIndirectCountNV-commandBuffer-02205,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader)+(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawMeshTasksIndirectCountNV-commandBuffer-cmdpool,Y,None,implicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader), The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdDrawMeshTasksIndirectCountNV-commandBuffer-parameter,Y,None,implicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdDrawMeshTasksIndirectCountNV-commandBuffer-recording,Y,None,implicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader), commandBuffer must be in the recording state
VUID-vkCmdDrawMeshTasksIndirectCountNV-commonparent,Y,None,implicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader)," Each of buffer, commandBuffer, and countBuffer must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdDrawMeshTasksIndirectCountNV-countBuffer-02178,Y,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader), If countBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdDrawMeshTasksIndirectCountNV-countBuffer-02179,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader), countBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
VUID-vkCmdDrawMeshTasksIndirectCountNV-countBuffer-02191,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader)," If the count stored in countBuffer is equal to 1, (offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawMeshTasksIndirectCountNV-countBuffer-02192,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader)," If the count stored in countBuffer is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawMeshTasksIndirectCountNV-countBuffer-02193,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader), The count stored in countBuffer must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount
VUID-vkCmdDrawMeshTasksIndirectCountNV-countBuffer-parameter,Y,None,implicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader), countBuffer must be a valid VkBuffer handle
VUID-vkCmdDrawMeshTasksIndirectCountNV-countBufferOffset-02181,Y,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader), countBufferOffset must be a multiple of 4
VUID-vkCmdDrawMeshTasksIndirectCountNV-linearTilingFeatures-02200,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader)," Any VkImageView being sampled with VK_FILTER_LINEAR as a result of this command must be of a format which supports linear filtering, as specified by the VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in VkFormatProperties::linearTilingFeatures (for a linear image) or VkFormatProperties::optimalTilingFeatures(for an optimally tiled image) returned by vkGetPhysicalDeviceFormatProperties"
VUID-vkCmdDrawMeshTasksIndirectCountNV-maxDrawCount-02183,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader)," If maxDrawCount is greater than or equal to 1, (stride {times} (maxDrawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawMeshTasksIndirectCountNV-maxMultiviewInstanceIndex-02202,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader)+(VK_KHR_multiview)," If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex."
VUID-vkCmdDrawMeshTasksIndirectCountNV-offset-02180,Y,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader), offset must be a multiple of 4
VUID-vkCmdDrawMeshTasksIndirectCountNV-renderPass-02184,Y,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader), The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawMeshTasksIndirectCountNV-renderpass,Y,None,implicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader), This command must only be called inside of a render pass instance
VUID-vkCmdDrawMeshTasksIndirectCountNV-sampleLocationsEnable-02206,N,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader)+(VK_EXT_sample_locations)," If the currently bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set"
VUID-vkCmdDrawMeshTasksIndirectCountNV-stride-02182,Y,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader), stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawMeshTasksIndirectCommandNV)
VUID-vkCmdDrawMeshTasksIndirectCountNV-subpass-02185,Y,None,explicit,vkCmdDrawMeshTasksIndirectCountNV,(VK_NV_mesh_shader), The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawMeshTasksIndirectNV-None-02150,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)," For each set n that is statically used by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawMeshTasksIndirectNV-None-02151,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)," For each push constant that is statically used by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawMeshTasksIndirectNV-None-02152,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)," Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the currently bound VkPipeline object, specified via vkCmdBindPipeline"
VUID-vkCmdDrawMeshTasksIndirectNV-None-02153,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader), All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have valid buffers bound
VUID-vkCmdDrawMeshTasksIndirectNV-None-02154,Y,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader), A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
VUID-vkCmdDrawMeshTasksIndirectNV-None-02155,Y,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)," If the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer"
VUID-vkCmdDrawMeshTasksIndirectNV-None-02159,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader), Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
VUID-vkCmdDrawMeshTasksIndirectNV-None-02160,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)," If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage"
VUID-vkCmdDrawMeshTasksIndirectNV-None-02161,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)," If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage"
VUID-vkCmdDrawMeshTasksIndirectNV-None-02162,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)," If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage"
VUID-vkCmdDrawMeshTasksIndirectNV-None-02163,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the currently bound descriptor set"
VUID-vkCmdDrawMeshTasksIndirectNV-None-02164,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the currently bound descriptor set"
VUID-vkCmdDrawMeshTasksIndirectNV-None-02166,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader), Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
VUID-vkCmdDrawMeshTasksIndirectNV-None-02168,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)+(VK_IMG_filter_cubic)," Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"
VUID-vkCmdDrawMeshTasksIndirectNV-buffer-02143,Y,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader), If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdDrawMeshTasksIndirectNV-buffer-02144,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader), buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
VUID-vkCmdDrawMeshTasksIndirectNV-buffer-parameter,Y,None,implicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader), buffer must be a valid VkBuffer handle
VUID-vkCmdDrawMeshTasksIndirectNV-commandBuffer-02170,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)+(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawMeshTasksIndirectNV-commandBuffer-02171,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)+(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer."
VUID-vkCmdDrawMeshTasksIndirectNV-commandBuffer-02172,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)+(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawMeshTasksIndirectNV-commandBuffer-cmdpool,Y,None,implicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader), The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdDrawMeshTasksIndirectNV-commandBuffer-parameter,Y,None,implicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdDrawMeshTasksIndirectNV-commandBuffer-recording,Y,None,implicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader), commandBuffer must be in the recording state
VUID-vkCmdDrawMeshTasksIndirectNV-commonparent,Y,None,implicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)," Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02146,Y,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)," If drawCount is greater than 1, stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawMeshTasksIndirectCommandNV)"
VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02147,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)," If the multi-draw indirect feature is not enabled, drawCount must be 0 or 1"
VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02156,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)," If drawCount is equal to 1, (offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02157,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)," If drawCount is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer"
VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02158,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader), drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount
VUID-vkCmdDrawMeshTasksIndirectNV-flags-02174,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)+(VK_NV_corner_sampled_image), Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
VUID-vkCmdDrawMeshTasksIndirectNV-linearTilingFeatures-02165,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)," Any VkImageView being sampled with VK_FILTER_LINEAR as a result of this command must be of a format which supports linear filtering, as specified by the VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in VkFormatProperties::linearTilingFeatures (for a linear image) or VkFormatProperties::optimalTilingFeatures(for an optimally tiled image) returned by vkGetPhysicalDeviceFormatProperties"
VUID-vkCmdDrawMeshTasksIndirectNV-linearTilingFeatures-02167,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)+(VK_IMG_filter_cubic)," Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must be of a format which supports cubic filtering, as specified by the VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG flag in VkFormatProperties::linearTilingFeatures (for a linear image) or VkFormatProperties::optimalTilingFeatures(for an optimally tiled image) returned by vkGetPhysicalDeviceFormatProperties"
VUID-vkCmdDrawMeshTasksIndirectNV-maxMultiviewInstanceIndex-02169,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)+(VK_KHR_multiview)," If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex."
VUID-vkCmdDrawMeshTasksIndirectNV-offset-02145,Y,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader), offset must be a multiple of 4
VUID-vkCmdDrawMeshTasksIndirectNV-renderPass-02148,Y,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader), The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawMeshTasksIndirectNV-renderpass,Y,None,implicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader), This command must only be called inside of a render pass instance
VUID-vkCmdDrawMeshTasksIndirectNV-sampleLocationsEnable-02173,N,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader)+(VK_EXT_sample_locations)," If the currently bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set"
VUID-vkCmdDrawMeshTasksIndirectNV-subpass-02149,Y,None,explicit,vkCmdDrawMeshTasksIndirectNV,(VK_NV_mesh_shader), The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawMeshTasksNV-None-02122,N,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader)," For each set n that is statically used by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawMeshTasksNV-None-02123,N,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader)," For each push constant that is statically used by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility"
VUID-vkCmdDrawMeshTasksNV-None-02124,N,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader)," Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the currently bound VkPipeline object, specified via vkCmdBindPipeline"
VUID-vkCmdDrawMeshTasksNV-None-02125,Y,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader), A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
VUID-vkCmdDrawMeshTasksNV-None-02126,Y,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader)," If the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer"
VUID-vkCmdDrawMeshTasksNV-None-02127,N,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader), Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
VUID-vkCmdDrawMeshTasksNV-None-02128,N,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader)," If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage"
VUID-vkCmdDrawMeshTasksNV-None-02129,N,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader)," If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage"
VUID-vkCmdDrawMeshTasksNV-None-02130,N,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader)," If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage"
VUID-vkCmdDrawMeshTasksNV-None-02131,N,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader)," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the currently bound descriptor set"
VUID-vkCmdDrawMeshTasksNV-None-02132,N,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader)," If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the currently bound descriptor set"
VUID-vkCmdDrawMeshTasksNV-None-02134,N,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader), Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
VUID-vkCmdDrawMeshTasksNV-None-02136,N,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader)+(VK_IMG_filter_cubic)," Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"
VUID-vkCmdDrawMeshTasksNV-commandBuffer-02138,N,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader)+(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawMeshTasksNV-commandBuffer-02139,N,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader)+(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer."
VUID-vkCmdDrawMeshTasksNV-commandBuffer-02140,N,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader)+(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer."
VUID-vkCmdDrawMeshTasksNV-commandBuffer-cmdpool,Y,None,implicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader), The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdDrawMeshTasksNV-commandBuffer-parameter,Y,None,implicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdDrawMeshTasksNV-commandBuffer-recording,Y,None,implicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader), commandBuffer must be in the recording state
VUID-vkCmdDrawMeshTasksNV-flags-02142,N,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader)+(VK_NV_corner_sampled_image), Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
VUID-vkCmdDrawMeshTasksNV-linearTilingFeatures-02133,N,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader)," Any VkImageView being sampled with VK_FILTER_LINEAR as a result of this command must be of a format which supports linear filtering, as specified by the VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in VkFormatProperties::linearTilingFeatures (for a linear image) or VkFormatProperties::optimalTilingFeatures(for an optimally tiled image) returned by vkGetPhysicalDeviceFormatProperties"
VUID-vkCmdDrawMeshTasksNV-linearTilingFeatures-02135,N,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader)+(VK_IMG_filter_cubic)," Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must be of a format which supports cubic filtering, as specified by the VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG flag in VkFormatProperties::linearTilingFeatures (for a linear image) or VkFormatProperties::optimalTilingFeatures(for an optimally tiled image) returned by vkGetPhysicalDeviceFormatProperties"
VUID-vkCmdDrawMeshTasksNV-maxMultiviewInstanceIndex-02137,N,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader)+(VK_KHR_multiview)," If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex."
VUID-vkCmdDrawMeshTasksNV-renderPass-02120,Y,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader), The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawMeshTasksNV-renderpass,Y,None,implicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader), This command must only be called inside of a render pass instance
VUID-vkCmdDrawMeshTasksNV-sampleLocationsEnable-02141,N,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader)+(VK_EXT_sample_locations)," If the currently bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set"
VUID-vkCmdDrawMeshTasksNV-subpass-02121,Y,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader), The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
VUID-vkCmdDrawMeshTasksNV-taskCount-02119,Y,None,explicit,vkCmdDrawMeshTasksNV,(VK_NV_mesh_shader), taskCount must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesNV::maxDrawMeshTasksCount
VUID-vkCmdEndConditionalRenderingEXT-None-01985,N,None,explicit,vkCmdEndConditionalRenderingEXT,(VK_EXT_conditional_rendering), Conditional rendering must be active
VUID-vkCmdEndConditionalRenderingEXT-None-01986,N,None,explicit,vkCmdEndConditionalRenderingEXT,(VK_EXT_conditional_rendering)," If conditional rendering was made active outside of a render pass instance, it must not be ended inside a render pass instance"
VUID-vkCmdEndConditionalRenderingEXT-None-01987,N,None,explicit,vkCmdEndConditionalRenderingEXT,(VK_EXT_conditional_rendering), If conditional rendering was made active within a subpass it must be ended in the same subpass
VUID-vkCmdEndConditionalRenderingEXT-commandBuffer-cmdpool,N,None,implicit,vkCmdEndConditionalRenderingEXT,(VK_EXT_conditional_rendering)," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdEndConditionalRenderingEXT-commandBuffer-parameter,Y,None,implicit,vkCmdEndConditionalRenderingEXT,(VK_EXT_conditional_rendering), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdEndConditionalRenderingEXT-commandBuffer-recording,N,None,implicit,vkCmdEndConditionalRenderingEXT,(VK_EXT_conditional_rendering), commandBuffer must be in the recording state
VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-01912,N,None,explicit,vkCmdEndDebugUtilsLabelEXT,(VK_EXT_debug_utils), There must be an outstanding vkCmdBeginDebugUtilsLabelEXT command prior to the vkCmdEndDebugUtilsLabelEXT on the queue that commandBuffer is submitted to
VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-01913,N,None,explicit,vkCmdEndDebugUtilsLabelEXT,(VK_EXT_debug_utils)," If commandBuffer is a secondary command buffer, there must be an outstanding vkCmdBeginDebugUtilsLabelEXT command recorded to commandBuffer that has not previously been ended by a call to vkCmdEndDebugUtilsLabelEXT."
VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-cmdpool,N,None,implicit,vkCmdEndDebugUtilsLabelEXT,(VK_EXT_debug_utils)," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-parameter,N,None,implicit,vkCmdEndDebugUtilsLabelEXT,(VK_EXT_debug_utils), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-recording,N,None,implicit,vkCmdEndDebugUtilsLabelEXT,(VK_EXT_debug_utils), commandBuffer must be in the recording state
VUID-vkCmdEndQuery-None-01923,Y,None,explicit,vkCmdEndQuery,core, All queries used by the command must be active
VUID-vkCmdEndQuery-commandBuffer-01886,N,None,explicit,vkCmdEndQuery,(VK_VERSION_1_1), commandBuffer must not be a protected command buffer
VUID-vkCmdEndQuery-commandBuffer-cmdpool,Y,None,implicit,vkCmdEndQuery,core," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdEndQuery-commandBuffer-parameter,Y,None,implicit,vkCmdEndQuery,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdEndQuery-commandBuffer-recording,Y,None,implicit,vkCmdEndQuery,core, commandBuffer must be in the recording state
VUID-vkCmdEndQuery-commonparent,Y,None,implicit,vkCmdEndQuery,core," Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdEndQuery-query-00810,N,None,explicit,vkCmdEndQuery,core, query must be less than the number of queries in queryPool
VUID-vkCmdEndQuery-query-00812,N,None,explicit,vkCmdEndQuery,"(VK_VERSION_1_1,VK_KHR_multiview)"," If vkCmdEndQuery is called within a render pass instance, the sum of query and the number of bits set in the current subpass's view mask must be less than or equal to the number of queries in queryPool"
VUID-vkCmdEndQuery-queryPool-parameter,Y,None,implicit,vkCmdEndQuery,core, queryPool must be a valid VkQueryPool handle
VUID-vkCmdEndRenderPass-None-00910,Y,None,explicit,vkCmdEndRenderPass,core, The current subpass index must be equal to the number of subpasses in the render pass minus one
VUID-vkCmdEndRenderPass-bufferlevel,Y,None,implicit,vkCmdEndRenderPass,core, commandBuffer must be a primary VkCommandBuffer
VUID-vkCmdEndRenderPass-commandBuffer-cmdpool,Y,None,implicit,vkCmdEndRenderPass,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdEndRenderPass-commandBuffer-parameter,Y,None,implicit,vkCmdEndRenderPass,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdEndRenderPass-commandBuffer-recording,Y,None,implicit,vkCmdEndRenderPass,core, commandBuffer must be in the recording state
VUID-vkCmdEndRenderPass-renderpass,Y,None,implicit,vkCmdEndRenderPass,core, This command must only be called inside of a render pass instance
VUID-vkCmdEndRenderPass2KHR-None-03103,N,None,explicit,vkCmdEndRenderPass2KHR,(VK_KHR_create_renderpass2), The current subpass index must be equal to the number of subpasses in the render pass minus one
VUID-vkCmdEndRenderPass2KHR-bufferlevel,N,None,implicit,vkCmdEndRenderPass2KHR,(VK_KHR_create_renderpass2), commandBuffer must be a primary VkCommandBuffer
VUID-vkCmdEndRenderPass2KHR-commandBuffer-cmdpool,N,None,implicit,vkCmdEndRenderPass2KHR,(VK_KHR_create_renderpass2), The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdEndRenderPass2KHR-commandBuffer-parameter,Y,None,implicit,vkCmdEndRenderPass2KHR,(VK_KHR_create_renderpass2), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdEndRenderPass2KHR-commandBuffer-recording,N,None,implicit,vkCmdEndRenderPass2KHR,(VK_KHR_create_renderpass2), commandBuffer must be in the recording state
VUID-vkCmdEndRenderPass2KHR-pSubpassEndInfo-parameter,Y,None,implicit,vkCmdEndRenderPass2KHR,(VK_KHR_create_renderpass2), pSubpassEndInfo must be a valid pointer to a valid VkSubpassEndInfoKHR structure
VUID-vkCmdEndRenderPass2KHR-renderpass,N,None,implicit,vkCmdEndRenderPass2KHR,(VK_KHR_create_renderpass2), This command must only be called inside of a render pass instance
VUID-vkCmdExecuteCommands-bufferlevel,Y,None,implicit,vkCmdExecuteCommands,core, commandBuffer must be a primary VkCommandBuffer
VUID-vkCmdExecuteCommands-commandBuffer-00087,N,None,explicit,vkCmdExecuteCommands,core, commandBuffer must have been allocated with a level of VK_COMMAND_BUFFER_LEVEL_PRIMARY
VUID-vkCmdExecuteCommands-commandBuffer-00101,Y,None,explicit,vkCmdExecuteCommands,core," If the inherited queries feature is not enabled, commandBuffer must not have any queries active"
VUID-vkCmdExecuteCommands-commandBuffer-00102,N,None,explicit,vkCmdExecuteCommands,core," If commandBuffer has a VK_QUERY_TYPE_OCCLUSION query active, then each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::occlusionQueryEnable set to VK_TRUE"
VUID-vkCmdExecuteCommands-commandBuffer-00103,N,None,explicit,vkCmdExecuteCommands,core," If commandBuffer has a VK_QUERY_TYPE_OCCLUSION query active, then each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::queryFlags having all bits set that are set for the query"
VUID-vkCmdExecuteCommands-commandBuffer-00104,Y,None,explicit,vkCmdExecuteCommands,core," If commandBuffer has a VK_QUERY_TYPE_PIPELINE_STATISTICS query active, then each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::pipelineStatistics having all bits set that are set in the VkQueryPool the query uses"
VUID-vkCmdExecuteCommands-commandBuffer-01820,N,None,explicit,vkCmdExecuteCommands,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, then each element of pCommandBuffers must be a protected command buffer."
VUID-vkCmdExecuteCommands-commandBuffer-01821,N,None,explicit,vkCmdExecuteCommands,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, then each element of pCommandBuffers must be an unprotected command buffer."
VUID-vkCmdExecuteCommands-commandBuffer-cmdpool,Y,None,implicit,vkCmdExecuteCommands,core," The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations"
VUID-vkCmdExecuteCommands-commandBuffer-parameter,Y,None,implicit,vkCmdExecuteCommands,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdExecuteCommands-commandBuffer-recording,Y,None,implicit,vkCmdExecuteCommands,core, commandBuffer must be in the recording state
VUID-vkCmdExecuteCommands-commandBufferCount-arraylength,N,None,implicit,vkCmdExecuteCommands,core, commandBufferCount must be greater than 0
VUID-vkCmdExecuteCommands-commonparent,Y,None,implicit,vkCmdExecuteCommands,core," Both of commandBuffer, and the elements of pCommandBuffers must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdExecuteCommands-contents-00095,N,None,explicit,vkCmdExecuteCommands,core," If vkCmdExecuteCommands is being called within a render pass instance, that render pass instance must have been begun with the contents parameter of vkCmdBeginRenderPass set to VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS"
VUID-vkCmdExecuteCommands-pCommandBuffers-00088,Y,None,explicit,vkCmdExecuteCommands,core, Each element of pCommandBuffers must have been allocated with a level of VK_COMMAND_BUFFER_LEVEL_SECONDARY
VUID-vkCmdExecuteCommands-pCommandBuffers-00089,Y,ExecuteUnrecordedSecondaryCB,explicit,vkCmdExecuteCommands,core, Each element of pCommandBuffers must be in the pending or executable state.
VUID-vkCmdExecuteCommands-pCommandBuffers-00090,Y,None,explicit,vkCmdExecuteCommands,core," If any element of pCommandBuffers was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag, and it was recorded into any other primary command buffer, that primary command buffer must not be in the pending state"
VUID-vkCmdExecuteCommands-pCommandBuffers-00091,N,None,explicit,vkCmdExecuteCommands,core," If any element of pCommandBuffers was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag, it must not be in the pending state."
VUID-vkCmdExecuteCommands-pCommandBuffers-00092,N,None,explicit,vkCmdExecuteCommands,core," If any element of pCommandBuffers was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag, it must not have already been recorded to commandBuffer."
VUID-vkCmdExecuteCommands-pCommandBuffers-00093,N,None,explicit,vkCmdExecuteCommands,core," If any element of pCommandBuffers was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag, it must not appear more than once in pCommandBuffers."
VUID-vkCmdExecuteCommands-pCommandBuffers-00094,N,None,explicit,vkCmdExecuteCommands,core, Each element of pCommandBuffers must have been allocated from a VkCommandPool that was created for the same queue family as the VkCommandPool from which commandBuffer was allocated
VUID-vkCmdExecuteCommands-pCommandBuffers-00096,Y,None,explicit,vkCmdExecuteCommands,core," If vkCmdExecuteCommands is being called within a render pass instance, each element of pCommandBuffers must have been recorded with the VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT"
VUID-vkCmdExecuteCommands-pCommandBuffers-00097,N,None,explicit,vkCmdExecuteCommands,core," If vkCmdExecuteCommands is being called within a render pass instance, each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::subpass set to the index of the subpass which the given command buffer will be executed in"
VUID-vkCmdExecuteCommands-pCommandBuffers-00099,Y,None,explicit,vkCmdExecuteCommands,core," If vkCmdExecuteCommands is being called within a render pass instance, and any element of pCommandBuffers was recorded with VkCommandBufferInheritanceInfo::framebuffer not equal to VK_NULL_HANDLE, that VkFramebuffer must match the VkFramebuffer used in the current render pass instance"
VUID-vkCmdExecuteCommands-pCommandBuffers-00100,N,None,explicit,vkCmdExecuteCommands,core," If vkCmdExecuteCommands is not being called within a render pass instance, each element of pCommandBuffers must not have been recorded with the VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT"
VUID-vkCmdExecuteCommands-pCommandBuffers-00105,N,None,explicit,vkCmdExecuteCommands,core, Each element of pCommandBuffers must not begin any query types that are active in commandBuffer
VUID-vkCmdExecuteCommands-pCommandBuffers-parameter,Y,None,implicit,vkCmdExecuteCommands,core, pCommandBuffers must be a valid pointer to an array of commandBufferCount valid VkCommandBuffer handles
VUID-vkCmdExecuteCommands-pInheritanceInfo-00098,Y,None,explicit,vkCmdExecuteCommands,core," If vkCmdExecuteCommands is being called within a render pass instance, the render passes specified in the pBeginInfo::pInheritanceInfo::renderPass members of the vkBeginCommandBuffer commands used to begin recording each element of pCommandBuffers must be compatible with the current render pass."
VUID-vkCmdFillBuffer-commandBuffer-00030,N,None,explicit,vkCmdFillBuffer,"!(VK_VERSION_1_1,VK_KHR_maintenance1)", The VkCommandPool that commandBuffer was allocated from must support graphics or compute operations
VUID-vkCmdFillBuffer-commandBuffer-01811,N,None,explicit,vkCmdFillBuffer,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, then dstBuffer must not be a protected buffer"
VUID-vkCmdFillBuffer-commandBuffer-01812,N,None,explicit,vkCmdFillBuffer,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, then dstBuffer must not be an unprotected buffer"
VUID-vkCmdFillBuffer-commandBuffer-cmdpool,Y,None,implicit,vkCmdFillBuffer,core," The VkCommandPool that commandBuffer was allocated from must support transfer, graphics or compute operations"
VUID-vkCmdFillBuffer-commandBuffer-parameter,Y,None,implicit,vkCmdFillBuffer,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdFillBuffer-commandBuffer-recording,Y,None,implicit,vkCmdFillBuffer,core, commandBuffer must be in the recording state
VUID-vkCmdFillBuffer-commonparent,Y,None,implicit,vkCmdFillBuffer,core," Both of commandBuffer, and dstBuffer must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdFillBuffer-dstBuffer-00029,Y,None,explicit,vkCmdFillBuffer,core, dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag
VUID-vkCmdFillBuffer-dstBuffer-00031,Y,None,explicit,vkCmdFillBuffer,core, If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdFillBuffer-dstBuffer-parameter,Y,None,implicit,vkCmdFillBuffer,core, dstBuffer must be a valid VkBuffer handle
VUID-vkCmdFillBuffer-dstOffset-00024,N,None,explicit,vkCmdFillBuffer,core, dstOffset must be less than the size of dstBuffer
VUID-vkCmdFillBuffer-dstOffset-00025,Y,None,explicit,vkCmdFillBuffer,core, dstOffset must be a multiple of 4
VUID-vkCmdFillBuffer-renderpass,Y,None,implicit,vkCmdFillBuffer,core, This command must only be called outside of a render pass instance
VUID-vkCmdFillBuffer-size-00026,Y,None,explicit,vkCmdFillBuffer,core," If size is not equal to VK_WHOLE_SIZE, size must be greater than 0"
VUID-vkCmdFillBuffer-size-00027,N,None,explicit,vkCmdFillBuffer,core," If size is not equal to VK_WHOLE_SIZE, size must be less than or equal to the size of dstBuffer minus dstOffset"
VUID-vkCmdFillBuffer-size-00028,Y,None,explicit,vkCmdFillBuffer,core," If size is not equal to VK_WHOLE_SIZE, size must be a multiple of 4"
VUID-vkCmdInsertDebugUtilsLabelEXT-commandBuffer-cmdpool,N,None,implicit,vkCmdInsertDebugUtilsLabelEXT,(VK_EXT_debug_utils)," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdInsertDebugUtilsLabelEXT-commandBuffer-parameter,N,None,implicit,vkCmdInsertDebugUtilsLabelEXT,(VK_EXT_debug_utils), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdInsertDebugUtilsLabelEXT-commandBuffer-recording,N,None,implicit,vkCmdInsertDebugUtilsLabelEXT,(VK_EXT_debug_utils), commandBuffer must be in the recording state
VUID-vkCmdInsertDebugUtilsLabelEXT-pLabelInfo-parameter,Y,None,implicit,vkCmdInsertDebugUtilsLabelEXT,(VK_EXT_debug_utils), pLabelInfo must be a valid pointer to a valid VkDebugUtilsLabelEXT structure
VUID-vkCmdNextSubpass-None-00909,Y,None,explicit,vkCmdNextSubpass,core, The current subpass index must be less than the number of subpasses in the render pass minus one
VUID-vkCmdNextSubpass-bufferlevel,Y,None,implicit,vkCmdNextSubpass,core, commandBuffer must be a primary VkCommandBuffer
VUID-vkCmdNextSubpass-commandBuffer-cmdpool,Y,None,implicit,vkCmdNextSubpass,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdNextSubpass-commandBuffer-parameter,Y,None,implicit,vkCmdNextSubpass,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdNextSubpass-commandBuffer-recording,Y,None,implicit,vkCmdNextSubpass,core, commandBuffer must be in the recording state
VUID-vkCmdNextSubpass-contents-parameter,Y,None,implicit,vkCmdNextSubpass,core, contents must be a valid VkSubpassContents value
VUID-vkCmdNextSubpass-renderpass,Y,None,implicit,vkCmdNextSubpass,core, This command must only be called inside of a render pass instance
VUID-vkCmdNextSubpass2KHR-None-03102,N,None,explicit,vkCmdNextSubpass2KHR,(VK_KHR_create_renderpass2), The current subpass index must be less than the number of subpasses in the render pass minus one
VUID-vkCmdNextSubpass2KHR-bufferlevel,N,None,implicit,vkCmdNextSubpass2KHR,(VK_KHR_create_renderpass2), commandBuffer must be a primary VkCommandBuffer
VUID-vkCmdNextSubpass2KHR-commandBuffer-cmdpool,N,None,implicit,vkCmdNextSubpass2KHR,(VK_KHR_create_renderpass2), The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdNextSubpass2KHR-commandBuffer-parameter,Y,None,implicit,vkCmdNextSubpass2KHR,(VK_KHR_create_renderpass2), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdNextSubpass2KHR-commandBuffer-recording,N,None,implicit,vkCmdNextSubpass2KHR,(VK_KHR_create_renderpass2), commandBuffer must be in the recording state
VUID-vkCmdNextSubpass2KHR-pSubpassBeginInfo-parameter,Y,None,implicit,vkCmdNextSubpass2KHR,(VK_KHR_create_renderpass2), pSubpassBeginInfo must be a valid pointer to a valid VkSubpassBeginInfoKHR structure
VUID-vkCmdNextSubpass2KHR-pSubpassEndInfo-parameter,Y,None,implicit,vkCmdNextSubpass2KHR,(VK_KHR_create_renderpass2), pSubpassEndInfo must be a valid pointer to a valid VkSubpassEndInfoKHR structure
VUID-vkCmdNextSubpass2KHR-renderpass,N,None,implicit,vkCmdNextSubpass2KHR,(VK_KHR_create_renderpass2), This command must only be called inside of a render pass instance
VUID-vkCmdPipelineBarrier-bufferMemoryBarrierCount-01178,Y,RenderPassBarrierConflicts,explicit,vkCmdPipelineBarrier,core," If vkCmdPipelineBarrier is called within a render pass instance, bufferMemoryBarrierCount must be 0"
VUID-vkCmdPipelineBarrier-commandBuffer-cmdpool,Y,None,implicit,vkCmdPipelineBarrier,core," The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations"
VUID-vkCmdPipelineBarrier-commandBuffer-parameter,Y,None,implicit,vkCmdPipelineBarrier,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdPipelineBarrier-commandBuffer-recording,Y,None,implicit,vkCmdPipelineBarrier,core, commandBuffer must be in the recording state
VUID-vkCmdPipelineBarrier-dependencyFlags-01186,N,None,explicit,vkCmdPipelineBarrier,"(VK_VERSION_1_1,VK_KHR_multiview)"," If vkCmdPipelineBarrier is called outside of a render pass instance, dependencyFlags must not include VK_DEPENDENCY_VIEW_LOCAL_BIT"
VUID-vkCmdPipelineBarrier-dependencyFlags-parameter,Y,None,implicit,vkCmdPipelineBarrier,core, dependencyFlags must be a valid combination of VkDependencyFlagBits values
VUID-vkCmdPipelineBarrier-dstStageMask-01169,Y,None,explicit,vkCmdPipelineBarrier,core," If the geometry shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"
VUID-vkCmdPipelineBarrier-dstStageMask-01171,Y,None,explicit,vkCmdPipelineBarrier,core," If the tessellation shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"
VUID-vkCmdPipelineBarrier-dstStageMask-02117,Y,MeshShaderDisabledNV,explicit,vkCmdPipelineBarrier,(VK_NV_mesh_shader)," If the mesh shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV"
VUID-vkCmdPipelineBarrier-dstStageMask-02118,Y,MeshShaderDisabledNV,explicit,vkCmdPipelineBarrier,(VK_NV_mesh_shader)," If the task shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV"
VUID-vkCmdPipelineBarrier-dstStageMask-parameter,N,None,implicit,vkCmdPipelineBarrier,core, dstStageMask must be a valid combination of VkPipelineStageFlagBits values
VUID-vkCmdPipelineBarrier-dstStageMask-requiredbitmask,Y,None,implicit,vkCmdPipelineBarrier,core, dstStageMask must not be 0
VUID-vkCmdPipelineBarrier-image-01179,Y,"ImageBarrierSubpassConflict, RenderPassBarrierConflicts, InvalidSecondaryCommandBufferBarrier",explicit,vkCmdPipelineBarrier,core," If vkCmdPipelineBarrier is called within a render pass instance, the image member of any element of pImageMemoryBarriers must be equal to one of the elements of pAttachments that the current framebuffer was created with, that is also referred to by one of the elements of the pColorAttachments, pResolveAttachments or pDepthStencilAttachment members of the VkSubpassDescription instance that the current subpass was created with"
VUID-vkCmdPipelineBarrier-oldLayout-01180,Y,RenderPassBarrierConflicts,explicit,vkCmdPipelineBarrier,core," If vkCmdPipelineBarrier is called within a render pass instance, the oldLayout and newLayout members of any element of pImageMemoryBarriers must be equal to the layout member of an element of the pColorAttachments, pResolveAttachments or pDepthStencilAttachment members of the VkSubpassDescription instance that the current subpass was created with, that refers to the same image"
VUID-vkCmdPipelineBarrier-oldLayout-01181,Y,RenderPassBarrierConflicts,explicit,vkCmdPipelineBarrier,core," If vkCmdPipelineBarrier is called within a render pass instance, the oldLayout and newLayout members of an element of pImageMemoryBarriers must be equal"
VUID-vkCmdPipelineBarrier-pBufferMemoryBarriers-parameter,Y,None,implicit,vkCmdPipelineBarrier,core," If bufferMemoryBarrierCount is not 0, pBufferMemoryBarriers must be a valid pointer to an array of bufferMemoryBarrierCount valid VkBufferMemoryBarrier structures"
VUID-vkCmdPipelineBarrier-pDependencies-02024,Y,RenderPassBarrierConflicts,explicit,vkCmdPipelineBarrier,core," If vkCmdPipelineBarrier is called within a render pass instance, the render pass must have been created with at least one VkSubpassDependency instance in VkRenderPassCreateInfo::pDependencies that expresses a dependency from the current subpass to itself, and for which srcStageMask contains a subset of the bit values in VkSubpassDependency::srcStageMask, dstStageMask contains a subset of the bit values in VkSubpassDependency::dstStageMask, and dependencyFlags is equal to VkSubpassDependency::dependencyFlags."
VUID-vkCmdPipelineBarrier-pImageMemoryBarriers-parameter,Y,None,implicit,vkCmdPipelineBarrier,core," If imageMemoryBarrierCount is not 0, pImageMemoryBarriers must be a valid pointer to an array of imageMemoryBarrierCount valid VkImageMemoryBarrier structures"
VUID-vkCmdPipelineBarrier-pMemoryBarriers-01184,Y,InvalidBarriers,explicit,vkCmdPipelineBarrier,core," Each element of pMemoryBarriers, pBufferMemoryBarriers and pImageMemoryBarriers must not have any access flag included in its srcAccessMask member if that bit is not supported by any of the pipeline stages in srcStageMask, as specified in the table of supported access types."
VUID-vkCmdPipelineBarrier-pMemoryBarriers-01185,Y,InvalidBarriers,explicit,vkCmdPipelineBarrier,core," Each element of pMemoryBarriers, pBufferMemoryBarriers and pImageMemoryBarriers must not have any access flag included in its dstAccessMask member if that bit is not supported by any of the pipeline stages in dstStageMask, as specified in the table of supported access types."
VUID-vkCmdPipelineBarrier-pMemoryBarriers-02026,N,None,explicit,vkCmdPipelineBarrier,core," If vkCmdPipelineBarrier is called within a render pass instance, for each element of pMemoryBarriers and pImageMemoryBarriers, the render pass must have been defined with a VkSubpassDependency self-dependency for the current subpass with valid srcStageMask, dstStageMask, and dependencyFlags values such that Vk*Barrier::srcAccessMask contains a subset of the bit values in VkSubpassDependency::srcAccessMask and Vk*Barrier::dstAccessMask contains a subset of the bit values in VkSubpassDependency::dstAccessMask."
VUID-vkCmdPipelineBarrier-pMemoryBarriers-parameter,Y,None,implicit,vkCmdPipelineBarrier,core," If memoryBarrierCount is not 0, pMemoryBarriers must be a valid pointer to an array of memoryBarrierCount valid VkMemoryBarrier structures"
VUID-vkCmdPipelineBarrier-srcQueueFamilyIndex-01182,Y,RenderPassBarrierConflicts,explicit,vkCmdPipelineBarrier,core," If vkCmdPipelineBarrier is called within a render pass instance, the srcQueueFamilyIndex and dstQueueFamilyIndex members of any element of pImageMemoryBarriers must be VK_QUEUE_FAMILY_IGNORED"
VUID-vkCmdPipelineBarrier-srcStageMask-01168,Y,None,explicit,vkCmdPipelineBarrier,core," If the geometry shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"
VUID-vkCmdPipelineBarrier-srcStageMask-01170,Y,None,explicit,vkCmdPipelineBarrier,core," If the tessellation shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"
VUID-vkCmdPipelineBarrier-srcStageMask-01183,Y,InvalidBarriers,explicit,vkCmdPipelineBarrier,core," Any pipeline stage included in srcStageMask or dstStageMask must be supported by the capabilities of the queue family specified by the queueFamilyIndex member of the VkCommandPoolCreateInfo structure that was used to create the VkCommandPool that commandBuffer was allocated from, as specified in the table of supported pipeline stages."
VUID-vkCmdPipelineBarrier-srcStageMask-02115,Y,MeshShaderDisabledNV,explicit,vkCmdPipelineBarrier,(VK_NV_mesh_shader)," If the mesh shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV"
VUID-vkCmdPipelineBarrier-srcStageMask-02116,Y,MeshShaderDisabledNV,explicit,vkCmdPipelineBarrier,(VK_NV_mesh_shader)," If the task shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV"
VUID-vkCmdPipelineBarrier-srcStageMask-parameter,N,None,implicit,vkCmdPipelineBarrier,core, srcStageMask must be a valid combination of VkPipelineStageFlagBits values
VUID-vkCmdPipelineBarrier-srcStageMask-requiredbitmask,Y,None,implicit,vkCmdPipelineBarrier,core, srcStageMask must not be 0
VUID-vkCmdProcessCommandsNVX-commandBuffer-cmdpool,N,None,implicit,vkCmdProcessCommandsNVX,(VK_NVX_device_generated_commands)," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdProcessCommandsNVX-commandBuffer-parameter,Y,None,implicit,vkCmdProcessCommandsNVX,(VK_NVX_device_generated_commands), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdProcessCommandsNVX-commandBuffer-recording,N,None,implicit,vkCmdProcessCommandsNVX,(VK_NVX_device_generated_commands), commandBuffer must be in the recording state
VUID-vkCmdProcessCommandsNVX-pProcessCommandsInfo-parameter,Y,None,implicit,vkCmdProcessCommandsNVX,(VK_NVX_device_generated_commands), pProcessCommandsInfo must be a valid pointer to a valid VkCmdProcessCommandsInfoNVX structure
VUID-vkCmdProcessCommandsNVX-renderpass,N,None,implicit,vkCmdProcessCommandsNVX,(VK_NVX_device_generated_commands), This command must only be called inside of a render pass instance
VUID-vkCmdPushConstants-commandBuffer-cmdpool,Y,None,implicit,vkCmdPushConstants,core," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdPushConstants-commandBuffer-parameter,Y,None,implicit,vkCmdPushConstants,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdPushConstants-commandBuffer-recording,Y,None,implicit,vkCmdPushConstants,core, commandBuffer must be in the recording state
VUID-vkCmdPushConstants-commonparent,Y,None,implicit,vkCmdPushConstants,core," Both of commandBuffer, and layout must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdPushConstants-layout-parameter,Y,None,implicit,vkCmdPushConstants,core, layout must be a valid VkPipelineLayout handle
VUID-vkCmdPushConstants-offset-00368,Y,None,explicit,vkCmdPushConstants,core, offset must be a multiple of 4
VUID-vkCmdPushConstants-offset-00370,Y,None,explicit,vkCmdPushConstants,core, offset must be less than VkPhysicalDeviceLimits::maxPushConstantsSize
VUID-vkCmdPushConstants-offset-01795,Y,InvalidPushConstants,explicit,vkCmdPushConstants,core," For each byte in the range specified by offset and size and for each shader stage in stageFlags, there must be a push constant range in layout that includes that byte and that stage"
VUID-vkCmdPushConstants-offset-01796,Y,InvalidPushConstants,explicit,vkCmdPushConstants,core," For each byte in the range specified by offset and size and for each push constant range that overlaps that byte, stageFlags must include all stages in that push constant range's VkPushConstantRange::stageFlags"
VUID-vkCmdPushConstants-pValues-parameter,Y,None,implicit,vkCmdPushConstants,core, pValues must be a valid pointer to an array of size bytes
VUID-vkCmdPushConstants-size-00369,Y,None,explicit,vkCmdPushConstants,core, size must be a multiple of 4
VUID-vkCmdPushConstants-size-00371,Y,None,explicit,vkCmdPushConstants,core, size must be less than or equal to VkPhysicalDeviceLimits::maxPushConstantsSize minus offset
VUID-vkCmdPushConstants-size-arraylength,Y,None,implicit,vkCmdPushConstants,core, size must be greater than 0
VUID-vkCmdPushConstants-stageFlags-parameter,N,None,implicit,vkCmdPushConstants,core, stageFlags must be a valid combination of VkShaderStageFlagBits values
VUID-vkCmdPushConstants-stageFlags-requiredbitmask,Y,None,implicit,vkCmdPushConstants,core, stageFlags must not be 0
VUID-vkCmdPushDescriptorSetKHR-commandBuffer-cmdpool,Y,PushDescriptorSetCmdPushBadArgs,implicit,vkCmdPushDescriptorSetKHR,(VK_KHR_push_descriptor)," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdPushDescriptorSetKHR-commandBuffer-parameter,Y,None,implicit,vkCmdPushDescriptorSetKHR,(VK_KHR_push_descriptor), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdPushDescriptorSetKHR-commandBuffer-recording,Y,None,implicit,vkCmdPushDescriptorSetKHR,(VK_KHR_push_descriptor), commandBuffer must be in the recording state
VUID-vkCmdPushDescriptorSetKHR-commonparent,Y,None,implicit,vkCmdPushDescriptorSetKHR,(VK_KHR_push_descriptor)," Both of commandBuffer, and layout must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdPushDescriptorSetKHR-descriptorWriteCount-arraylength,N,None,implicit,vkCmdPushDescriptorSetKHR,(VK_KHR_push_descriptor), descriptorWriteCount must be greater than 0
VUID-vkCmdPushDescriptorSetKHR-layout-parameter,Y,None,implicit,vkCmdPushDescriptorSetKHR,(VK_KHR_push_descriptor), layout must be a valid VkPipelineLayout handle
VUID-vkCmdPushDescriptorSetKHR-pDescriptorWrites-parameter,Y,None,implicit,vkCmdPushDescriptorSetKHR,(VK_KHR_push_descriptor), pDescriptorWrites must be a valid pointer to an array of descriptorWriteCount valid VkWriteDescriptorSet structures
VUID-vkCmdPushDescriptorSetKHR-pipelineBindPoint-00363,Y,PushDescriptorSetCmdPushBadArgs,explicit,vkCmdPushDescriptorSetKHR,(VK_KHR_push_descriptor), pipelineBindPoint must be supported by the commandBuffer's parent VkCommandPool's queue family
VUID-vkCmdPushDescriptorSetKHR-pipelineBindPoint-parameter,Y,None,implicit,vkCmdPushDescriptorSetKHR,(VK_KHR_push_descriptor), pipelineBindPoint must be a valid VkPipelineBindPoint value
VUID-vkCmdPushDescriptorSetKHR-set-00364,Y,PushDescriptorSetCmdPushBadArgs,explicit,vkCmdPushDescriptorSetKHR,(VK_KHR_push_descriptor), set must be less than VkPipelineLayoutCreateInfo::setLayoutCount provided when layout was created
VUID-vkCmdPushDescriptorSetKHR-set-00365,Y,PushDescriptorSetCmdPushBadArgs,explicit,vkCmdPushDescriptorSetKHR,(VK_KHR_push_descriptor), set must be the unique set number in the pipeline layout that uses a descriptor set layout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR
VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-00366,N,None,explicit,vkCmdPushDescriptorSetWithTemplateKHR,"(VK_KHR_push_descriptor)+(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", The pipelineBindPoint specified during the creation of the descriptor update template must be supported by the commandBuffer's parent VkCommandPool's queue family
VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-cmdpool,N,None,implicit,vkCmdPushDescriptorSetWithTemplateKHR,"(VK_KHR_push_descriptor)+(VK_VERSION_1_1,VK_KHR_descriptor_update_template)"," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-parameter,Y,None,implicit,vkCmdPushDescriptorSetWithTemplateKHR,"(VK_KHR_push_descriptor)+(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-recording,Y,None,implicit,vkCmdPushDescriptorSetWithTemplateKHR,"(VK_KHR_push_descriptor)+(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", commandBuffer must be in the recording state
VUID-vkCmdPushDescriptorSetWithTemplateKHR-commonparent,Y,None,implicit,vkCmdPushDescriptorSetWithTemplateKHR,"(VK_KHR_push_descriptor)+(VK_VERSION_1_1,VK_KHR_descriptor_update_template)"," Each of commandBuffer, descriptorUpdateTemplate, and layout must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdPushDescriptorSetWithTemplateKHR-descriptorUpdateTemplate-parameter,Y,None,implicit,vkCmdPushDescriptorSetWithTemplateKHR,"(VK_KHR_push_descriptor)+(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", descriptorUpdateTemplate must be a valid VkDescriptorUpdateTemplate handle
VUID-vkCmdPushDescriptorSetWithTemplateKHR-layout-parameter,Y,None,implicit,vkCmdPushDescriptorSetWithTemplateKHR,"(VK_KHR_push_descriptor)+(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", layout must be a valid VkPipelineLayout handle
VUID-vkCmdPushDescriptorSetWithTemplateKHR-pData-01686,N,None,explicit,vkCmdPushDescriptorSetWithTemplateKHR,"(VK_KHR_push_descriptor)+(VK_VERSION_1_1,VK_KHR_descriptor_update_template)"," pData must be a valid pointer to a memory that contains one or more valid instances of VkDescriptorImageInfo, VkDescriptorBufferInfo, or VkBufferView in a layout defined by descriptorUpdateTemplate when it was created with vkCreateDescriptorUpdateTemplateKHR"
VUID-vkCmdReserveSpaceForCommandsNVX-bufferlevel,N,None,implicit,vkCmdReserveSpaceForCommandsNVX,(VK_NVX_device_generated_commands), commandBuffer must be a secondary VkCommandBuffer
VUID-vkCmdReserveSpaceForCommandsNVX-commandBuffer-01329,N,None,explicit,vkCmdReserveSpaceForCommandsNVX,(VK_NVX_device_generated_commands), The provided commandBuffer must not have had a prior space reservation since its creation or the last reset.
VUID-vkCmdReserveSpaceForCommandsNVX-commandBuffer-01330,N,None,explicit,vkCmdReserveSpaceForCommandsNVX,(VK_NVX_device_generated_commands), The state of the commandBuffer must be legal to execute all commands within the sequence provided by the indirectCommandsLayout member of pProcessCommandsInfo.
VUID-vkCmdReserveSpaceForCommandsNVX-commandBuffer-cmdpool,N,None,implicit,vkCmdReserveSpaceForCommandsNVX,(VK_NVX_device_generated_commands)," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdReserveSpaceForCommandsNVX-commandBuffer-parameter,Y,None,implicit,vkCmdReserveSpaceForCommandsNVX,(VK_NVX_device_generated_commands), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdReserveSpaceForCommandsNVX-commandBuffer-recording,N,None,implicit,vkCmdReserveSpaceForCommandsNVX,(VK_NVX_device_generated_commands), commandBuffer must be in the recording state
VUID-vkCmdReserveSpaceForCommandsNVX-pReserveSpaceInfo-parameter,Y,None,implicit,vkCmdReserveSpaceForCommandsNVX,(VK_NVX_device_generated_commands), pReserveSpaceInfo must be a valid pointer to a valid VkCmdReserveSpaceForCommandsInfoNVX structure
VUID-vkCmdReserveSpaceForCommandsNVX-renderpass,N,None,implicit,vkCmdReserveSpaceForCommandsNVX,(VK_NVX_device_generated_commands), This command must only be called inside of a render pass instance
VUID-vkCmdResetEvent-commandBuffer-01157,N,None,explicit,vkCmdResetEvent,"(VK_VERSION_1_1,VK_KHR_device_group)", commandBuffer's current device mask must include exactly one physical device.
VUID-vkCmdResetEvent-commandBuffer-cmdpool,Y,None,implicit,vkCmdResetEvent,core," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdResetEvent-commandBuffer-parameter,Y,None,implicit,vkCmdResetEvent,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdResetEvent-commandBuffer-recording,Y,None,implicit,vkCmdResetEvent,core, commandBuffer must be in the recording state
VUID-vkCmdResetEvent-commonparent,Y,None,implicit,vkCmdResetEvent,core," Both of commandBuffer, and event must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdResetEvent-event-01156,N,None,explicit,vkCmdResetEvent,core," When this command executes, event must not be waited on by a vkCmdWaitEvents command that is currently executing"
VUID-vkCmdResetEvent-event-parameter,Y,None,implicit,vkCmdResetEvent,core, event must be a valid VkEvent handle
VUID-vkCmdResetEvent-renderpass,Y,None,implicit,vkCmdResetEvent,core, This command must only be called outside of a render pass instance
VUID-vkCmdResetEvent-stageMask-01153,N,None,explicit,vkCmdResetEvent,core, stageMask must not include VK_PIPELINE_STAGE_HOST_BIT
VUID-vkCmdResetEvent-stageMask-01154,Y,None,explicit,vkCmdResetEvent,core," If the geometry shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"
VUID-vkCmdResetEvent-stageMask-01155,Y,None,explicit,vkCmdResetEvent,core," If the tessellation shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"
VUID-vkCmdResetEvent-stageMask-02109,Y,MeshShaderDisabledNV,explicit,vkCmdResetEvent,(VK_NV_mesh_shader)," If the mesh shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV"
VUID-vkCmdResetEvent-stageMask-02110,Y,MeshShaderDisabledNV,explicit,vkCmdResetEvent,(VK_NV_mesh_shader)," If the task shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV"
VUID-vkCmdResetEvent-stageMask-parameter,N,None,implicit,vkCmdResetEvent,core, stageMask must be a valid combination of VkPipelineStageFlagBits values
VUID-vkCmdResetEvent-stageMask-requiredbitmask,Y,None,implicit,vkCmdResetEvent,core, stageMask must not be 0
VUID-vkCmdResetQueryPool-commandBuffer-cmdpool,Y,None,implicit,vkCmdResetQueryPool,core," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdResetQueryPool-commandBuffer-parameter,Y,None,implicit,vkCmdResetQueryPool,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdResetQueryPool-commandBuffer-recording,Y,None,implicit,vkCmdResetQueryPool,core, commandBuffer must be in the recording state
VUID-vkCmdResetQueryPool-commonparent,Y,None,implicit,vkCmdResetQueryPool,core," Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdResetQueryPool-firstQuery-00796,N,None,explicit,vkCmdResetQueryPool,core, firstQuery must be less than the number of queries in queryPool
VUID-vkCmdResetQueryPool-firstQuery-00797,N,None,explicit,vkCmdResetQueryPool,core, The sum of firstQuery and queryCount must be less than or equal to the number of queries in queryPool
VUID-vkCmdResetQueryPool-queryPool-parameter,Y,None,implicit,vkCmdResetQueryPool,core, queryPool must be a valid VkQueryPool handle
VUID-vkCmdResetQueryPool-renderpass,Y,None,implicit,vkCmdResetQueryPool,core, This command must only be called outside of a render pass instance
VUID-vkCmdResolveImage-commandBuffer-01837,N,None,explicit,vkCmdResolveImage,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, then srcImage must not be a protected image"
VUID-vkCmdResolveImage-commandBuffer-01838,N,None,explicit,vkCmdResolveImage,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, then dstImage must not be a protected image"
VUID-vkCmdResolveImage-commandBuffer-01839,N,None,explicit,vkCmdResolveImage,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, then dstImage must not be an unprotected image"
VUID-vkCmdResolveImage-commandBuffer-cmdpool,Y,None,implicit,vkCmdResolveImage,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdResolveImage-commandBuffer-parameter,Y,None,implicit,vkCmdResolveImage,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdResolveImage-commandBuffer-recording,Y,None,implicit,vkCmdResolveImage,core, commandBuffer must be in the recording state
VUID-vkCmdResolveImage-commonparent,Y,None,implicit,vkCmdResolveImage,core," Each of commandBuffer, dstImage, and srcImage must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdResolveImage-dstImage-00258,Y,None,explicit,vkCmdResolveImage,core, If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdResolveImage-dstImage-00259,Y,None,explicit,vkCmdResolveImage,core, dstImage must have a sample count equal to VK_SAMPLE_COUNT_1_BIT
VUID-vkCmdResolveImage-dstImage-02003,Y,None,explicit,vkCmdResolveImage,core, The format features of dstImage must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT.
VUID-vkCmdResolveImage-dstImage-parameter,Y,None,implicit,vkCmdResolveImage,core, dstImage must be a valid VkImage handle
VUID-vkCmdResolveImage-dstImageLayout-00262,Y,ResolveImageLayoutMismatch,explicit,vkCmdResolveImage,core, dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice
VUID-vkCmdResolveImage-dstImageLayout-00263,Y,None,explicit,vkCmdResolveImage,!(VK_KHR_shared_presentable_image), dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL
VUID-vkCmdResolveImage-dstImageLayout-01401,Y,None,explicit,vkCmdResolveImage,(VK_KHR_shared_presentable_image)," dstImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL"
VUID-vkCmdResolveImage-dstImageLayout-parameter,Y,None,implicit,vkCmdResolveImage,core, dstImageLayout must be a valid VkImageLayout value
VUID-vkCmdResolveImage-dstSubresource-01710,Y,ResolveInvalidSubresource,explicit,vkCmdResolveImage,core, The dstSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created
VUID-vkCmdResolveImage-dstSubresource-01712,Y,ResolveInvalidSubresource,explicit,vkCmdResolveImage,core, The dstSubresource.baseArrayLayer + dstSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created
VUID-vkCmdResolveImage-pRegions-00253,N,None,explicit,vkCmdResolveImage,core, The source region specified by each element of pRegions must be a region that is contained within srcImage
VUID-vkCmdResolveImage-pRegions-00254,N,None,explicit,vkCmdResolveImage,core, The destination region specified by each element of pRegions must be a region that is contained within dstImage
VUID-vkCmdResolveImage-pRegions-00255,N,None,explicit,vkCmdResolveImage,core," The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory"
VUID-vkCmdResolveImage-pRegions-parameter,Y,None,implicit,vkCmdResolveImage,core, pRegions must be a valid pointer to an array of regionCount valid VkImageResolve structures
VUID-vkCmdResolveImage-regionCount-arraylength,Y,None,implicit,vkCmdResolveImage,core, regionCount must be greater than 0
VUID-vkCmdResolveImage-renderpass,Y,None,implicit,vkCmdResolveImage,core, This command must only be called outside of a render pass instance
VUID-vkCmdResolveImage-srcImage-00256,Y,None,explicit,vkCmdResolveImage,core, If srcImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdResolveImage-srcImage-00257,Y,None,explicit,vkCmdResolveImage,core, srcImage must have a sample count equal to any valid sample count value other than VK_SAMPLE_COUNT_1_BIT
VUID-vkCmdResolveImage-srcImage-01386,N,None,explicit,vkCmdResolveImage,core, srcImage and dstImage must have been created with the same image format
VUID-vkCmdResolveImage-srcImage-parameter,Y,None,implicit,vkCmdResolveImage,core, srcImage must be a valid VkImage handle
VUID-vkCmdResolveImage-srcImageLayout-00260,Y,ResolveImageLayoutMismatch,explicit,vkCmdResolveImage,core, srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice
VUID-vkCmdResolveImage-srcImageLayout-00261,Y,None,explicit,vkCmdResolveImage,!(VK_KHR_shared_presentable_image), srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL
VUID-vkCmdResolveImage-srcImageLayout-01400,Y,None,explicit,vkCmdResolveImage,(VK_KHR_shared_presentable_image)," srcImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL"
VUID-vkCmdResolveImage-srcImageLayout-parameter,Y,None,implicit,vkCmdResolveImage,core, srcImageLayout must be a valid VkImageLayout value
VUID-vkCmdResolveImage-srcSubresource-01709,Y,ResolveInvalidSubresource,explicit,vkCmdResolveImage,core, The srcSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created
VUID-vkCmdResolveImage-srcSubresource-01711,Y,ResolveInvalidSubresource,explicit,vkCmdResolveImage,core, The srcSubresource.baseArrayLayer + srcSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created
VUID-vkCmdSetBlendConstants-None-00612,Y,None,explicit,vkCmdSetBlendConstants,core, The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_BLEND_CONSTANTS dynamic state enabled
VUID-vkCmdSetBlendConstants-commandBuffer-cmdpool,Y,None,implicit,vkCmdSetBlendConstants,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdSetBlendConstants-commandBuffer-parameter,Y,None,implicit,vkCmdSetBlendConstants,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdSetBlendConstants-commandBuffer-recording,Y,None,implicit,vkCmdSetBlendConstants,core, commandBuffer must be in the recording state
VUID-vkCmdSetCheckpointNV-commandBuffer-cmdpool,N,None,implicit,vkCmdSetCheckpointNV,(VK_NV_device_diagnostic_checkpoints)," The VkCommandPool that commandBuffer was allocated from must support graphics, compute, or transfer operations"
VUID-vkCmdSetCheckpointNV-commandBuffer-parameter,Y,None,implicit,vkCmdSetCheckpointNV,(VK_NV_device_diagnostic_checkpoints), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdSetCheckpointNV-commandBuffer-recording,N,None,implicit,vkCmdSetCheckpointNV,(VK_NV_device_diagnostic_checkpoints), commandBuffer must be in the recording state
VUID-vkCmdSetCoarseSampleOrderNV-commandBuffer-cmdpool,N,None,implicit,vkCmdSetCoarseSampleOrderNV,(VK_NV_shading_rate_image), The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdSetCoarseSampleOrderNV-commandBuffer-parameter,Y,None,implicit,vkCmdSetCoarseSampleOrderNV,(VK_NV_shading_rate_image), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdSetCoarseSampleOrderNV-commandBuffer-recording,N,None,implicit,vkCmdSetCoarseSampleOrderNV,(VK_NV_shading_rate_image), commandBuffer must be in the recording state
VUID-vkCmdSetCoarseSampleOrderNV-pCustomSampleOrders-02235,N,None,explicit,vkCmdSetCoarseSampleOrderNV,(VK_NV_shading_rate_image), The array pCustomSampleOrders must not contain two structures with matching values for both the shadingRate and sampleCount members.
VUID-vkCmdSetCoarseSampleOrderNV-pCustomSampleOrders-parameter,Y,None,implicit,vkCmdSetCoarseSampleOrderNV,(VK_NV_shading_rate_image)," If customSampleOrderCount is not 0, pCustomSampleOrders must be a valid pointer to an array of customSampleOrderCount valid VkCoarseSampleOrderCustomNV structures"
VUID-vkCmdSetCoarseSampleOrderNV-sampleOrderType-02081,Y,ShadingRateImageNV,explicit,vkCmdSetCoarseSampleOrderNV,(VK_NV_shading_rate_image)," If sampleOrderType is not VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV, customSamplerOrderCount must be 0"
VUID-vkCmdSetCoarseSampleOrderNV-sampleOrderType-parameter,Y,None,implicit,vkCmdSetCoarseSampleOrderNV,(VK_NV_shading_rate_image), sampleOrderType must be a valid VkCoarseSampleOrderTypeNV value
VUID-vkCmdSetDepthBias-None-00789,Y,None,explicit,vkCmdSetDepthBias,core, The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_DEPTH_BIAS dynamic state enabled
VUID-vkCmdSetDepthBias-commandBuffer-cmdpool,Y,None,implicit,vkCmdSetDepthBias,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdSetDepthBias-commandBuffer-parameter,Y,None,implicit,vkCmdSetDepthBias,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdSetDepthBias-commandBuffer-recording,Y,None,implicit,vkCmdSetDepthBias,core, commandBuffer must be in the recording state
VUID-vkCmdSetDepthBias-depthBiasClamp-00790,Y,None,explicit,vkCmdSetDepthBias,core," If the depth bias clamping feature is not enabled, depthBiasClamp must be 0.0"
VUID-vkCmdSetDepthBounds-None-00599,Y,None,explicit,vkCmdSetDepthBounds,core, The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_DEPTH_BOUNDS dynamic state enabled
VUID-vkCmdSetDepthBounds-commandBuffer-cmdpool,Y,None,implicit,vkCmdSetDepthBounds,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdSetDepthBounds-commandBuffer-parameter,Y,None,implicit,vkCmdSetDepthBounds,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdSetDepthBounds-commandBuffer-recording,Y,None,implicit,vkCmdSetDepthBounds,core, commandBuffer must be in the recording state
VUID-vkCmdSetDepthBounds-maxDepthBounds-00601,N,None,explicit,vkCmdSetDepthBounds,(VK_EXT_depth_range_unrestricted)," Unless the VK_EXT_depth_range_unrestricted extension is enabled maxDepthBounds must be between 0.0 and 1.0, inclusive"
VUID-vkCmdSetDepthBounds-maxDepthBounds-00601,N,None,explicit,vkCmdSetDepthBounds,!(VK_EXT_depth_range_unrestricted)," maxDepthBounds must be between 0.0 and 1.0, inclusive"
VUID-vkCmdSetDepthBounds-minDepthBounds-00600,N,None,explicit,vkCmdSetDepthBounds,(VK_EXT_depth_range_unrestricted)," Unless the VK_EXT_depth_range_unrestricted extension is enabled minDepthBounds must be between 0.0 and 1.0, inclusive"
VUID-vkCmdSetDepthBounds-minDepthBounds-00600,N,None,explicit,vkCmdSetDepthBounds,!(VK_EXT_depth_range_unrestricted)," minDepthBounds must be between 0.0 and 1.0, inclusive"
VUID-vkCmdSetDeviceMask-commandBuffer-cmdpool,N,None,implicit,vkCmdSetDeviceMask,"(VK_VERSION_1_1,VK_KHR_device_group)"," The VkCommandPool that commandBuffer was allocated from must support graphics, compute, or transfer operations"
VUID-vkCmdSetDeviceMask-commandBuffer-parameter,Y,None,implicit,vkCmdSetDeviceMask,"(VK_VERSION_1_1,VK_KHR_device_group)", commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdSetDeviceMask-commandBuffer-recording,N,None,implicit,vkCmdSetDeviceMask,"(VK_VERSION_1_1,VK_KHR_device_group)", commandBuffer must be in the recording state
VUID-vkCmdSetDeviceMask-deviceMask-00108,N,None,explicit,vkCmdSetDeviceMask,"(VK_VERSION_1_1,VK_KHR_device_group)", deviceMask must be a valid device mask value
VUID-vkCmdSetDeviceMask-deviceMask-00109,N,None,explicit,vkCmdSetDeviceMask,"(VK_VERSION_1_1,VK_KHR_device_group)", deviceMask must not be zero
VUID-vkCmdSetDeviceMask-deviceMask-00110,N,None,explicit,vkCmdSetDeviceMask,"(VK_VERSION_1_1,VK_KHR_device_group)", deviceMask must not include any set bits that were not in the VkDeviceGroupCommandBufferBeginInfo::deviceMask value when the command buffer began recording.
VUID-vkCmdSetDeviceMask-deviceMask-00111,N,None,explicit,vkCmdSetDeviceMask,"(VK_VERSION_1_1,VK_KHR_device_group)"," If vkCmdSetDeviceMask is called inside a render pass instance, deviceMask must not include any set bits that were not in the VkDeviceGroupRenderPassBeginInfo::deviceMask value when the render pass instance began recording."
VUID-vkCmdSetDiscardRectangleEXT-None-00583,N,None,explicit,vkCmdSetDiscardRectangleEXT,(VK_EXT_discard_rectangles), The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT dynamic state enabled
VUID-vkCmdSetDiscardRectangleEXT-commandBuffer-cmdpool,N,None,implicit,vkCmdSetDiscardRectangleEXT,(VK_EXT_discard_rectangles), The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdSetDiscardRectangleEXT-commandBuffer-parameter,Y,None,implicit,vkCmdSetDiscardRectangleEXT,(VK_EXT_discard_rectangles), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdSetDiscardRectangleEXT-commandBuffer-recording,Y,None,implicit,vkCmdSetDiscardRectangleEXT,(VK_EXT_discard_rectangles), commandBuffer must be in the recording state
VUID-vkCmdSetDiscardRectangleEXT-discardRectangleCount-arraylength,Y,None,implicit,vkCmdSetDiscardRectangleEXT,(VK_EXT_discard_rectangles), discardRectangleCount must be greater than 0
VUID-vkCmdSetDiscardRectangleEXT-firstDiscardRectangle-00585,N,None,explicit,vkCmdSetDiscardRectangleEXT,(VK_EXT_discard_rectangles), The sum of firstDiscardRectangle and discardRectangleCount must be less than or equal to VkPhysicalDeviceDiscardRectanglePropertiesEXT::maxDiscardRectangles
VUID-vkCmdSetDiscardRectangleEXT-offset-00588,N,None,explicit,vkCmdSetDiscardRectangleEXT,(VK_EXT_discard_rectangles), Evaluation of (offset.x + extent.width) in each VkRect2D element of pDiscardRectangles must not cause a signed integer addition overflow
VUID-vkCmdSetDiscardRectangleEXT-offset-00589,N,None,explicit,vkCmdSetDiscardRectangleEXT,(VK_EXT_discard_rectangles), Evaluation of (offset.y + extent.height) in each VkRect2D element of pDiscardRectangles must not cause a signed integer addition overflow
VUID-vkCmdSetDiscardRectangleEXT-pDiscardRectangles-parameter,Y,None,implicit,vkCmdSetDiscardRectangleEXT,(VK_EXT_discard_rectangles), pDiscardRectangles must be a valid pointer to an array of discardRectangleCount VkRect2D structures
VUID-vkCmdSetDiscardRectangleEXT-x-00587,N,None,explicit,vkCmdSetDiscardRectangleEXT,(VK_EXT_discard_rectangles), The x and y member of offset in each VkRect2D element of pDiscardRectangles must be greater than or equal to 0
VUID-vkCmdSetEvent-commandBuffer-01152,N,None,explicit,vkCmdSetEvent,"(VK_VERSION_1_1,VK_KHR_device_group)", commandBuffer's current device mask must include exactly one physical device.
VUID-vkCmdSetEvent-commandBuffer-cmdpool,Y,None,implicit,vkCmdSetEvent,core," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdSetEvent-commandBuffer-parameter,Y,None,implicit,vkCmdSetEvent,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdSetEvent-commandBuffer-recording,Y,None,implicit,vkCmdSetEvent,core, commandBuffer must be in the recording state
VUID-vkCmdSetEvent-commonparent,Y,None,implicit,vkCmdSetEvent,core," Both of commandBuffer, and event must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdSetEvent-event-parameter,Y,None,implicit,vkCmdSetEvent,core, event must be a valid VkEvent handle
VUID-vkCmdSetEvent-renderpass,Y,None,implicit,vkCmdSetEvent,core, This command must only be called outside of a render pass instance
VUID-vkCmdSetEvent-stageMask-01149,N,None,explicit,vkCmdSetEvent,core, stageMask must not include VK_PIPELINE_STAGE_HOST_BIT
VUID-vkCmdSetEvent-stageMask-01150,Y,StageMaskGsTsEnabled,explicit,vkCmdSetEvent,core," If the geometry shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"
VUID-vkCmdSetEvent-stageMask-01151,Y,StageMaskGsTsEnabled,explicit,vkCmdSetEvent,core," If the tessellation shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"
VUID-vkCmdSetEvent-stageMask-02107,Y,MeshShaderDisabledNV,explicit,vkCmdSetEvent,(VK_NV_mesh_shader)," If the mesh shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV"
VUID-vkCmdSetEvent-stageMask-02108,Y,MeshShaderDisabledNV,explicit,vkCmdSetEvent,(VK_NV_mesh_shader)," If the task shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV"
VUID-vkCmdSetEvent-stageMask-parameter,N,None,implicit,vkCmdSetEvent,core, stageMask must be a valid combination of VkPipelineStageFlagBits values
VUID-vkCmdSetEvent-stageMask-requiredbitmask,Y,None,implicit,vkCmdSetEvent,core, stageMask must not be 0
VUID-vkCmdSetExclusiveScissorNV-None-02031,Y,None,explicit,vkCmdSetExclusiveScissorNV,(VK_NV_scissor_exclusive), The exclusive scissor feature must be enabled.
VUID-vkCmdSetExclusiveScissorNV-None-02032,Y,None,explicit,vkCmdSetExclusiveScissorNV,(VK_NV_scissor_exclusive), The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV dynamic state enabled
VUID-vkCmdSetExclusiveScissorNV-commandBuffer-cmdpool,Y,None,implicit,vkCmdSetExclusiveScissorNV,(VK_NV_scissor_exclusive), The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdSetExclusiveScissorNV-commandBuffer-parameter,Y,None,implicit,vkCmdSetExclusiveScissorNV,(VK_NV_scissor_exclusive), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdSetExclusiveScissorNV-commandBuffer-recording,Y,None,implicit,vkCmdSetExclusiveScissorNV,(VK_NV_scissor_exclusive), commandBuffer must be in the recording state
VUID-vkCmdSetExclusiveScissorNV-exclusiveScissorCount-02036,Y,ExclusiveScissorNV,explicit,vkCmdSetExclusiveScissorNV,(VK_NV_scissor_exclusive)," If the multiple viewports feature is not enabled, exclusiveScissorCount must be 1"
VUID-vkCmdSetExclusiveScissorNV-exclusiveScissorCount-arraylength,Y,None,implicit,vkCmdSetExclusiveScissorNV,(VK_NV_scissor_exclusive), exclusiveScissorCount must be greater than 0
VUID-vkCmdSetExclusiveScissorNV-firstExclusiveScissor-02033,Y,None,explicit,vkCmdSetExclusiveScissorNV,(VK_NV_scissor_exclusive), firstExclusiveScissor must be less than VkPhysicalDeviceLimits::maxViewports
VUID-vkCmdSetExclusiveScissorNV-firstExclusiveScissor-02034,Y,None,explicit,vkCmdSetExclusiveScissorNV,(VK_NV_scissor_exclusive)," The sum of firstExclusiveScissor and exclusiveScissorCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive"
VUID-vkCmdSetExclusiveScissorNV-firstExclusiveScissor-02035,Y,ExclusiveScissorNV,explicit,vkCmdSetExclusiveScissorNV,(VK_NV_scissor_exclusive)," If the multiple viewports feature is not enabled, firstExclusiveScissor must be 0"
VUID-vkCmdSetExclusiveScissorNV-offset-02038,Y,ExclusiveScissorNV,explicit,vkCmdSetExclusiveScissorNV,(VK_NV_scissor_exclusive), Evaluation of (offset.x + extent.width) for each member of pExclusiveScissors must not cause a signed integer addition overflow
VUID-vkCmdSetExclusiveScissorNV-offset-02039,Y,ExclusiveScissorNV,explicit,vkCmdSetExclusiveScissorNV,(VK_NV_scissor_exclusive), Evaluation of (offset.y + extent.height) for each member of pExclusiveScissors must not cause a signed integer addition overflow
VUID-vkCmdSetExclusiveScissorNV-pExclusiveScissors-parameter,Y,None,implicit,vkCmdSetExclusiveScissorNV,(VK_NV_scissor_exclusive), pExclusiveScissors must be a valid pointer to an array of exclusiveScissorCount VkRect2D structures
VUID-vkCmdSetExclusiveScissorNV-x-02037,Y,ExclusiveScissorNV,explicit,vkCmdSetExclusiveScissorNV,(VK_NV_scissor_exclusive), The x and y members of offset in each member of pExclusiveScissors must be greater than or equal to 0
VUID-vkCmdSetLineWidth-None-00787,Y,None,explicit,vkCmdSetLineWidth,core, The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_LINE_WIDTH dynamic state enabled
VUID-vkCmdSetLineWidth-commandBuffer-cmdpool,Y,None,implicit,vkCmdSetLineWidth,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdSetLineWidth-commandBuffer-parameter,Y,None,implicit,vkCmdSetLineWidth,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdSetLineWidth-commandBuffer-recording,Y,None,implicit,vkCmdSetLineWidth,core, commandBuffer must be in the recording state
VUID-vkCmdSetLineWidth-lineWidth-00788,Y,PSOLineWidthInvalid,explicit,vkCmdSetLineWidth,core," If the wide lines feature is not enabled, lineWidth must be 1.0"
VUID-vkCmdSetSampleLocationsEXT-None-01528,N,None,explicit,vkCmdSetSampleLocationsEXT,(VK_EXT_sample_locations), The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled
VUID-vkCmdSetSampleLocationsEXT-commandBuffer-cmdpool,N,None,implicit,vkCmdSetSampleLocationsEXT,(VK_EXT_sample_locations), The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdSetSampleLocationsEXT-commandBuffer-parameter,Y,None,implicit,vkCmdSetSampleLocationsEXT,(VK_EXT_sample_locations), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdSetSampleLocationsEXT-commandBuffer-recording,Y,None,implicit,vkCmdSetSampleLocationsEXT,(VK_EXT_sample_locations), commandBuffer must be in the recording state
VUID-vkCmdSetSampleLocationsEXT-pSampleLocationsInfo-parameter,Y,None,implicit,vkCmdSetSampleLocationsEXT,(VK_EXT_sample_locations), pSampleLocationsInfo must be a valid pointer to a valid VkSampleLocationsInfoEXT structure
VUID-vkCmdSetSampleLocationsEXT-sampleLocationsPerPixel-01529,N,None,explicit,vkCmdSetSampleLocationsEXT,(VK_EXT_sample_locations), The sampleLocationsPerPixel member of pSampleLocationsInfo must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with
VUID-vkCmdSetSampleLocationsEXT-variableSampleLocations-01530,N,None,explicit,vkCmdSetSampleLocationsEXT,(VK_EXT_sample_locations), If VkPhysicalDeviceSampleLocationsPropertiesEXT::variableSampleLocations is VK_FALSE then the current render pass must have been begun by specifying a VkRenderPassSampleLocationsBeginInfoEXT structure whose pPostSubpassSampleLocations member contains an element with a subpassIndex matching the current subpass index and the sampleLocationsInfo member of that element must match the sample locations state pointed to by pSampleLocationsInfo
VUID-vkCmdSetScissor-None-00590,Y,None,explicit,vkCmdSetScissor,core, The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_SCISSOR dynamic state enabled
VUID-vkCmdSetScissor-commandBuffer-cmdpool,Y,None,implicit,vkCmdSetScissor,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdSetScissor-commandBuffer-parameter,Y,None,implicit,vkCmdSetScissor,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdSetScissor-commandBuffer-recording,Y,None,implicit,vkCmdSetScissor,core, commandBuffer must be in the recording state
VUID-vkCmdSetScissor-firstScissor-00591,N,None,explicit,vkCmdSetScissor,core, firstScissor must be less than VkPhysicalDeviceLimits::maxViewports
VUID-vkCmdSetScissor-firstScissor-00592,Y,SetDynScissorParamMultiviewportTests,explicit,vkCmdSetScissor,core," The sum of firstScissor and scissorCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive"
VUID-vkCmdSetScissor-firstScissor-00593,Y,SetDynScissorParamTests,explicit,vkCmdSetScissor,core," If the multiple viewports feature is not enabled, firstScissor must be 0"
VUID-vkCmdSetScissor-offset-00596,Y,SetDynScissorParamTests,explicit,vkCmdSetScissor,core, Evaluation of (offset.x + extent.width) must not cause a signed integer addition overflow
VUID-vkCmdSetScissor-offset-00597,Y,SetDynScissorParamTests,explicit,vkCmdSetScissor,core, Evaluation of (offset.y + extent.height) must not cause a signed integer addition overflow
VUID-vkCmdSetScissor-pScissors-parameter,Y,"SetDynScissorParamMultiviewportTests, SetDynScissorParamTests",implicit,vkCmdSetScissor,core, pScissors must be a valid pointer to an array of scissorCount VkRect2D structures
VUID-vkCmdSetScissor-scissorCount-00594,Y,SetDynScissorParamTests,explicit,vkCmdSetScissor,core," If the multiple viewports feature is not enabled, scissorCount must be 1"
VUID-vkCmdSetScissor-scissorCount-arraylength,Y,"SetDynScissorParamMultiviewportTests, SetDynScissorParamTests",implicit,vkCmdSetScissor,core, scissorCount must be greater than 0
VUID-vkCmdSetScissor-x-00595,Y,SetDynScissorParamTests,explicit,vkCmdSetScissor,core, The x and y members of offset must be greater than or equal to 0
VUID-vkCmdSetStencilCompareMask-None-00602,Y,None,explicit,vkCmdSetStencilCompareMask,core, The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK dynamic state enabled
VUID-vkCmdSetStencilCompareMask-commandBuffer-cmdpool,Y,None,implicit,vkCmdSetStencilCompareMask,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdSetStencilCompareMask-commandBuffer-parameter,Y,None,implicit,vkCmdSetStencilCompareMask,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdSetStencilCompareMask-commandBuffer-recording,Y,None,implicit,vkCmdSetStencilCompareMask,core, commandBuffer must be in the recording state
VUID-vkCmdSetStencilCompareMask-faceMask-parameter,N,None,implicit,vkCmdSetStencilCompareMask,core, faceMask must be a valid combination of VkStencilFaceFlagBits values
VUID-vkCmdSetStencilCompareMask-faceMask-requiredbitmask,Y,None,implicit,vkCmdSetStencilCompareMask,core, faceMask must not be 0
VUID-vkCmdSetStencilReference-None-00604,Y,None,explicit,vkCmdSetStencilReference,core, The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_STENCIL_REFERENCE dynamic state enabled
VUID-vkCmdSetStencilReference-commandBuffer-cmdpool,Y,None,implicit,vkCmdSetStencilReference,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdSetStencilReference-commandBuffer-parameter,Y,None,implicit,vkCmdSetStencilReference,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdSetStencilReference-commandBuffer-recording,Y,None,implicit,vkCmdSetStencilReference,core, commandBuffer must be in the recording state
VUID-vkCmdSetStencilReference-faceMask-parameter,N,None,implicit,vkCmdSetStencilReference,core, faceMask must be a valid combination of VkStencilFaceFlagBits values
VUID-vkCmdSetStencilReference-faceMask-requiredbitmask,Y,None,implicit,vkCmdSetStencilReference,core, faceMask must not be 0
VUID-vkCmdSetStencilWriteMask-None-00603,Y,None,explicit,vkCmdSetStencilWriteMask,core, The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_STENCIL_WRITE_MASK dynamic state enabled
VUID-vkCmdSetStencilWriteMask-commandBuffer-cmdpool,Y,None,implicit,vkCmdSetStencilWriteMask,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdSetStencilWriteMask-commandBuffer-parameter,Y,None,implicit,vkCmdSetStencilWriteMask,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdSetStencilWriteMask-commandBuffer-recording,Y,None,implicit,vkCmdSetStencilWriteMask,core, commandBuffer must be in the recording state
VUID-vkCmdSetStencilWriteMask-faceMask-parameter,N,None,implicit,vkCmdSetStencilWriteMask,core, faceMask must be a valid combination of VkStencilFaceFlagBits values
VUID-vkCmdSetStencilWriteMask-faceMask-requiredbitmask,Y,None,implicit,vkCmdSetStencilWriteMask,core, faceMask must not be 0
VUID-vkCmdSetViewport-None-01221,Y,None,explicit,vkCmdSetViewport,core, The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_VIEWPORT dynamic state enabled
VUID-vkCmdSetViewport-commandBuffer-cmdpool,Y,CommandQueueFlags,implicit,vkCmdSetViewport,core, The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdSetViewport-commandBuffer-parameter,Y,None,implicit,vkCmdSetViewport,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdSetViewport-commandBuffer-recording,Y,None,implicit,vkCmdSetViewport,core, commandBuffer must be in the recording state
VUID-vkCmdSetViewport-firstViewport-01222,N,None,explicit,vkCmdSetViewport,core, firstViewport must be less than VkPhysicalDeviceLimits::maxViewports
VUID-vkCmdSetViewport-firstViewport-01223,Y,SetDynViewportParamMultiviewportTests,explicit,vkCmdSetViewport,core," The sum of firstViewport and viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive"
VUID-vkCmdSetViewport-firstViewport-01224,Y,SetDynViewportParamTests,explicit,vkCmdSetViewport,core," If the multiple viewports feature is not enabled, firstViewport must be 0"
VUID-vkCmdSetViewport-pViewports-parameter,Y,"SetDynViewportParamMultiviewportTests, SetDynViewportParamTests, RequiredParameter",implicit,vkCmdSetViewport,core, pViewports must be a valid pointer to an array of viewportCount valid VkViewport structures
VUID-vkCmdSetViewport-viewportCount-01225,Y,SetDynViewportParamTests,explicit,vkCmdSetViewport,core," If the multiple viewports feature is not enabled, viewportCount must be 1"
VUID-vkCmdSetViewport-viewportCount-arraylength,Y,"SetDynViewportParamMultiviewportTests, SetDynViewportParamTests, RequiredParameter",implicit,vkCmdSetViewport,core, viewportCount must be greater than 0
VUID-vkCmdSetViewportShadingRatePaletteNV-None-02064,Y,None,explicit,vkCmdSetViewportShadingRatePaletteNV,(VK_NV_shading_rate_image), The shading rate image feature must be enabled.
VUID-vkCmdSetViewportShadingRatePaletteNV-None-02065,Y,None,explicit,vkCmdSetViewportShadingRatePaletteNV,(VK_NV_shading_rate_image), The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled
VUID-vkCmdSetViewportShadingRatePaletteNV-commandBuffer-cmdpool,Y,None,implicit,vkCmdSetViewportShadingRatePaletteNV,(VK_NV_shading_rate_image), The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdSetViewportShadingRatePaletteNV-commandBuffer-parameter,Y,None,implicit,vkCmdSetViewportShadingRatePaletteNV,(VK_NV_shading_rate_image), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdSetViewportShadingRatePaletteNV-commandBuffer-recording,Y,None,implicit,vkCmdSetViewportShadingRatePaletteNV,(VK_NV_shading_rate_image), commandBuffer must be in the recording state
VUID-vkCmdSetViewportShadingRatePaletteNV-firstViewport-02066,Y,ShadingRateImageNV,explicit,vkCmdSetViewportShadingRatePaletteNV,(VK_NV_shading_rate_image), firstViewport must be less than VkPhysicalDeviceLimits::maxViewports
VUID-vkCmdSetViewportShadingRatePaletteNV-firstViewport-02067,Y,ShadingRateImageNV,explicit,vkCmdSetViewportShadingRatePaletteNV,(VK_NV_shading_rate_image)," The sum of firstViewport and viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive"
VUID-vkCmdSetViewportShadingRatePaletteNV-firstViewport-02068,Y,ShadingRateImageNV,explicit,vkCmdSetViewportShadingRatePaletteNV,(VK_NV_shading_rate_image)," If the multiple viewports feature is not enabled, firstViewport must be 0"
VUID-vkCmdSetViewportShadingRatePaletteNV-pShadingRatePalettes-parameter,Y,None,implicit,vkCmdSetViewportShadingRatePaletteNV,(VK_NV_shading_rate_image), pShadingRatePalettes must be a valid pointer to an array of viewportCount valid VkShadingRatePaletteNV structures
VUID-vkCmdSetViewportShadingRatePaletteNV-viewportCount-02069,Y,ShadingRateImageNV,explicit,vkCmdSetViewportShadingRatePaletteNV,(VK_NV_shading_rate_image)," If the multiple viewports feature is not enabled, viewportCount must be 1"
VUID-vkCmdSetViewportShadingRatePaletteNV-viewportCount-arraylength,Y,None,implicit,vkCmdSetViewportShadingRatePaletteNV,(VK_NV_shading_rate_image), viewportCount must be greater than 0
VUID-vkCmdSetViewportWScalingNV-None-01322,N,None,explicit,vkCmdSetViewportWScalingNV,(VK_NV_clip_space_w_scaling), The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled
VUID-vkCmdSetViewportWScalingNV-commandBuffer-cmdpool,N,None,implicit,vkCmdSetViewportWScalingNV,(VK_NV_clip_space_w_scaling), The VkCommandPool that commandBuffer was allocated from must support graphics operations
VUID-vkCmdSetViewportWScalingNV-commandBuffer-parameter,Y,None,implicit,vkCmdSetViewportWScalingNV,(VK_NV_clip_space_w_scaling), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdSetViewportWScalingNV-commandBuffer-recording,N,None,implicit,vkCmdSetViewportWScalingNV,(VK_NV_clip_space_w_scaling), commandBuffer must be in the recording state
VUID-vkCmdSetViewportWScalingNV-firstViewport-01323,N,None,explicit,vkCmdSetViewportWScalingNV,(VK_NV_clip_space_w_scaling), firstViewport must be less than VkPhysicalDeviceLimits::maxViewports
VUID-vkCmdSetViewportWScalingNV-firstViewport-01324,N,None,explicit,vkCmdSetViewportWScalingNV,(VK_NV_clip_space_w_scaling)," The sum of firstViewport and viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive"
VUID-vkCmdSetViewportWScalingNV-pViewportWScalings-parameter,Y,None,implicit,vkCmdSetViewportWScalingNV,(VK_NV_clip_space_w_scaling), pViewportWScalings must be a valid pointer to an array of viewportCount VkViewportWScalingNV structures
VUID-vkCmdSetViewportWScalingNV-viewportCount-arraylength,Y,None,implicit,vkCmdSetViewportWScalingNV,(VK_NV_clip_space_w_scaling), viewportCount must be greater than 0
VUID-vkCmdTraceRaysNVX-cmdBuf-parameter,Y,None,implicit,vkCmdTraceRaysNVX,(VK_NVX_raytracing), cmdBuf must be a valid VkCommandBuffer handle
VUID-vkCmdTraceRaysNVX-commandBuffer-cmdpool,N,None,implicit,vkCmdTraceRaysNVX,(VK_NVX_raytracing)," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdTraceRaysNVX-commandBuffer-recording,N,None,implicit,vkCmdTraceRaysNVX,(VK_NVX_raytracing), commandBuffer must be in the recording state
VUID-vkCmdTraceRaysNVX-commonparent,Y,None,implicit,vkCmdTraceRaysNVX,(VK_NVX_raytracing)," Each of cmdBuf, hitShaderBindingTableBuffer, missShaderBindingTableBuffer, and raygenShaderBindingTableBuffer must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdTraceRaysNVX-hitShaderBindingTableBuffer-parameter,Y,None,implicit,vkCmdTraceRaysNVX,(VK_NVX_raytracing), hitShaderBindingTableBuffer must be a valid VkBuffer handle
VUID-vkCmdTraceRaysNVX-missShaderBindingTableBuffer-parameter,Y,None,implicit,vkCmdTraceRaysNVX,(VK_NVX_raytracing), missShaderBindingTableBuffer must be a valid VkBuffer handle
VUID-vkCmdTraceRaysNVX-raygenShaderBindingTableBuffer-parameter,Y,None,implicit,vkCmdTraceRaysNVX,(VK_NVX_raytracing), raygenShaderBindingTableBuffer must be a valid VkBuffer handle
VUID-vkCmdUpdateBuffer-commandBuffer-01813,N,None,explicit,vkCmdUpdateBuffer,(VK_VERSION_1_1)," If commandBuffer is an unprotected command buffer, then dstBuffer must not be a protected buffer"
VUID-vkCmdUpdateBuffer-commandBuffer-01814,N,None,explicit,vkCmdUpdateBuffer,(VK_VERSION_1_1)," If commandBuffer is a protected command buffer, then dstBuffer must not be an unprotected buffer"
VUID-vkCmdUpdateBuffer-commandBuffer-cmdpool,Y,None,implicit,vkCmdUpdateBuffer,core," The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations"
VUID-vkCmdUpdateBuffer-commandBuffer-parameter,Y,None,implicit,vkCmdUpdateBuffer,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdUpdateBuffer-commandBuffer-recording,Y,None,implicit,vkCmdUpdateBuffer,core, commandBuffer must be in the recording state
VUID-vkCmdUpdateBuffer-commonparent,Y,None,implicit,vkCmdUpdateBuffer,core," Both of commandBuffer, and dstBuffer must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdUpdateBuffer-dataSize-00033,N,None,explicit,vkCmdUpdateBuffer,core, dataSize must be less than or equal to the size of dstBuffer minus dstOffset
VUID-vkCmdUpdateBuffer-dataSize-00037,Y,None,explicit,vkCmdUpdateBuffer,core, dataSize must be less than or equal to 65536
VUID-vkCmdUpdateBuffer-dataSize-00038,Y,None,explicit,vkCmdUpdateBuffer,core, dataSize must be a multiple of 4
VUID-vkCmdUpdateBuffer-dataSize-arraylength,Y,None,implicit,vkCmdUpdateBuffer,core, dataSize must be greater than 0
VUID-vkCmdUpdateBuffer-dstBuffer-00034,Y,None,explicit,vkCmdUpdateBuffer,core, dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag
VUID-vkCmdUpdateBuffer-dstBuffer-00035,Y,None,explicit,vkCmdUpdateBuffer,core, If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdUpdateBuffer-dstBuffer-parameter,Y,None,implicit,vkCmdUpdateBuffer,core, dstBuffer must be a valid VkBuffer handle
VUID-vkCmdUpdateBuffer-dstOffset-00032,N,None,explicit,vkCmdUpdateBuffer,core, dstOffset must be less than the size of dstBuffer
VUID-vkCmdUpdateBuffer-dstOffset-00036,Y,None,explicit,vkCmdUpdateBuffer,core, dstOffset must be a multiple of 4
VUID-vkCmdUpdateBuffer-pData-parameter,Y,None,implicit,vkCmdUpdateBuffer,core, pData must be a valid pointer to an array of dataSize bytes
VUID-vkCmdUpdateBuffer-renderpass,Y,None,implicit,vkCmdUpdateBuffer,core, This command must only be called outside of a render pass instance
VUID-vkCmdWaitEvents-commandBuffer-01167,N,None,explicit,vkCmdWaitEvents,"(VK_VERSION_1_1,VK_KHR_device_group)", commandBuffer's current device mask must include exactly one physical device.
VUID-vkCmdWaitEvents-commandBuffer-cmdpool,Y,None,implicit,vkCmdWaitEvents,core," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdWaitEvents-commandBuffer-parameter,Y,None,implicit,vkCmdWaitEvents,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdWaitEvents-commandBuffer-recording,Y,None,implicit,vkCmdWaitEvents,core, commandBuffer must be in the recording state
VUID-vkCmdWaitEvents-commonparent,Y,None,implicit,vkCmdWaitEvents,core," Both of commandBuffer, and the elements of pEvents must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdWaitEvents-dstStageMask-01160,Y,None,explicit,vkCmdWaitEvents,core," If the geometry shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"
VUID-vkCmdWaitEvents-dstStageMask-01162,Y,None,explicit,vkCmdWaitEvents,core," If the tessellation shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"
VUID-vkCmdWaitEvents-dstStageMask-02113,Y,MeshShaderDisabledNV,explicit,vkCmdWaitEvents,(VK_NV_mesh_shader)," If the mesh shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV"
VUID-vkCmdWaitEvents-dstStageMask-02114,Y,MeshShaderDisabledNV,explicit,vkCmdWaitEvents,(VK_NV_mesh_shader)," If the task shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV"
VUID-vkCmdWaitEvents-dstStageMask-parameter,N,None,implicit,vkCmdWaitEvents,core, dstStageMask must be a valid combination of VkPipelineStageFlagBits values
VUID-vkCmdWaitEvents-dstStageMask-requiredbitmask,Y,None,implicit,vkCmdWaitEvents,core, dstStageMask must not be 0
VUID-vkCmdWaitEvents-eventCount-arraylength,N,None,implicit,vkCmdWaitEvents,core, eventCount must be greater than 0
VUID-vkCmdWaitEvents-pBufferMemoryBarriers-parameter,Y,None,implicit,vkCmdWaitEvents,core," If bufferMemoryBarrierCount is not 0, pBufferMemoryBarriers must be a valid pointer to an array of bufferMemoryBarrierCount valid VkBufferMemoryBarrier structures"
VUID-vkCmdWaitEvents-pEvents-01163,N,None,explicit,vkCmdWaitEvents,core," If pEvents includes one or more events that will be signaled by vkSetEvent after commandBuffer has been submitted to a queue, then vkCmdWaitEvents must not be called inside a render pass instance"
VUID-vkCmdWaitEvents-pEvents-parameter,Y,None,implicit,vkCmdWaitEvents,core, pEvents must be a valid pointer to an array of eventCount valid VkEvent handles
VUID-vkCmdWaitEvents-pImageMemoryBarriers-parameter,Y,None,implicit,vkCmdWaitEvents,core," If imageMemoryBarrierCount is not 0, pImageMemoryBarriers must be a valid pointer to an array of imageMemoryBarrierCount valid VkImageMemoryBarrier structures"
VUID-vkCmdWaitEvents-pMemoryBarriers-01165,N,None,explicit,vkCmdWaitEvents,core," Each element of pMemoryBarriers, pBufferMemoryBarriers or pImageMemoryBarriers must not have any access flag included in its srcAccessMask member if that bit is not supported by any of the pipeline stages in srcStageMask, as specified in the table of supported access types."
VUID-vkCmdWaitEvents-pMemoryBarriers-01166,N,None,explicit,vkCmdWaitEvents,core," Each element of pMemoryBarriers, pBufferMemoryBarriers or pImageMemoryBarriers must not have any access flag included in its dstAccessMask member if that bit is not supported by any of the pipeline stages in dstStageMask, as specified in the table of supported access types."
VUID-vkCmdWaitEvents-pMemoryBarriers-parameter,Y,None,implicit,vkCmdWaitEvents,core," If memoryBarrierCount is not 0, pMemoryBarriers must be a valid pointer to an array of memoryBarrierCount valid VkMemoryBarrier structures"
VUID-vkCmdWaitEvents-srcStageMask-01158,N,None,explicit,vkCmdWaitEvents,core, srcStageMask must be the bitwise OR of the stageMask parameter used in previous calls to vkCmdSetEvent with any of the members of pEvents and VK_PIPELINE_STAGE_HOST_BIT if any of the members of pEvents was set using vkSetEvent
VUID-vkCmdWaitEvents-srcStageMask-01159,Y,None,explicit,vkCmdWaitEvents,core," If the geometry shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"
VUID-vkCmdWaitEvents-srcStageMask-01161,Y,None,explicit,vkCmdWaitEvents,core," If the tessellation shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"
VUID-vkCmdWaitEvents-srcStageMask-01164,Y,InvalidBarriers,explicit,vkCmdWaitEvents,core," Any pipeline stage included in srcStageMask or dstStageMask must be supported by the capabilities of the queue family specified by the queueFamilyIndex member of the VkCommandPoolCreateInfo structure that was used to create the VkCommandPool that commandBuffer was allocated from, as specified in the table of supported pipeline stages."
VUID-vkCmdWaitEvents-srcStageMask-02111,Y,MeshShaderDisabledNV,explicit,vkCmdWaitEvents,(VK_NV_mesh_shader)," If the mesh shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV"
VUID-vkCmdWaitEvents-srcStageMask-02112,Y,MeshShaderDisabledNV,explicit,vkCmdWaitEvents,(VK_NV_mesh_shader)," If the task shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV"
VUID-vkCmdWaitEvents-srcStageMask-parameter,Y,None,implicit,vkCmdWaitEvents,core, srcStageMask must be a valid combination of VkPipelineStageFlagBits values
VUID-vkCmdWaitEvents-srcStageMask-requiredbitmask,Y,None,implicit,vkCmdWaitEvents,core, srcStageMask must not be 0
VUID-vkCmdWriteAccelerationStructurePropertiesNVX-accelerationStructure-parameter,Y,None,implicit,vkCmdWriteAccelerationStructurePropertiesNVX,(VK_NVX_raytracing), accelerationStructure must be a valid VkAccelerationStructureNVX handle
VUID-vkCmdWriteAccelerationStructurePropertiesNVX-cmdBuf-parameter,Y,None,implicit,vkCmdWriteAccelerationStructurePropertiesNVX,(VK_NVX_raytracing), cmdBuf must be a valid VkCommandBuffer handle
VUID-vkCmdWriteAccelerationStructurePropertiesNVX-commandBuffer-cmdpool,N,None,implicit,vkCmdWriteAccelerationStructurePropertiesNVX,(VK_NVX_raytracing)," The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations"
VUID-vkCmdWriteAccelerationStructurePropertiesNVX-commandBuffer-recording,N,None,implicit,vkCmdWriteAccelerationStructurePropertiesNVX,(VK_NVX_raytracing), commandBuffer must be in the recording state
VUID-vkCmdWriteAccelerationStructurePropertiesNVX-commonparent,Y,None,implicit,vkCmdWriteAccelerationStructurePropertiesNVX,(VK_NVX_raytracing)," Each of accelerationStructure, cmdBuf, and queryPool must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdWriteAccelerationStructurePropertiesNVX-queryPool-parameter,Y,None,implicit,vkCmdWriteAccelerationStructurePropertiesNVX,(VK_NVX_raytracing), queryPool must be a valid VkQueryPool handle
VUID-vkCmdWriteAccelerationStructurePropertiesNVX-queryType-02242,N,None,explicit,vkCmdWriteAccelerationStructurePropertiesNVX,(VK_NVX_raytracing), queryType must be VK_QUERY_TYPE_COMPACTED_SIZE_NVX
VUID-vkCmdWriteAccelerationStructurePropertiesNVX-queryType-parameter,Y,None,implicit,vkCmdWriteAccelerationStructurePropertiesNVX,(VK_NVX_raytracing), queryType must be a valid VkQueryType value
VUID-vkCmdWriteBufferMarkerAMD-commandBuffer-cmdpool,N,None,implicit,vkCmdWriteBufferMarkerAMD,(VK_AMD_buffer_marker)," The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations"
VUID-vkCmdWriteBufferMarkerAMD-commandBuffer-parameter,Y,None,implicit,vkCmdWriteBufferMarkerAMD,(VK_AMD_buffer_marker), commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdWriteBufferMarkerAMD-commandBuffer-recording,N,None,implicit,vkCmdWriteBufferMarkerAMD,(VK_AMD_buffer_marker), commandBuffer must be in the recording state
VUID-vkCmdWriteBufferMarkerAMD-commonparent,Y,None,implicit,vkCmdWriteBufferMarkerAMD,(VK_AMD_buffer_marker)," Both of commandBuffer, and dstBuffer must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdWriteBufferMarkerAMD-dstBuffer-01799,N,None,explicit,vkCmdWriteBufferMarkerAMD,(VK_AMD_buffer_marker), dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag
VUID-vkCmdWriteBufferMarkerAMD-dstBuffer-01800,N,None,explicit,vkCmdWriteBufferMarkerAMD,(VK_AMD_buffer_marker), If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
VUID-vkCmdWriteBufferMarkerAMD-dstBuffer-parameter,Y,None,implicit,vkCmdWriteBufferMarkerAMD,(VK_AMD_buffer_marker), dstBuffer must be a valid VkBuffer handle
VUID-vkCmdWriteBufferMarkerAMD-dstOffset-01798,N,None,explicit,vkCmdWriteBufferMarkerAMD,(VK_AMD_buffer_marker), dstOffset must be less than or equal to the size of dstBuffer minus 4.
VUID-vkCmdWriteBufferMarkerAMD-dstOffset-01801,N,None,explicit,vkCmdWriteBufferMarkerAMD,(VK_AMD_buffer_marker), dstOffset must be a multiple of 4
VUID-vkCmdWriteBufferMarkerAMD-pipelineStage-parameter,Y,None,implicit,vkCmdWriteBufferMarkerAMD,(VK_AMD_buffer_marker), pipelineStage must be a valid VkPipelineStageFlagBits value
VUID-vkCmdWriteTimestamp-None-00830,N,None,explicit,vkCmdWriteTimestamp,"(VK_VERSION_1_1,VK_KHR_multiview)", All queries used by the command must be unavailable
VUID-vkCmdWriteTimestamp-commandBuffer-cmdpool,Y,None,implicit,vkCmdWriteTimestamp,core," The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations"
VUID-vkCmdWriteTimestamp-commandBuffer-parameter,Y,None,implicit,vkCmdWriteTimestamp,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkCmdWriteTimestamp-commandBuffer-recording,Y,None,implicit,vkCmdWriteTimestamp,core, commandBuffer must be in the recording state
VUID-vkCmdWriteTimestamp-commonparent,Y,None,implicit,vkCmdWriteTimestamp,core," Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkCmdWriteTimestamp-pipelineStage-parameter,Y,None,implicit,vkCmdWriteTimestamp,core, pipelineStage must be a valid VkPipelineStageFlagBits value
VUID-vkCmdWriteTimestamp-query-00831,N,None,explicit,vkCmdWriteTimestamp,"(VK_VERSION_1_1,VK_KHR_multiview)"," If vkCmdWriteTimestamp is called within a render pass instance, the sum of query and the number of bits set in the current subpass's view mask must be less than or equal to the number of queries in queryPool"
VUID-vkCmdWriteTimestamp-queryPool-00828,N,None,explicit,vkCmdWriteTimestamp,core, The query identified by queryPool and query must be unavailable
VUID-vkCmdWriteTimestamp-queryPool-01416,N,None,explicit,vkCmdWriteTimestamp,core, queryPool must have been created with a queryType of VK_QUERY_TYPE_TIMESTAMP
VUID-vkCmdWriteTimestamp-queryPool-parameter,Y,None,implicit,vkCmdWriteTimestamp,core, queryPool must be a valid VkQueryPool handle
VUID-vkCmdWriteTimestamp-timestampValidBits-00829,N,None,explicit,vkCmdWriteTimestamp,core, The command pool's queue family must support a non-zero timestampValidBits
VUID-vkCompileDeferredNVX-device-parameter,Y,None,implicit,vkCompileDeferredNVX,(VK_NVX_raytracing), device must be a valid VkDevice handle
VUID-vkCompileDeferredNVX-pipeline-02237,N,None,explicit,vkCompileDeferredNVX,(VK_NVX_raytracing), pipeline must have been created with VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NVX.
VUID-vkCompileDeferredNVX-pipeline-parameter,Y,None,implicit,vkCompileDeferredNVX,(VK_NVX_raytracing), pipeline must be a valid VkPipeline handle
VUID-vkCompileDeferredNVX-pipeline-parent,Y,None,implicit,vkCompileDeferredNVX,(VK_NVX_raytracing)," pipeline must have been created, allocated, or retrieved from device"
VUID-vkCompileDeferredNVX-shader-02238,N,None,explicit,vkCompileDeferredNVX,(VK_NVX_raytracing), shader must not have been called as a deferred compile before.
VUID-vkCreateAccelerationStructureNVX-device-parameter,Y,None,implicit,vkCreateAccelerationStructureNVX,(VK_NVX_raytracing), device must be a valid VkDevice handle
VUID-vkCreateAccelerationStructureNVX-pAccelerationStructure-parameter,Y,None,implicit,vkCreateAccelerationStructureNVX,(VK_NVX_raytracing), pAccelerationStructure must be a valid pointer to a VkAccelerationStructureNVX handle
VUID-vkCreateAccelerationStructureNVX-pAllocator-parameter,N,None,implicit,vkCreateAccelerationStructureNVX,(VK_NVX_raytracing)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateAccelerationStructureNVX-pCreateInfo-parameter,Y,None,implicit,vkCreateAccelerationStructureNVX,(VK_NVX_raytracing), pCreateInfo must be a valid pointer to a valid VkAccelerationStructureCreateInfoNVX structure
VUID-vkCreateAndroidSurfaceKHR-instance-parameter,Y,None,implicit,vkCreateAndroidSurfaceKHR,(VK_KHR_surface)+(VK_KHR_android_surface), instance must be a valid VkInstance handle
VUID-vkCreateAndroidSurfaceKHR-pAllocator-parameter,N,None,implicit,vkCreateAndroidSurfaceKHR,(VK_KHR_surface)+(VK_KHR_android_surface)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateAndroidSurfaceKHR-pCreateInfo-parameter,Y,None,implicit,vkCreateAndroidSurfaceKHR,(VK_KHR_surface)+(VK_KHR_android_surface), pCreateInfo must be a valid pointer to a valid VkAndroidSurfaceCreateInfoKHR structure
VUID-vkCreateAndroidSurfaceKHR-pSurface-parameter,Y,None,implicit,vkCreateAndroidSurfaceKHR,(VK_KHR_surface)+(VK_KHR_android_surface), pSurface must be a valid pointer to a VkSurfaceKHR handle
VUID-vkCreateBuffer-device-parameter,Y,None,implicit,vkCreateBuffer,core, device must be a valid VkDevice handle
VUID-vkCreateBuffer-flags-00911,N,None,explicit,vkCreateBuffer,core," If the flags member of pCreateInfo includes VK_BUFFER_CREATE_SPARSE_BINDING_BIT, creating this VkBuffer must not cause the total required sparse memory for all currently valid sparse resources on the device to exceed VkPhysicalDeviceLimits::sparseAddressSpaceSize"
VUID-vkCreateBuffer-pAllocator-parameter,N,None,implicit,vkCreateBuffer,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateBuffer-pBuffer-parameter,Y,None,implicit,vkCreateBuffer,core, pBuffer must be a valid pointer to a VkBuffer handle
VUID-vkCreateBuffer-pCreateInfo-parameter,Y,None,implicit,vkCreateBuffer,core, pCreateInfo must be a valid pointer to a valid VkBufferCreateInfo structure
VUID-vkCreateBufferView-device-parameter,Y,None,implicit,vkCreateBufferView,core, device must be a valid VkDevice handle
VUID-vkCreateBufferView-pAllocator-parameter,N,None,implicit,vkCreateBufferView,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateBufferView-pCreateInfo-parameter,Y,None,implicit,vkCreateBufferView,core, pCreateInfo must be a valid pointer to a valid VkBufferViewCreateInfo structure
VUID-vkCreateBufferView-pView-parameter,Y,None,implicit,vkCreateBufferView,core, pView must be a valid pointer to a VkBufferView handle
VUID-vkCreateCommandPool-device-parameter,Y,None,implicit,vkCreateCommandPool,core, device must be a valid VkDevice handle
VUID-vkCreateCommandPool-pAllocator-parameter,N,None,implicit,vkCreateCommandPool,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateCommandPool-pCommandPool-parameter,Y,None,implicit,vkCreateCommandPool,core, pCommandPool must be a valid pointer to a VkCommandPool handle
VUID-vkCreateCommandPool-pCreateInfo-parameter,Y,None,implicit,vkCreateCommandPool,core, pCreateInfo must be a valid pointer to a valid VkCommandPoolCreateInfo structure
VUID-vkCreateCommandPool-queueFamilyIndex-01937,Y,None,explicit,vkCreateCommandPool,core, pCreateInfo::queueFamilyIndex must be the index of a queue family available in the logical device device.
VUID-vkCreateComputePipelines-createInfoCount-arraylength,Y,None,implicit,vkCreateComputePipelines,core, createInfoCount must be greater than 0
VUID-vkCreateComputePipelines-device-parameter,Y,None,implicit,vkCreateComputePipelines,core, device must be a valid VkDevice handle
VUID-vkCreateComputePipelines-flags-00695,N,None,explicit,vkCreateComputePipelines,core," If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the basePipelineIndex member of that same element is not -1, basePipelineIndex must be less than the index into pCreateInfos that corresponds to that element"
VUID-vkCreateComputePipelines-flags-00696,N,None,explicit,vkCreateComputePipelines,core," If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base pipeline must have been created with the VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set"
VUID-vkCreateComputePipelines-pAllocator-parameter,N,None,implicit,vkCreateComputePipelines,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateComputePipelines-pCreateInfos-parameter,Y,None,implicit,vkCreateComputePipelines,core, pCreateInfos must be a valid pointer to an array of createInfoCount valid VkComputePipelineCreateInfo structures
VUID-vkCreateComputePipelines-pPipelines-parameter,Y,None,implicit,vkCreateComputePipelines,core, pPipelines must be a valid pointer to an array of createInfoCount VkPipeline handles
VUID-vkCreateComputePipelines-pipelineCache-parameter,Y,None,implicit,vkCreateComputePipelines,core," If pipelineCache is not VK_NULL_HANDLE, pipelineCache must be a valid VkPipelineCache handle"
VUID-vkCreateComputePipelines-pipelineCache-parent,Y,None,implicit,vkCreateComputePipelines,core," If pipelineCache is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkCreateDebugReportCallbackEXT-instance-parameter,N,None,implicit,vkCreateDebugReportCallbackEXT,(VK_EXT_debug_report), instance must be a valid VkInstance handle
VUID-vkCreateDebugReportCallbackEXT-pAllocator-parameter,N,None,implicit,vkCreateDebugReportCallbackEXT,(VK_EXT_debug_report)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateDebugReportCallbackEXT-pCallback-parameter,Y,None,implicit,vkCreateDebugReportCallbackEXT,(VK_EXT_debug_report), pCallback must be a valid pointer to a VkDebugReportCallbackEXT handle
VUID-vkCreateDebugReportCallbackEXT-pCreateInfo-parameter,Y,None,implicit,vkCreateDebugReportCallbackEXT,(VK_EXT_debug_report), pCreateInfo must be a valid pointer to a valid VkDebugReportCallbackCreateInfoEXT structure
VUID-vkCreateDebugUtilsMessengerEXT-instance-parameter,N,None,implicit,vkCreateDebugUtilsMessengerEXT,(VK_EXT_debug_utils), instance must be a valid VkInstance handle
VUID-vkCreateDebugUtilsMessengerEXT-pAllocator-parameter,N,None,implicit,vkCreateDebugUtilsMessengerEXT,(VK_EXT_debug_utils)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateDebugUtilsMessengerEXT-pCreateInfo-parameter,Y,None,implicit,vkCreateDebugUtilsMessengerEXT,(VK_EXT_debug_utils), pCreateInfo must be a valid pointer to a valid VkDebugUtilsMessengerCreateInfoEXT structure
VUID-vkCreateDebugUtilsMessengerEXT-pMessenger-parameter,Y,None,implicit,vkCreateDebugUtilsMessengerEXT,(VK_EXT_debug_utils), pMessenger must be a valid pointer to a VkDebugUtilsMessengerEXT handle
VUID-vkCreateDescriptorPool-device-parameter,Y,None,implicit,vkCreateDescriptorPool,core, device must be a valid VkDevice handle
VUID-vkCreateDescriptorPool-pAllocator-parameter,N,None,implicit,vkCreateDescriptorPool,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateDescriptorPool-pCreateInfo-parameter,Y,None,implicit,vkCreateDescriptorPool,core, pCreateInfo must be a valid pointer to a valid VkDescriptorPoolCreateInfo structure
VUID-vkCreateDescriptorPool-pDescriptorPool-parameter,Y,None,implicit,vkCreateDescriptorPool,core, pDescriptorPool must be a valid pointer to a VkDescriptorPool handle
VUID-vkCreateDescriptorSetLayout-device-parameter,Y,None,implicit,vkCreateDescriptorSetLayout,core, device must be a valid VkDevice handle
VUID-vkCreateDescriptorSetLayout-pAllocator-parameter,N,None,implicit,vkCreateDescriptorSetLayout,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateDescriptorSetLayout-pCreateInfo-parameter,Y,None,implicit,vkCreateDescriptorSetLayout,core, pCreateInfo must be a valid pointer to a valid VkDescriptorSetLayoutCreateInfo structure
VUID-vkCreateDescriptorSetLayout-pSetLayout-parameter,Y,None,implicit,vkCreateDescriptorSetLayout,core, pSetLayout must be a valid pointer to a VkDescriptorSetLayout handle
VUID-vkCreateDescriptorUpdateTemplate-device-parameter,Y,None,implicit,vkCreateDescriptorUpdateTemplate,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", device must be a valid VkDevice handle
VUID-vkCreateDescriptorUpdateTemplate-pAllocator-parameter,N,None,implicit,vkCreateDescriptorUpdateTemplate,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)"," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateDescriptorUpdateTemplate-pCreateInfo-parameter,Y,None,implicit,vkCreateDescriptorUpdateTemplate,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", pCreateInfo must be a valid pointer to a valid VkDescriptorUpdateTemplateCreateInfo structure
VUID-vkCreateDescriptorUpdateTemplate-pDescriptorUpdateTemplate-parameter,Y,None,implicit,vkCreateDescriptorUpdateTemplate,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", pDescriptorUpdateTemplate must be a valid pointer to a VkDescriptorUpdateTemplate handle
VUID-vkCreateDevice-pAllocator-parameter,N,None,implicit,vkCreateDevice,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateDevice-pCreateInfo-parameter,Y,None,implicit,vkCreateDevice,core, pCreateInfo must be a valid pointer to a valid VkDeviceCreateInfo structure
VUID-vkCreateDevice-pDevice-parameter,Y,None,implicit,vkCreateDevice,core, pDevice must be a valid pointer to a VkDevice handle
VUID-vkCreateDevice-physicalDevice-parameter,Y,None,implicit,vkCreateDevice,core, physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkCreateDevice-ppEnabledExtensionNames-01387,Y,ExtensionNotEnabled,explicit,vkCreateDevice,core, All required extensions for each extension in the VkDeviceCreateInfo::ppEnabledExtensionNames list must also be present in that list.
VUID-vkCreateDisplayModeKHR-display-parameter,Y,None,implicit,vkCreateDisplayModeKHR,(VK_KHR_surface)+(VK_KHR_display), display must be a valid VkDisplayKHR handle
VUID-vkCreateDisplayModeKHR-pAllocator-parameter,N,None,implicit,vkCreateDisplayModeKHR,(VK_KHR_surface)+(VK_KHR_display)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateDisplayModeKHR-pCreateInfo-parameter,Y,None,implicit,vkCreateDisplayModeKHR,(VK_KHR_surface)+(VK_KHR_display), pCreateInfo must be a valid pointer to a valid VkDisplayModeCreateInfoKHR structure
VUID-vkCreateDisplayModeKHR-pMode-parameter,Y,None,implicit,vkCreateDisplayModeKHR,(VK_KHR_surface)+(VK_KHR_display), pMode must be a valid pointer to a VkDisplayModeKHR handle
VUID-vkCreateDisplayModeKHR-physicalDevice-parameter,Y,None,implicit,vkCreateDisplayModeKHR,(VK_KHR_surface)+(VK_KHR_display), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkCreateDisplayPlaneSurfaceKHR-instance-parameter,Y,None,implicit,vkCreateDisplayPlaneSurfaceKHR,(VK_KHR_surface)+(VK_KHR_display), instance must be a valid VkInstance handle
VUID-vkCreateDisplayPlaneSurfaceKHR-pAllocator-parameter,N,None,implicit,vkCreateDisplayPlaneSurfaceKHR,(VK_KHR_surface)+(VK_KHR_display)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateDisplayPlaneSurfaceKHR-pCreateInfo-parameter,Y,None,implicit,vkCreateDisplayPlaneSurfaceKHR,(VK_KHR_surface)+(VK_KHR_display), pCreateInfo must be a valid pointer to a valid VkDisplaySurfaceCreateInfoKHR structure
VUID-vkCreateDisplayPlaneSurfaceKHR-pSurface-parameter,Y,None,implicit,vkCreateDisplayPlaneSurfaceKHR,(VK_KHR_surface)+(VK_KHR_display), pSurface must be a valid pointer to a VkSurfaceKHR handle
VUID-vkCreateEvent-device-parameter,Y,None,implicit,vkCreateEvent,core, device must be a valid VkDevice handle
VUID-vkCreateEvent-pAllocator-parameter,N,None,implicit,vkCreateEvent,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateEvent-pCreateInfo-parameter,Y,None,implicit,vkCreateEvent,core, pCreateInfo must be a valid pointer to a valid VkEventCreateInfo structure
VUID-vkCreateEvent-pEvent-parameter,Y,None,implicit,vkCreateEvent,core, pEvent must be a valid pointer to a VkEvent handle
VUID-vkCreateFence-device-parameter,Y,None,implicit,vkCreateFence,core, device must be a valid VkDevice handle
VUID-vkCreateFence-pAllocator-parameter,N,None,implicit,vkCreateFence,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateFence-pCreateInfo-parameter,Y,None,implicit,vkCreateFence,core, pCreateInfo must be a valid pointer to a valid VkFenceCreateInfo structure
VUID-vkCreateFence-pFence-parameter,Y,None,implicit,vkCreateFence,core, pFence must be a valid pointer to a VkFence handle
VUID-vkCreateFramebuffer-device-parameter,Y,None,implicit,vkCreateFramebuffer,core, device must be a valid VkDevice handle
VUID-vkCreateFramebuffer-pAllocator-parameter,N,None,implicit,vkCreateFramebuffer,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateFramebuffer-pCreateInfo-parameter,Y,None,implicit,vkCreateFramebuffer,core, pCreateInfo must be a valid pointer to a valid VkFramebufferCreateInfo structure
VUID-vkCreateFramebuffer-pFramebuffer-parameter,Y,None,implicit,vkCreateFramebuffer,core, pFramebuffer must be a valid pointer to a VkFramebuffer handle
VUID-vkCreateGraphicsPipelines-createInfoCount-arraylength,Y,None,implicit,vkCreateGraphicsPipelines,core, createInfoCount must be greater than 0
VUID-vkCreateGraphicsPipelines-device-parameter,Y,None,implicit,vkCreateGraphicsPipelines,core, device must be a valid VkDevice handle
VUID-vkCreateGraphicsPipelines-flags-00720,Y,None,explicit,vkCreateGraphicsPipelines,core," If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the basePipelineIndex member of that same element is not -1, basePipelineIndex must be less than the index into pCreateInfos that corresponds to that element"
VUID-vkCreateGraphicsPipelines-flags-00721,N,None,explicit,vkCreateGraphicsPipelines,core," If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base pipeline must have been created with the VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set"
VUID-vkCreateGraphicsPipelines-pAllocator-parameter,N,None,implicit,vkCreateGraphicsPipelines,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateGraphicsPipelines-pCreateInfos-parameter,Y,None,implicit,vkCreateGraphicsPipelines,core, pCreateInfos must be a valid pointer to an array of createInfoCount valid VkGraphicsPipelineCreateInfo structures
VUID-vkCreateGraphicsPipelines-pPipelines-parameter,Y,None,implicit,vkCreateGraphicsPipelines,core, pPipelines must be a valid pointer to an array of createInfoCount VkPipeline handles
VUID-vkCreateGraphicsPipelines-pipelineCache-parameter,Y,None,implicit,vkCreateGraphicsPipelines,core," If pipelineCache is not VK_NULL_HANDLE, pipelineCache must be a valid VkPipelineCache handle"
VUID-vkCreateGraphicsPipelines-pipelineCache-parent,Y,None,implicit,vkCreateGraphicsPipelines,core," If pipelineCache is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkCreateIOSSurfaceMVK-instance-parameter,Y,None,implicit,vkCreateIOSSurfaceMVK,(VK_KHR_surface)+(VK_MVK_ios_surface), instance must be a valid VkInstance handle
VUID-vkCreateIOSSurfaceMVK-pAllocator-parameter,N,None,implicit,vkCreateIOSSurfaceMVK,(VK_KHR_surface)+(VK_MVK_ios_surface)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateIOSSurfaceMVK-pCreateInfo-parameter,Y,None,implicit,vkCreateIOSSurfaceMVK,(VK_KHR_surface)+(VK_MVK_ios_surface), pCreateInfo must be a valid pointer to a valid VkIOSSurfaceCreateInfoMVK structure
VUID-vkCreateIOSSurfaceMVK-pSurface-parameter,Y,None,implicit,vkCreateIOSSurfaceMVK,(VK_KHR_surface)+(VK_MVK_ios_surface), pSurface must be a valid pointer to a VkSurfaceKHR handle
VUID-vkCreateImage-device-parameter,Y,None,implicit,vkCreateImage,core, device must be a valid VkDevice handle
VUID-vkCreateImage-flags-00939,N,None,explicit,vkCreateImage,core," If the flags member of pCreateInfo includes VK_IMAGE_CREATE_SPARSE_BINDING_BIT, creating this VkImage must not cause the total required sparse memory for all currently valid sparse resources on the device to exceed VkPhysicalDeviceLimits::sparseAddressSpaceSize"
VUID-vkCreateImage-pAllocator-parameter,N,None,implicit,vkCreateImage,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateImage-pCreateInfo-parameter,Y,RequiredParameter,implicit,vkCreateImage,core, pCreateInfo must be a valid pointer to a valid VkImageCreateInfo structure
VUID-vkCreateImage-pImage-parameter,Y,None,implicit,vkCreateImage,core, pImage must be a valid pointer to a VkImage handle
VUID-vkCreateImageView-device-parameter,Y,None,implicit,vkCreateImageView,core, device must be a valid VkDevice handle
VUID-vkCreateImageView-pAllocator-parameter,N,None,implicit,vkCreateImageView,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateImageView-pCreateInfo-parameter,Y,None,implicit,vkCreateImageView,core, pCreateInfo must be a valid pointer to a valid VkImageViewCreateInfo structure
VUID-vkCreateImageView-pView-parameter,Y,None,implicit,vkCreateImageView,core, pView must be a valid pointer to a VkImageView handle
VUID-vkCreateIndirectCommandsLayoutNVX-device-parameter,Y,None,implicit,vkCreateIndirectCommandsLayoutNVX,(VK_NVX_device_generated_commands), device must be a valid VkDevice handle
VUID-vkCreateIndirectCommandsLayoutNVX-pAllocator-parameter,N,None,implicit,vkCreateIndirectCommandsLayoutNVX,(VK_NVX_device_generated_commands)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateIndirectCommandsLayoutNVX-pCreateInfo-parameter,Y,None,implicit,vkCreateIndirectCommandsLayoutNVX,(VK_NVX_device_generated_commands), pCreateInfo must be a valid pointer to a valid VkIndirectCommandsLayoutCreateInfoNVX structure
VUID-vkCreateIndirectCommandsLayoutNVX-pIndirectCommandsLayout-parameter,Y,None,implicit,vkCreateIndirectCommandsLayoutNVX,(VK_NVX_device_generated_commands), pIndirectCommandsLayout must be a valid pointer to a VkIndirectCommandsLayoutNVX handle
VUID-vkCreateInstance-pAllocator-parameter,N,None,implicit,vkCreateInstance,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateInstance-pCreateInfo-parameter,Y,None,implicit,vkCreateInstance,core, pCreateInfo must be a valid pointer to a valid VkInstanceCreateInfo structure
VUID-vkCreateInstance-pInstance-parameter,Y,None,implicit,vkCreateInstance,core, pInstance must be a valid pointer to a VkInstance handle
VUID-vkCreateInstance-ppEnabledExtensionNames-01388,Y,None,explicit,vkCreateInstance,core, All required extensions for each extension in the VkInstanceCreateInfo::ppEnabledExtensionNames list must also be present in that list.
VUID-vkCreateMacOSSurfaceMVK-instance-parameter,Y,None,implicit,vkCreateMacOSSurfaceMVK,(VK_KHR_surface)+(VK_MVK_macos_surface), instance must be a valid VkInstance handle
VUID-vkCreateMacOSSurfaceMVK-pAllocator-parameter,N,None,implicit,vkCreateMacOSSurfaceMVK,(VK_KHR_surface)+(VK_MVK_macos_surface)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateMacOSSurfaceMVK-pCreateInfo-parameter,Y,None,implicit,vkCreateMacOSSurfaceMVK,(VK_KHR_surface)+(VK_MVK_macos_surface), pCreateInfo must be a valid pointer to a valid VkMacOSSurfaceCreateInfoMVK structure
VUID-vkCreateMacOSSurfaceMVK-pSurface-parameter,Y,None,implicit,vkCreateMacOSSurfaceMVK,(VK_KHR_surface)+(VK_MVK_macos_surface), pSurface must be a valid pointer to a VkSurfaceKHR handle
VUID-vkCreateMirSurfaceKHR-instance-parameter,Y,None,implicit,vkCreateMirSurfaceKHR,(VK_KHR_surface)+(VK_KHR_mir_surface), instance must be a valid VkInstance handle
VUID-vkCreateMirSurfaceKHR-pAllocator-parameter,N,None,implicit,vkCreateMirSurfaceKHR,(VK_KHR_surface)+(VK_KHR_mir_surface)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateMirSurfaceKHR-pCreateInfo-parameter,Y,None,implicit,vkCreateMirSurfaceKHR,(VK_KHR_surface)+(VK_KHR_mir_surface), pCreateInfo must be a valid pointer to a valid VkMirSurfaceCreateInfoKHR structure
VUID-vkCreateMirSurfaceKHR-pSurface-parameter,Y,None,implicit,vkCreateMirSurfaceKHR,(VK_KHR_surface)+(VK_KHR_mir_surface), pSurface must be a valid pointer to a VkSurfaceKHR handle
VUID-vkCreateObjectTableNVX-device-parameter,Y,None,implicit,vkCreateObjectTableNVX,(VK_NVX_device_generated_commands), device must be a valid VkDevice handle
VUID-vkCreateObjectTableNVX-pAllocator-parameter,N,None,implicit,vkCreateObjectTableNVX,(VK_NVX_device_generated_commands)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateObjectTableNVX-pCreateInfo-parameter,Y,None,implicit,vkCreateObjectTableNVX,(VK_NVX_device_generated_commands), pCreateInfo must be a valid pointer to a valid VkObjectTableCreateInfoNVX structure
VUID-vkCreateObjectTableNVX-pObjectTable-parameter,Y,None,implicit,vkCreateObjectTableNVX,(VK_NVX_device_generated_commands), pObjectTable must be a valid pointer to a VkObjectTableNVX handle
VUID-vkCreatePipelineCache-device-parameter,Y,None,implicit,vkCreatePipelineCache,core, device must be a valid VkDevice handle
VUID-vkCreatePipelineCache-pAllocator-parameter,N,None,implicit,vkCreatePipelineCache,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreatePipelineCache-pCreateInfo-parameter,Y,None,implicit,vkCreatePipelineCache,core, pCreateInfo must be a valid pointer to a valid VkPipelineCacheCreateInfo structure
VUID-vkCreatePipelineCache-pPipelineCache-parameter,Y,None,implicit,vkCreatePipelineCache,core, pPipelineCache must be a valid pointer to a VkPipelineCache handle
VUID-vkCreatePipelineLayout-device-parameter,Y,None,implicit,vkCreatePipelineLayout,core, device must be a valid VkDevice handle
VUID-vkCreatePipelineLayout-pAllocator-parameter,N,None,implicit,vkCreatePipelineLayout,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreatePipelineLayout-pCreateInfo-parameter,Y,None,implicit,vkCreatePipelineLayout,core, pCreateInfo must be a valid pointer to a valid VkPipelineLayoutCreateInfo structure
VUID-vkCreatePipelineLayout-pPipelineLayout-parameter,Y,None,implicit,vkCreatePipelineLayout,core, pPipelineLayout must be a valid pointer to a VkPipelineLayout handle
VUID-vkCreateQueryPool-device-parameter,Y,None,implicit,vkCreateQueryPool,core, device must be a valid VkDevice handle
VUID-vkCreateQueryPool-pAllocator-parameter,N,None,implicit,vkCreateQueryPool,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateQueryPool-pCreateInfo-parameter,Y,None,implicit,vkCreateQueryPool,core, pCreateInfo must be a valid pointer to a valid VkQueryPoolCreateInfo structure
VUID-vkCreateQueryPool-pQueryPool-parameter,Y,None,implicit,vkCreateQueryPool,core, pQueryPool must be a valid pointer to a VkQueryPool handle
VUID-vkCreateRaytracingPipelinesNVX-createInfoCount-arraylength,Y,None,implicit,vkCreateRaytracingPipelinesNVX,(VK_NVX_raytracing), createInfoCount must be greater than 0
VUID-vkCreateRaytracingPipelinesNVX-device-parameter,Y,None,implicit,vkCreateRaytracingPipelinesNVX,(VK_NVX_raytracing), device must be a valid VkDevice handle
VUID-vkCreateRaytracingPipelinesNVX-pAllocator-parameter,N,None,implicit,vkCreateRaytracingPipelinesNVX,(VK_NVX_raytracing)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateRaytracingPipelinesNVX-pCreateInfos-parameter,Y,None,implicit,vkCreateRaytracingPipelinesNVX,(VK_NVX_raytracing), pCreateInfos must be a valid pointer to an array of createInfoCount valid VkRaytracingPipelineCreateInfoNVX structures
VUID-vkCreateRaytracingPipelinesNVX-pPipelines-parameter,Y,None,implicit,vkCreateRaytracingPipelinesNVX,(VK_NVX_raytracing), pPipelines must be a valid pointer to an array of createInfoCount VkPipeline handles
VUID-vkCreateRaytracingPipelinesNVX-pipelineCache-parameter,Y,None,implicit,vkCreateRaytracingPipelinesNVX,(VK_NVX_raytracing)," If pipelineCache is not VK_NULL_HANDLE, pipelineCache must be a valid VkPipelineCache handle"
VUID-vkCreateRaytracingPipelinesNVX-pipelineCache-parent,Y,None,implicit,vkCreateRaytracingPipelinesNVX,(VK_NVX_raytracing)," If pipelineCache is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkCreateRenderPass-device-parameter,Y,None,implicit,vkCreateRenderPass,core, device must be a valid VkDevice handle
VUID-vkCreateRenderPass-pAllocator-parameter,N,None,implicit,vkCreateRenderPass,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateRenderPass-pCreateInfo-parameter,Y,None,implicit,vkCreateRenderPass,core, pCreateInfo must be a valid pointer to a valid VkRenderPassCreateInfo structure
VUID-vkCreateRenderPass-pRenderPass-parameter,Y,None,implicit,vkCreateRenderPass,core, pRenderPass must be a valid pointer to a VkRenderPass handle
VUID-vkCreateRenderPass2KHR-device-parameter,Y,None,implicit,vkCreateRenderPass2KHR,(VK_KHR_create_renderpass2), device must be a valid VkDevice handle
VUID-vkCreateRenderPass2KHR-pAllocator-parameter,N,None,implicit,vkCreateRenderPass2KHR,(VK_KHR_create_renderpass2)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateRenderPass2KHR-pCreateInfo-parameter,Y,None,implicit,vkCreateRenderPass2KHR,(VK_KHR_create_renderpass2), pCreateInfo must be a valid pointer to a valid VkRenderPassCreateInfo2KHR structure
VUID-vkCreateRenderPass2KHR-pRenderPass-parameter,Y,None,implicit,vkCreateRenderPass2KHR,(VK_KHR_create_renderpass2), pRenderPass must be a valid pointer to a VkRenderPass handle
VUID-vkCreateSampler-device-parameter,Y,None,implicit,vkCreateSampler,core, device must be a valid VkDevice handle
VUID-vkCreateSampler-pAllocator-parameter,N,None,implicit,vkCreateSampler,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateSampler-pCreateInfo-parameter,Y,None,implicit,vkCreateSampler,core, pCreateInfo must be a valid pointer to a valid VkSamplerCreateInfo structure
VUID-vkCreateSampler-pSampler-parameter,Y,None,implicit,vkCreateSampler,core, pSampler must be a valid pointer to a VkSampler handle
VUID-vkCreateSamplerYcbcrConversion-None-01648,N,None,explicit,vkCreateSamplerYcbcrConversion,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", The sampler Y'CBCR conversion feature must be enabled
VUID-vkCreateSamplerYcbcrConversion-device-parameter,Y,None,implicit,vkCreateSamplerYcbcrConversion,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", device must be a valid VkDevice handle
VUID-vkCreateSamplerYcbcrConversion-pAllocator-parameter,N,None,implicit,vkCreateSamplerYcbcrConversion,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateSamplerYcbcrConversion-pCreateInfo-parameter,Y,None,implicit,vkCreateSamplerYcbcrConversion,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", pCreateInfo must be a valid pointer to a valid VkSamplerYcbcrConversionCreateInfo structure
VUID-vkCreateSamplerYcbcrConversion-pYcbcrConversion-parameter,Y,None,implicit,vkCreateSamplerYcbcrConversion,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", pYcbcrConversion must be a valid pointer to a VkSamplerYcbcrConversion handle
VUID-vkCreateSemaphore-device-parameter,Y,None,implicit,vkCreateSemaphore,core, device must be a valid VkDevice handle
VUID-vkCreateSemaphore-pAllocator-parameter,N,None,implicit,vkCreateSemaphore,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateSemaphore-pCreateInfo-parameter,Y,None,implicit,vkCreateSemaphore,core, pCreateInfo must be a valid pointer to a valid VkSemaphoreCreateInfo structure
VUID-vkCreateSemaphore-pSemaphore-parameter,Y,None,implicit,vkCreateSemaphore,core, pSemaphore must be a valid pointer to a VkSemaphore handle
VUID-vkCreateShaderModule-device-parameter,Y,None,implicit,vkCreateShaderModule,core, device must be a valid VkDevice handle
VUID-vkCreateShaderModule-pAllocator-parameter,N,None,implicit,vkCreateShaderModule,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateShaderModule-pCreateInfo-parameter,Y,None,implicit,vkCreateShaderModule,core, pCreateInfo must be a valid pointer to a valid VkShaderModuleCreateInfo structure
VUID-vkCreateShaderModule-pShaderModule-parameter,Y,None,implicit,vkCreateShaderModule,core, pShaderModule must be a valid pointer to a VkShaderModule handle
VUID-vkCreateSharedSwapchainsKHR-device-parameter,Y,None,implicit,vkCreateSharedSwapchainsKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain), device must be a valid VkDevice handle
VUID-vkCreateSharedSwapchainsKHR-pAllocator-parameter,N,None,implicit,vkCreateSharedSwapchainsKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateSharedSwapchainsKHR-pCreateInfos-parameter,Y,None,implicit,vkCreateSharedSwapchainsKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain), pCreateInfos must be a valid pointer to an array of swapchainCount valid VkSwapchainCreateInfoKHR structures
VUID-vkCreateSharedSwapchainsKHR-pSwapchains-parameter,Y,None,implicit,vkCreateSharedSwapchainsKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain), pSwapchains must be a valid pointer to an array of swapchainCount VkSwapchainKHR handles
VUID-vkCreateSharedSwapchainsKHR-swapchainCount-arraylength,Y,None,implicit,vkCreateSharedSwapchainsKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain), swapchainCount must be greater than 0
VUID-vkCreateSwapchainKHR-device-parameter,Y,None,implicit,vkCreateSwapchainKHR,(VK_KHR_surface)+(VK_KHR_swapchain), device must be a valid VkDevice handle
VUID-vkCreateSwapchainKHR-pAllocator-parameter,N,None,implicit,vkCreateSwapchainKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateSwapchainKHR-pCreateInfo-parameter,Y,None,implicit,vkCreateSwapchainKHR,(VK_KHR_surface)+(VK_KHR_swapchain), pCreateInfo must be a valid pointer to a valid VkSwapchainCreateInfoKHR structure
VUID-vkCreateSwapchainKHR-pSwapchain-parameter,Y,None,implicit,vkCreateSwapchainKHR,(VK_KHR_surface)+(VK_KHR_swapchain), pSwapchain must be a valid pointer to a VkSwapchainKHR handle
VUID-vkCreateValidationCacheEXT-device-parameter,Y,None,implicit,vkCreateValidationCacheEXT,(VK_EXT_validation_cache), device must be a valid VkDevice handle
VUID-vkCreateValidationCacheEXT-pAllocator-parameter,N,None,implicit,vkCreateValidationCacheEXT,(VK_EXT_validation_cache)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateValidationCacheEXT-pCreateInfo-parameter,Y,None,implicit,vkCreateValidationCacheEXT,(VK_EXT_validation_cache), pCreateInfo must be a valid pointer to a valid VkValidationCacheCreateInfoEXT structure
VUID-vkCreateValidationCacheEXT-pValidationCache-parameter,Y,None,implicit,vkCreateValidationCacheEXT,(VK_EXT_validation_cache), pValidationCache must be a valid pointer to a VkValidationCacheEXT handle
VUID-vkCreateViSurfaceNN-instance-parameter,Y,None,implicit,vkCreateViSurfaceNN,(VK_KHR_surface)+(VK_NN_vi_surface), instance must be a valid VkInstance handle
VUID-vkCreateViSurfaceNN-pAllocator-parameter,N,None,implicit,vkCreateViSurfaceNN,(VK_KHR_surface)+(VK_NN_vi_surface)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateViSurfaceNN-pCreateInfo-parameter,Y,None,implicit,vkCreateViSurfaceNN,(VK_KHR_surface)+(VK_NN_vi_surface), pCreateInfo must be a valid pointer to a valid VkViSurfaceCreateInfoNN structure
VUID-vkCreateViSurfaceNN-pSurface-parameter,Y,None,implicit,vkCreateViSurfaceNN,(VK_KHR_surface)+(VK_NN_vi_surface), pSurface must be a valid pointer to a VkSurfaceKHR handle
VUID-vkCreateWaylandSurfaceKHR-instance-parameter,Y,None,implicit,vkCreateWaylandSurfaceKHR,(VK_KHR_surface)+(VK_KHR_wayland_surface), instance must be a valid VkInstance handle
VUID-vkCreateWaylandSurfaceKHR-pAllocator-parameter,N,None,implicit,vkCreateWaylandSurfaceKHR,(VK_KHR_surface)+(VK_KHR_wayland_surface)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateWaylandSurfaceKHR-pCreateInfo-parameter,Y,None,implicit,vkCreateWaylandSurfaceKHR,(VK_KHR_surface)+(VK_KHR_wayland_surface), pCreateInfo must be a valid pointer to a valid VkWaylandSurfaceCreateInfoKHR structure
VUID-vkCreateWaylandSurfaceKHR-pSurface-parameter,Y,None,implicit,vkCreateWaylandSurfaceKHR,(VK_KHR_surface)+(VK_KHR_wayland_surface), pSurface must be a valid pointer to a VkSurfaceKHR handle
VUID-vkCreateWin32SurfaceKHR-instance-parameter,Y,None,implicit,vkCreateWin32SurfaceKHR,(VK_KHR_surface)+(VK_KHR_win32_surface), instance must be a valid VkInstance handle
VUID-vkCreateWin32SurfaceKHR-pAllocator-parameter,N,None,implicit,vkCreateWin32SurfaceKHR,(VK_KHR_surface)+(VK_KHR_win32_surface)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateWin32SurfaceKHR-pCreateInfo-parameter,Y,None,implicit,vkCreateWin32SurfaceKHR,(VK_KHR_surface)+(VK_KHR_win32_surface), pCreateInfo must be a valid pointer to a valid VkWin32SurfaceCreateInfoKHR structure
VUID-vkCreateWin32SurfaceKHR-pSurface-parameter,Y,None,implicit,vkCreateWin32SurfaceKHR,(VK_KHR_surface)+(VK_KHR_win32_surface), pSurface must be a valid pointer to a VkSurfaceKHR handle
VUID-vkCreateXcbSurfaceKHR-instance-parameter,Y,None,implicit,vkCreateXcbSurfaceKHR,(VK_KHR_surface)+(VK_KHR_xcb_surface), instance must be a valid VkInstance handle
VUID-vkCreateXcbSurfaceKHR-pAllocator-parameter,N,None,implicit,vkCreateXcbSurfaceKHR,(VK_KHR_surface)+(VK_KHR_xcb_surface)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateXcbSurfaceKHR-pCreateInfo-parameter,Y,None,implicit,vkCreateXcbSurfaceKHR,(VK_KHR_surface)+(VK_KHR_xcb_surface), pCreateInfo must be a valid pointer to a valid VkXcbSurfaceCreateInfoKHR structure
VUID-vkCreateXcbSurfaceKHR-pSurface-parameter,Y,None,implicit,vkCreateXcbSurfaceKHR,(VK_KHR_surface)+(VK_KHR_xcb_surface), pSurface must be a valid pointer to a VkSurfaceKHR handle
VUID-vkCreateXlibSurfaceKHR-instance-parameter,Y,None,implicit,vkCreateXlibSurfaceKHR,(VK_KHR_surface)+(VK_KHR_xlib_surface), instance must be a valid VkInstance handle
VUID-vkCreateXlibSurfaceKHR-pAllocator-parameter,N,None,implicit,vkCreateXlibSurfaceKHR,(VK_KHR_surface)+(VK_KHR_xlib_surface)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkCreateXlibSurfaceKHR-pCreateInfo-parameter,Y,None,implicit,vkCreateXlibSurfaceKHR,(VK_KHR_surface)+(VK_KHR_xlib_surface), pCreateInfo must be a valid pointer to a valid VkXlibSurfaceCreateInfoKHR structure
VUID-vkCreateXlibSurfaceKHR-pSurface-parameter,Y,None,implicit,vkCreateXlibSurfaceKHR,(VK_KHR_surface)+(VK_KHR_xlib_surface), pSurface must be a valid pointer to a VkSurfaceKHR handle
VUID-vkDebugMarkerSetObjectNameEXT-device-parameter,Y,None,implicit,vkDebugMarkerSetObjectNameEXT,(VK_EXT_debug_marker), device must be a valid VkDevice handle
VUID-vkDebugMarkerSetObjectNameEXT-pNameInfo-parameter,Y,None,implicit,vkDebugMarkerSetObjectNameEXT,(VK_EXT_debug_marker), pNameInfo must be a valid pointer to a valid VkDebugMarkerObjectNameInfoEXT structure
VUID-vkDebugMarkerSetObjectTagEXT-device-parameter,Y,None,implicit,vkDebugMarkerSetObjectTagEXT,(VK_EXT_debug_marker), device must be a valid VkDevice handle
VUID-vkDebugMarkerSetObjectTagEXT-pTagInfo-parameter,Y,None,implicit,vkDebugMarkerSetObjectTagEXT,(VK_EXT_debug_marker), pTagInfo must be a valid pointer to a valid VkDebugMarkerObjectTagInfoEXT structure
VUID-vkDebugReportMessageEXT-flags-parameter,N,None,implicit,vkDebugReportMessageEXT,(VK_EXT_debug_report), flags must be a valid combination of VkDebugReportFlagBitsEXT values
VUID-vkDebugReportMessageEXT-flags-requiredbitmask,Y,None,implicit,vkDebugReportMessageEXT,(VK_EXT_debug_report), flags must not be 0
VUID-vkDebugReportMessageEXT-instance-parameter,N,None,implicit,vkDebugReportMessageEXT,(VK_EXT_debug_report), instance must be a valid VkInstance handle
VUID-vkDebugReportMessageEXT-object-01241,N,None,explicit,vkDebugReportMessageEXT,(VK_EXT_debug_report), object must be a Vulkan object or VK_NULL_HANDLE
VUID-vkDebugReportMessageEXT-objectType-01498,N,None,explicit,vkDebugReportMessageEXT,(VK_EXT_debug_report)," If objectType is not VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT and object is not VK_NULL_HANDLE, object must be a Vulkan object of the corresponding type associated with objectType as defined in VkDebugReportObjectTypeEXT and Vulkan Handle Relationship."
VUID-vkDebugReportMessageEXT-objectType-parameter,Y,None,implicit,vkDebugReportMessageEXT,(VK_EXT_debug_report), objectType must be a valid VkDebugReportObjectTypeEXT value
VUID-vkDebugReportMessageEXT-pLayerPrefix-parameter,Y,None,implicit,vkDebugReportMessageEXT,(VK_EXT_debug_report), pLayerPrefix must be a null-terminated UTF-8 string
VUID-vkDebugReportMessageEXT-pMessage-parameter,Y,None,implicit,vkDebugReportMessageEXT,(VK_EXT_debug_report), pMessage must be a null-terminated UTF-8 string
VUID-vkDestroyAccelerationStructureNVX-accelerationStructure-parameter,Y,None,implicit,vkDestroyAccelerationStructureNVX,(VK_NVX_raytracing), accelerationStructure must be a valid VkAccelerationStructureNVX handle
VUID-vkDestroyAccelerationStructureNVX-accelerationStructure-parent,Y,None,implicit,vkDestroyAccelerationStructureNVX,(VK_NVX_raytracing)," accelerationStructure must have been created, allocated, or retrieved from device"
VUID-vkDestroyAccelerationStructureNVX-device-parameter,Y,None,implicit,vkDestroyAccelerationStructureNVX,(VK_NVX_raytracing), device must be a valid VkDevice handle
VUID-vkDestroyAccelerationStructureNVX-pAllocator-parameter,N,None,implicit,vkDestroyAccelerationStructureNVX,(VK_NVX_raytracing)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyBuffer-buffer-00922,Y,None,explicit,vkDestroyBuffer,core," All submitted commands that refer to buffer, either directly or via a VkBufferView, must have completed execution"
VUID-vkDestroyBuffer-buffer-00923,Y,None,explicit,vkDestroyBuffer,core," If VkAllocationCallbacks were provided when buffer was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyBuffer-buffer-00924,Y,None,explicit,vkDestroyBuffer,core," If no VkAllocationCallbacks were provided when buffer was created, pAllocator must be NULL"
VUID-vkDestroyBuffer-buffer-parameter,Y,VertexBufferInvalid,implicit,vkDestroyBuffer,core," If buffer is not VK_NULL_HANDLE, buffer must be a valid VkBuffer handle"
VUID-vkDestroyBuffer-buffer-parent,Y,None,implicit,vkDestroyBuffer,core," If buffer is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroyBuffer-device-parameter,Y,None,implicit,vkDestroyBuffer,core, device must be a valid VkDevice handle
VUID-vkDestroyBuffer-pAllocator-parameter,N,None,implicit,vkDestroyBuffer,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyBufferView-bufferView-00936,Y,BufferViewInUseDestroyedSignaled,explicit,vkDestroyBufferView,core, All submitted commands that refer to bufferView must have completed execution
VUID-vkDestroyBufferView-bufferView-00937,Y,None,explicit,vkDestroyBufferView,core," If VkAllocationCallbacks were provided when bufferView was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyBufferView-bufferView-00938,Y,None,explicit,vkDestroyBufferView,core," If no VkAllocationCallbacks were provided when bufferView was created, pAllocator must be NULL"
VUID-vkDestroyBufferView-bufferView-parameter,Y,None,implicit,vkDestroyBufferView,core," If bufferView is not VK_NULL_HANDLE, bufferView must be a valid VkBufferView handle"
VUID-vkDestroyBufferView-bufferView-parent,Y,None,implicit,vkDestroyBufferView,core," If bufferView is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroyBufferView-device-parameter,Y,None,implicit,vkDestroyBufferView,core, device must be a valid VkDevice handle
VUID-vkDestroyBufferView-pAllocator-parameter,N,None,implicit,vkDestroyBufferView,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyCommandPool-commandPool-00041,Y,None,explicit,vkDestroyCommandPool,core, All VkCommandBuffer objects allocated from commandPool must not be in the pending state.
VUID-vkDestroyCommandPool-commandPool-00042,Y,None,explicit,vkDestroyCommandPool,core," If VkAllocationCallbacks were provided when commandPool was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyCommandPool-commandPool-00043,Y,None,explicit,vkDestroyCommandPool,core," If no VkAllocationCallbacks were provided when commandPool was created, pAllocator must be NULL"
VUID-vkDestroyCommandPool-commandPool-parameter,Y,None,implicit,vkDestroyCommandPool,core," If commandPool is not VK_NULL_HANDLE, commandPool must be a valid VkCommandPool handle"
VUID-vkDestroyCommandPool-commandPool-parent,Y,None,implicit,vkDestroyCommandPool,core," If commandPool is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroyCommandPool-device-parameter,Y,None,implicit,vkDestroyCommandPool,core, device must be a valid VkDevice handle
VUID-vkDestroyCommandPool-pAllocator-parameter,N,None,implicit,vkDestroyCommandPool,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyDebugReportCallbackEXT-callback-parameter,N,None,implicit,vkDestroyDebugReportCallbackEXT,(VK_EXT_debug_report), callback must be a valid VkDebugReportCallbackEXT handle
VUID-vkDestroyDebugReportCallbackEXT-callback-parent,N,None,implicit,vkDestroyDebugReportCallbackEXT,(VK_EXT_debug_report)," callback must have been created, allocated, or retrieved from instance"
VUID-vkDestroyDebugReportCallbackEXT-instance-01242,Y,None,explicit,vkDestroyDebugReportCallbackEXT,(VK_EXT_debug_report)," If VkAllocationCallbacks were provided when callback was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyDebugReportCallbackEXT-instance-01243,Y,None,explicit,vkDestroyDebugReportCallbackEXT,(VK_EXT_debug_report)," If no VkAllocationCallbacks were provided when callback was created, pAllocator must be NULL"
VUID-vkDestroyDebugReportCallbackEXT-instance-parameter,N,None,implicit,vkDestroyDebugReportCallbackEXT,(VK_EXT_debug_report), instance must be a valid VkInstance handle
VUID-vkDestroyDebugReportCallbackEXT-pAllocator-parameter,N,None,implicit,vkDestroyDebugReportCallbackEXT,(VK_EXT_debug_report)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyDebugUtilsMessengerEXT-instance-parameter,N,None,implicit,vkDestroyDebugUtilsMessengerEXT,(VK_EXT_debug_utils), instance must be a valid VkInstance handle
VUID-vkDestroyDebugUtilsMessengerEXT-messenger-01915,N,None,explicit,vkDestroyDebugUtilsMessengerEXT,(VK_EXT_debug_utils)," If VkAllocationCallbacks were provided when messenger was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyDebugUtilsMessengerEXT-messenger-01916,N,None,explicit,vkDestroyDebugUtilsMessengerEXT,(VK_EXT_debug_utils)," If no VkAllocationCallbacks were provided when messenger was created, pAllocator must be NULL"
VUID-vkDestroyDebugUtilsMessengerEXT-messenger-parameter,N,None,implicit,vkDestroyDebugUtilsMessengerEXT,(VK_EXT_debug_utils), messenger must be a valid VkDebugUtilsMessengerEXT handle
VUID-vkDestroyDebugUtilsMessengerEXT-messenger-parent,N,None,implicit,vkDestroyDebugUtilsMessengerEXT,(VK_EXT_debug_utils)," messenger must have been created, allocated, or retrieved from instance"
VUID-vkDestroyDebugUtilsMessengerEXT-pAllocator-parameter,N,None,implicit,vkDestroyDebugUtilsMessengerEXT,(VK_EXT_debug_utils)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyDescriptorPool-descriptorPool-00303,Y,DescriptorPoolInUseDestroyedSignaled,explicit,vkDestroyDescriptorPool,core, All submitted commands that refer to descriptorPool (via any allocated descriptor sets) must have completed execution
VUID-vkDestroyDescriptorPool-descriptorPool-00304,Y,None,explicit,vkDestroyDescriptorPool,core," If VkAllocationCallbacks were provided when descriptorPool was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyDescriptorPool-descriptorPool-00305,Y,None,explicit,vkDestroyDescriptorPool,core," If no VkAllocationCallbacks were provided when descriptorPool was created, pAllocator must be NULL"
VUID-vkDestroyDescriptorPool-descriptorPool-parameter,Y,None,implicit,vkDestroyDescriptorPool,core," If descriptorPool is not VK_NULL_HANDLE, descriptorPool must be a valid VkDescriptorPool handle"
VUID-vkDestroyDescriptorPool-descriptorPool-parent,Y,None,implicit,vkDestroyDescriptorPool,core," If descriptorPool is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroyDescriptorPool-device-parameter,Y,None,implicit,vkDestroyDescriptorPool,core, device must be a valid VkDevice handle
VUID-vkDestroyDescriptorPool-pAllocator-parameter,N,None,implicit,vkDestroyDescriptorPool,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00284,Y,None,explicit,vkDestroyDescriptorSetLayout,core," If VkAllocationCallbacks were provided when descriptorSetLayout was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00285,Y,None,explicit,vkDestroyDescriptorSetLayout,core," If no VkAllocationCallbacks were provided when descriptorSetLayout was created, pAllocator must be NULL"
VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parameter,Y,None,implicit,vkDestroyDescriptorSetLayout,core," If descriptorSetLayout is not VK_NULL_HANDLE, descriptorSetLayout must be a valid VkDescriptorSetLayout handle"
VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parent,Y,None,implicit,vkDestroyDescriptorSetLayout,core," If descriptorSetLayout is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroyDescriptorSetLayout-device-parameter,Y,None,implicit,vkDestroyDescriptorSetLayout,core, device must be a valid VkDevice handle
VUID-vkDestroyDescriptorSetLayout-pAllocator-parameter,N,None,implicit,vkDestroyDescriptorSetLayout,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyDescriptorUpdateTemplate-descriptorSetLayout-00356,Y,None,explicit,vkDestroyDescriptorUpdateTemplate,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)"," If VkAllocationCallbacks were provided when descriptorSetLayout was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyDescriptorUpdateTemplate-descriptorSetLayout-00357,Y,None,explicit,vkDestroyDescriptorUpdateTemplate,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)"," If no VkAllocationCallbacks were provided when descriptorSetLayout was created, pAllocator must be NULL"
VUID-vkDestroyDescriptorUpdateTemplate-descriptorUpdateTemplate-parameter,Y,None,implicit,vkDestroyDescriptorUpdateTemplate,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)"," If descriptorUpdateTemplate is not VK_NULL_HANDLE, descriptorUpdateTemplate must be a valid VkDescriptorUpdateTemplate handle"
VUID-vkDestroyDescriptorUpdateTemplate-descriptorUpdateTemplate-parent,Y,None,implicit,vkDestroyDescriptorUpdateTemplate,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)"," If descriptorUpdateTemplate is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroyDescriptorUpdateTemplate-device-parameter,Y,None,implicit,vkDestroyDescriptorUpdateTemplate,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", device must be a valid VkDevice handle
VUID-vkDestroyDescriptorUpdateTemplate-pAllocator-parameter,N,None,implicit,vkDestroyDescriptorUpdateTemplate,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)"," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyDevice-device-00378,Y,None,explicit,vkDestroyDevice,core, All child objects created on device must have been destroyed prior to destroying device
VUID-vkDestroyDevice-device-00379,Y,None,explicit,vkDestroyDevice,core," If VkAllocationCallbacks were provided when device was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyDevice-device-00380,Y,None,explicit,vkDestroyDevice,core," If no VkAllocationCallbacks were provided when device was created, pAllocator must be NULL"
VUID-vkDestroyDevice-device-parameter,Y,None,implicit,vkDestroyDevice,core," If device is not NULL, device must be a valid VkDevice handle"
VUID-vkDestroyDevice-pAllocator-parameter,N,None,implicit,vkDestroyDevice,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyEvent-device-parameter,Y,None,implicit,vkDestroyEvent,core, device must be a valid VkDevice handle
VUID-vkDestroyEvent-event-01145,Y,InUseDestroyedSignaled,explicit,vkDestroyEvent,core, All submitted commands that refer to event must have completed execution
VUID-vkDestroyEvent-event-01146,Y,None,explicit,vkDestroyEvent,core," If VkAllocationCallbacks were provided when event was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyEvent-event-01147,Y,None,explicit,vkDestroyEvent,core," If no VkAllocationCallbacks were provided when event was created, pAllocator must be NULL"
VUID-vkDestroyEvent-event-parameter,Y,None,implicit,vkDestroyEvent,core," If event is not VK_NULL_HANDLE, event must be a valid VkEvent handle"
VUID-vkDestroyEvent-event-parent,Y,None,implicit,vkDestroyEvent,core," If event is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroyEvent-pAllocator-parameter,N,None,implicit,vkDestroyEvent,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyFence-device-parameter,Y,None,implicit,vkDestroyFence,core, device must be a valid VkDevice handle
VUID-vkDestroyFence-fence-01120,Y,None,explicit,vkDestroyFence,core, All queue submission commands that refer to fence must have completed execution
VUID-vkDestroyFence-fence-01121,Y,None,explicit,vkDestroyFence,core," If VkAllocationCallbacks were provided when fence was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyFence-fence-01122,Y,None,explicit,vkDestroyFence,core," If no VkAllocationCallbacks were provided when fence was created, pAllocator must be NULL"
VUID-vkDestroyFence-fence-parameter,Y,None,implicit,vkDestroyFence,core," If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle"
VUID-vkDestroyFence-fence-parent,Y,None,implicit,vkDestroyFence,core," If fence is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroyFence-pAllocator-parameter,N,None,implicit,vkDestroyFence,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyFramebuffer-device-parameter,Y,None,implicit,vkDestroyFramebuffer,core, device must be a valid VkDevice handle
VUID-vkDestroyFramebuffer-framebuffer-00892,Y,FramebufferInUseDestroyedSignaled,explicit,vkDestroyFramebuffer,core, All submitted commands that refer to framebuffer must have completed execution
VUID-vkDestroyFramebuffer-framebuffer-00893,Y,None,explicit,vkDestroyFramebuffer,core," If VkAllocationCallbacks were provided when framebuffer was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyFramebuffer-framebuffer-00894,Y,None,explicit,vkDestroyFramebuffer,core," If no VkAllocationCallbacks were provided when framebuffer was created, pAllocator must be NULL"
VUID-vkDestroyFramebuffer-framebuffer-parameter,Y,None,implicit,vkDestroyFramebuffer,core," If framebuffer is not VK_NULL_HANDLE, framebuffer must be a valid VkFramebuffer handle"
VUID-vkDestroyFramebuffer-framebuffer-parent,Y,None,implicit,vkDestroyFramebuffer,core," If framebuffer is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroyFramebuffer-pAllocator-parameter,N,None,implicit,vkDestroyFramebuffer,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyImage-device-parameter,Y,None,implicit,vkDestroyImage,core, device must be a valid VkDevice handle
VUID-vkDestroyImage-image-01000,Y,FramebufferImageInUseDestroyedSignaled,explicit,vkDestroyImage,core," All submitted commands that refer to image, either directly or via a VkImageView, must have completed execution"
VUID-vkDestroyImage-image-01001,Y,None,explicit,vkDestroyImage,core," If VkAllocationCallbacks were provided when image was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyImage-image-01002,Y,None,explicit,vkDestroyImage,core," If no VkAllocationCallbacks were provided when image was created, pAllocator must be NULL"
VUID-vkDestroyImage-image-parameter,Y,None,implicit,vkDestroyImage,core," If image is not VK_NULL_HANDLE, image must be a valid VkImage handle"
VUID-vkDestroyImage-image-parent,Y,None,implicit,vkDestroyImage,core," If image is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroyImage-pAllocator-parameter,N,None,implicit,vkDestroyImage,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyImageView-device-parameter,Y,None,implicit,vkDestroyImageView,core, device must be a valid VkDevice handle
VUID-vkDestroyImageView-imageView-01026,Y,ImageViewInUseDestroyedSignaled,explicit,vkDestroyImageView,core, All submitted commands that refer to imageView must have completed execution
VUID-vkDestroyImageView-imageView-01027,Y,None,explicit,vkDestroyImageView,core," If VkAllocationCallbacks were provided when imageView was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyImageView-imageView-01028,Y,None,explicit,vkDestroyImageView,core," If no VkAllocationCallbacks were provided when imageView was created, pAllocator must be NULL"
VUID-vkDestroyImageView-imageView-parameter,Y,None,implicit,vkDestroyImageView,core," If imageView is not VK_NULL_HANDLE, imageView must be a valid VkImageView handle"
VUID-vkDestroyImageView-imageView-parent,Y,None,implicit,vkDestroyImageView,core," If imageView is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroyImageView-pAllocator-parameter,N,None,implicit,vkDestroyImageView,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyIndirectCommandsLayoutNVX-device-parameter,Y,None,implicit,vkDestroyIndirectCommandsLayoutNVX,(VK_NVX_device_generated_commands), device must be a valid VkDevice handle
VUID-vkDestroyIndirectCommandsLayoutNVX-indirectCommandsLayout-01352,N,None,explicit,vkDestroyIndirectCommandsLayoutNVX,(VK_NVX_device_generated_commands), All submitted commands that refer to indirectCommandsLayout must have completed execution
VUID-vkDestroyIndirectCommandsLayoutNVX-indirectCommandsLayout-parameter,Y,None,implicit,vkDestroyIndirectCommandsLayoutNVX,(VK_NVX_device_generated_commands), indirectCommandsLayout must be a valid VkIndirectCommandsLayoutNVX handle
VUID-vkDestroyIndirectCommandsLayoutNVX-indirectCommandsLayout-parent,Y,None,implicit,vkDestroyIndirectCommandsLayoutNVX,(VK_NVX_device_generated_commands)," indirectCommandsLayout must have been created, allocated, or retrieved from device"
VUID-vkDestroyIndirectCommandsLayoutNVX-objectTable-01353,N,None,explicit,vkDestroyIndirectCommandsLayoutNVX,(VK_NVX_device_generated_commands)," If VkAllocationCallbacks were provided when objectTable was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyIndirectCommandsLayoutNVX-objectTable-01354,N,None,explicit,vkDestroyIndirectCommandsLayoutNVX,(VK_NVX_device_generated_commands)," If no VkAllocationCallbacks were provided when objectTable was created, pAllocator must be NULL"
VUID-vkDestroyIndirectCommandsLayoutNVX-pAllocator-parameter,N,None,implicit,vkDestroyIndirectCommandsLayoutNVX,(VK_NVX_device_generated_commands)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyInstance-instance-00629,Y,None,explicit,vkDestroyInstance,core, All child objects created using instance must have been destroyed prior to destroying instance
VUID-vkDestroyInstance-instance-00630,Y,None,explicit,vkDestroyInstance,core," If VkAllocationCallbacks were provided when instance was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyInstance-instance-00631,Y,None,explicit,vkDestroyInstance,core," If no VkAllocationCallbacks were provided when instance was created, pAllocator must be NULL"
VUID-vkDestroyInstance-instance-parameter,Y,None,implicit,vkDestroyInstance,core," If instance is not NULL, instance must be a valid VkInstance handle"
VUID-vkDestroyInstance-pAllocator-parameter,N,None,implicit,vkDestroyInstance,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyObjectTableNVX-device-parameter,Y,None,implicit,vkDestroyObjectTableNVX,(VK_NVX_device_generated_commands), device must be a valid VkDevice handle
VUID-vkDestroyObjectTableNVX-objectTable-01361,N,None,explicit,vkDestroyObjectTableNVX,(VK_NVX_device_generated_commands), All submitted commands that refer to objectTable must have completed execution.
VUID-vkDestroyObjectTableNVX-objectTable-01362,N,None,explicit,vkDestroyObjectTableNVX,(VK_NVX_device_generated_commands)," If VkAllocationCallbacks were provided when objectTable was created, a compatible set of callbacks must be provided here."
VUID-vkDestroyObjectTableNVX-objectTable-01363,N,None,explicit,vkDestroyObjectTableNVX,(VK_NVX_device_generated_commands)," If no VkAllocationCallbacks were provided when objectTable was created, pAllocator must be NULL."
VUID-vkDestroyObjectTableNVX-objectTable-parameter,Y,None,implicit,vkDestroyObjectTableNVX,(VK_NVX_device_generated_commands), objectTable must be a valid VkObjectTableNVX handle
VUID-vkDestroyObjectTableNVX-objectTable-parent,Y,None,implicit,vkDestroyObjectTableNVX,(VK_NVX_device_generated_commands)," objectTable must have been created, allocated, or retrieved from device"
VUID-vkDestroyObjectTableNVX-pAllocator-parameter,N,None,implicit,vkDestroyObjectTableNVX,(VK_NVX_device_generated_commands)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyPipeline-device-parameter,Y,None,implicit,vkDestroyPipeline,core, device must be a valid VkDevice handle
VUID-vkDestroyPipeline-pAllocator-parameter,N,None,implicit,vkDestroyPipeline,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyPipeline-pipeline-00765,Y,PipelineInUseDestroyedSignaled,explicit,vkDestroyPipeline,core, All submitted commands that refer to pipeline must have completed execution
VUID-vkDestroyPipeline-pipeline-00766,Y,None,explicit,vkDestroyPipeline,core," If VkAllocationCallbacks were provided when pipeline was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyPipeline-pipeline-00767,Y,None,explicit,vkDestroyPipeline,core," If no VkAllocationCallbacks were provided when pipeline was created, pAllocator must be NULL"
VUID-vkDestroyPipeline-pipeline-parameter,Y,None,implicit,vkDestroyPipeline,core," If pipeline is not VK_NULL_HANDLE, pipeline must be a valid VkPipeline handle"
VUID-vkDestroyPipeline-pipeline-parent,Y,None,implicit,vkDestroyPipeline,core," If pipeline is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroyPipelineCache-device-parameter,Y,None,implicit,vkDestroyPipelineCache,core, device must be a valid VkDevice handle
VUID-vkDestroyPipelineCache-pAllocator-parameter,N,None,implicit,vkDestroyPipelineCache,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyPipelineCache-pipelineCache-00771,Y,None,explicit,vkDestroyPipelineCache,core," If VkAllocationCallbacks were provided when pipelineCache was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyPipelineCache-pipelineCache-00772,Y,None,explicit,vkDestroyPipelineCache,core," If no VkAllocationCallbacks were provided when pipelineCache was created, pAllocator must be NULL"
VUID-vkDestroyPipelineCache-pipelineCache-parameter,Y,None,implicit,vkDestroyPipelineCache,core," If pipelineCache is not VK_NULL_HANDLE, pipelineCache must be a valid VkPipelineCache handle"
VUID-vkDestroyPipelineCache-pipelineCache-parent,Y,None,implicit,vkDestroyPipelineCache,core," If pipelineCache is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroyPipelineLayout-device-parameter,Y,None,implicit,vkDestroyPipelineLayout,core, device must be a valid VkDevice handle
VUID-vkDestroyPipelineLayout-pAllocator-parameter,N,None,implicit,vkDestroyPipelineLayout,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyPipelineLayout-pipelineLayout-00299,Y,None,explicit,vkDestroyPipelineLayout,core," If VkAllocationCallbacks were provided when pipelineLayout was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyPipelineLayout-pipelineLayout-00300,Y,None,explicit,vkDestroyPipelineLayout,core," If no VkAllocationCallbacks were provided when pipelineLayout was created, pAllocator must be NULL"
VUID-vkDestroyPipelineLayout-pipelineLayout-02004,N,None,explicit,vkDestroyPipelineLayout,core, pipelineLayout must not have been passed to any vkCmd* command for any command buffers that are still in the recording state when vkDestroyPipelineLayout is called
VUID-vkDestroyPipelineLayout-pipelineLayout-parameter,Y,None,implicit,vkDestroyPipelineLayout,core," If pipelineLayout is not VK_NULL_HANDLE, pipelineLayout must be a valid VkPipelineLayout handle"
VUID-vkDestroyPipelineLayout-pipelineLayout-parent,Y,None,implicit,vkDestroyPipelineLayout,core," If pipelineLayout is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroyQueryPool-device-parameter,Y,None,implicit,vkDestroyQueryPool,core, device must be a valid VkDevice handle
VUID-vkDestroyQueryPool-pAllocator-parameter,N,None,implicit,vkDestroyQueryPool,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyQueryPool-queryPool-00793,Y,QueryPoolInUseDestroyedSignaled,explicit,vkDestroyQueryPool,core, All submitted commands that refer to queryPool must have completed execution
VUID-vkDestroyQueryPool-queryPool-00794,Y,None,explicit,vkDestroyQueryPool,core," If VkAllocationCallbacks were provided when queryPool was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyQueryPool-queryPool-00795,Y,None,explicit,vkDestroyQueryPool,core," If no VkAllocationCallbacks were provided when queryPool was created, pAllocator must be NULL"
VUID-vkDestroyQueryPool-queryPool-parameter,Y,None,implicit,vkDestroyQueryPool,core," If queryPool is not VK_NULL_HANDLE, queryPool must be a valid VkQueryPool handle"
VUID-vkDestroyQueryPool-queryPool-parent,Y,None,implicit,vkDestroyQueryPool,core," If queryPool is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroyRenderPass-device-parameter,Y,None,implicit,vkDestroyRenderPass,core, device must be a valid VkDevice handle
VUID-vkDestroyRenderPass-pAllocator-parameter,N,None,implicit,vkDestroyRenderPass,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyRenderPass-renderPass-00873,Y,RenderPassInUseDestroyedSignaled,explicit,vkDestroyRenderPass,core, All submitted commands that refer to renderPass must have completed execution
VUID-vkDestroyRenderPass-renderPass-00874,Y,None,explicit,vkDestroyRenderPass,core," If VkAllocationCallbacks were provided when renderPass was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyRenderPass-renderPass-00875,Y,None,explicit,vkDestroyRenderPass,core," If no VkAllocationCallbacks were provided when renderPass was created, pAllocator must be NULL"
VUID-vkDestroyRenderPass-renderPass-parameter,Y,None,implicit,vkDestroyRenderPass,core," If renderPass is not VK_NULL_HANDLE, renderPass must be a valid VkRenderPass handle"
VUID-vkDestroyRenderPass-renderPass-parent,Y,UseObjectWithWrongDevice,implicit,vkDestroyRenderPass,core," If renderPass is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroySampler-device-parameter,Y,None,implicit,vkDestroySampler,core, device must be a valid VkDevice handle
VUID-vkDestroySampler-pAllocator-parameter,N,None,implicit,vkDestroySampler,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroySampler-sampler-01082,Y,SamplerInUseDestroyedSignaled,explicit,vkDestroySampler,core, All submitted commands that refer to sampler must have completed execution
VUID-vkDestroySampler-sampler-01083,Y,None,explicit,vkDestroySampler,core," If VkAllocationCallbacks were provided when sampler was created, a compatible set of callbacks must be provided here"
VUID-vkDestroySampler-sampler-01084,Y,None,explicit,vkDestroySampler,core," If no VkAllocationCallbacks were provided when sampler was created, pAllocator must be NULL"
VUID-vkDestroySampler-sampler-parameter,Y,None,implicit,vkDestroySampler,core," If sampler is not VK_NULL_HANDLE, sampler must be a valid VkSampler handle"
VUID-vkDestroySampler-sampler-parent,Y,None,implicit,vkDestroySampler,core," If sampler is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroySamplerYcbcrConversion-device-parameter,Y,None,implicit,vkDestroySamplerYcbcrConversion,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", device must be a valid VkDevice handle
VUID-vkDestroySamplerYcbcrConversion-pAllocator-parameter,N,None,implicit,vkDestroySamplerYcbcrConversion,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroySamplerYcbcrConversion-ycbcrConversion-parameter,Y,None,implicit,vkDestroySamplerYcbcrConversion,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If ycbcrConversion is not VK_NULL_HANDLE, ycbcrConversion must be a valid VkSamplerYcbcrConversion handle"
VUID-vkDestroySamplerYcbcrConversion-ycbcrConversion-parent,Y,None,implicit,vkDestroySamplerYcbcrConversion,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If ycbcrConversion is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroySemaphore-device-parameter,Y,None,implicit,vkDestroySemaphore,core, device must be a valid VkDevice handle
VUID-vkDestroySemaphore-pAllocator-parameter,N,None,implicit,vkDestroySemaphore,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroySemaphore-semaphore-01137,Y,InUseDestroyedSignaled,explicit,vkDestroySemaphore,core, All submitted batches that refer to semaphore must have completed execution
VUID-vkDestroySemaphore-semaphore-01138,Y,None,explicit,vkDestroySemaphore,core," If VkAllocationCallbacks were provided when semaphore was created, a compatible set of callbacks must be provided here"
VUID-vkDestroySemaphore-semaphore-01139,Y,None,explicit,vkDestroySemaphore,core," If no VkAllocationCallbacks were provided when semaphore was created, pAllocator must be NULL"
VUID-vkDestroySemaphore-semaphore-parameter,Y,None,implicit,vkDestroySemaphore,core," If semaphore is not VK_NULL_HANDLE, semaphore must be a valid VkSemaphore handle"
VUID-vkDestroySemaphore-semaphore-parent,Y,None,implicit,vkDestroySemaphore,core," If semaphore is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroyShaderModule-device-parameter,Y,None,implicit,vkDestroyShaderModule,core, device must be a valid VkDevice handle
VUID-vkDestroyShaderModule-pAllocator-parameter,N,None,implicit,vkDestroyShaderModule,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyShaderModule-shaderModule-01092,Y,None,explicit,vkDestroyShaderModule,core," If VkAllocationCallbacks were provided when shaderModule was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyShaderModule-shaderModule-01093,Y,None,explicit,vkDestroyShaderModule,core," If no VkAllocationCallbacks were provided when shaderModule was created, pAllocator must be NULL"
VUID-vkDestroyShaderModule-shaderModule-parameter,Y,None,implicit,vkDestroyShaderModule,core," If shaderModule is not VK_NULL_HANDLE, shaderModule must be a valid VkShaderModule handle"
VUID-vkDestroyShaderModule-shaderModule-parent,Y,None,implicit,vkDestroyShaderModule,core," If shaderModule is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDestroySurfaceKHR-instance-parameter,Y,None,implicit,vkDestroySurfaceKHR,(VK_KHR_surface), instance must be a valid VkInstance handle
VUID-vkDestroySurfaceKHR-pAllocator-parameter,N,None,implicit,vkDestroySurfaceKHR,(VK_KHR_surface)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroySurfaceKHR-surface-01266,Y,None,explicit,vkDestroySurfaceKHR,(VK_KHR_surface), All VkSwapchainKHR objects created for surface must have been destroyed prior to destroying surface
VUID-vkDestroySurfaceKHR-surface-01267,Y,None,explicit,vkDestroySurfaceKHR,(VK_KHR_surface)," If VkAllocationCallbacks were provided when surface was created, a compatible set of callbacks must be provided here"
VUID-vkDestroySurfaceKHR-surface-01268,Y,None,explicit,vkDestroySurfaceKHR,(VK_KHR_surface)," If no VkAllocationCallbacks were provided when surface was created, pAllocator must be NULL"
VUID-vkDestroySurfaceKHR-surface-parameter,Y,None,implicit,vkDestroySurfaceKHR,(VK_KHR_surface)," If surface is not VK_NULL_HANDLE, surface must be a valid VkSurfaceKHR handle"
VUID-vkDestroySurfaceKHR-surface-parent,Y,None,implicit,vkDestroySurfaceKHR,(VK_KHR_surface)," If surface is a valid handle, it must have been created, allocated, or retrieved from instance"
VUID-vkDestroySwapchainKHR-commonparent,N,None,implicit,vkDestroySwapchainKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," Both of device, and swapchain that are valid handles must have been created, allocated, or retrieved from the same VkInstance"
VUID-vkDestroySwapchainKHR-device-parameter,N,None,implicit,vkDestroySwapchainKHR,(VK_KHR_surface)+(VK_KHR_swapchain), device must be a valid VkDevice handle
VUID-vkDestroySwapchainKHR-pAllocator-parameter,N,None,implicit,vkDestroySwapchainKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroySwapchainKHR-swapchain-01282,N,None,explicit,vkDestroySwapchainKHR,(VK_KHR_surface)+(VK_KHR_swapchain), All uses of presentable images acquired from swapchain must have completed execution
VUID-vkDestroySwapchainKHR-swapchain-01283,Y,None,explicit,vkDestroySwapchainKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," If VkAllocationCallbacks were provided when swapchain was created, a compatible set of callbacks must be provided here"
VUID-vkDestroySwapchainKHR-swapchain-01284,Y,None,explicit,vkDestroySwapchainKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," If no VkAllocationCallbacks were provided when swapchain was created, pAllocator must be NULL"
VUID-vkDestroySwapchainKHR-swapchain-parameter,N,None,implicit,vkDestroySwapchainKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," If swapchain is not VK_NULL_HANDLE, swapchain must be a valid VkSwapchainKHR handle"
VUID-vkDestroyValidationCacheEXT-device-parameter,Y,None,implicit,vkDestroyValidationCacheEXT,(VK_EXT_validation_cache), device must be a valid VkDevice handle
VUID-vkDestroyValidationCacheEXT-pAllocator-parameter,N,None,implicit,vkDestroyValidationCacheEXT,(VK_EXT_validation_cache)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkDestroyValidationCacheEXT-validationCache-01537,N,None,explicit,vkDestroyValidationCacheEXT,(VK_EXT_validation_cache)," If VkAllocationCallbacks were provided when validationCache was created, a compatible set of callbacks must be provided here"
VUID-vkDestroyValidationCacheEXT-validationCache-01538,N,None,explicit,vkDestroyValidationCacheEXT,(VK_EXT_validation_cache)," If no VkAllocationCallbacks were provided when validationCache was created, pAllocator must be NULL"
VUID-vkDestroyValidationCacheEXT-validationCache-parameter,Y,None,implicit,vkDestroyValidationCacheEXT,(VK_EXT_validation_cache)," If validationCache is not VK_NULL_HANDLE, validationCache must be a valid VkValidationCacheEXT handle"
VUID-vkDestroyValidationCacheEXT-validationCache-parent,Y,None,implicit,vkDestroyValidationCacheEXT,(VK_EXT_validation_cache)," If validationCache is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkDeviceWaitIdle-device-parameter,Y,None,implicit,vkDeviceWaitIdle,core, device must be a valid VkDevice handle
VUID-vkDisplayPowerControlEXT-device-parameter,Y,None,implicit,vkDisplayPowerControlEXT,(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_display_control), device must be a valid VkDevice handle
VUID-vkDisplayPowerControlEXT-display-parameter,Y,None,implicit,vkDisplayPowerControlEXT,(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_display_control), display must be a valid VkDisplayKHR handle
VUID-vkDisplayPowerControlEXT-pDisplayPowerInfo-parameter,Y,None,implicit,vkDisplayPowerControlEXT,(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_display_control), pDisplayPowerInfo must be a valid pointer to a valid VkDisplayPowerInfoEXT structure
VUID-vkEndCommandBuffer-None-01978,N,None,explicit,vkEndCommandBuffer,(VK_EXT_conditional_rendering), Conditional rendering must not be active
VUID-vkEndCommandBuffer-commandBuffer-00059,Y,None,explicit,vkEndCommandBuffer,core, commandBuffer must be in the recording state.
VUID-vkEndCommandBuffer-commandBuffer-00060,Y,None,explicit,vkEndCommandBuffer,core," If commandBuffer is a primary command buffer, there must not be an active render pass instance"
VUID-vkEndCommandBuffer-commandBuffer-00061,Y,None,explicit,vkEndCommandBuffer,core, All queries made active during the recording of commandBuffer must have been made inactive
VUID-vkEndCommandBuffer-commandBuffer-00062,N,None,explicit,vkEndCommandBuffer,(VK_EXT_debug_marker)," If commandBuffer is a secondary command buffer, there must not be an outstanding vkCmdDebugMarkerBeginEXT command recorded to commandBuffer that has not previously been ended by a call to vkCmdDebugMarkerEndEXT."
VUID-vkEndCommandBuffer-commandBuffer-01815,N,None,explicit,vkEndCommandBuffer,(VK_EXT_debug_utils)," If commandBuffer is a secondary command buffer, there must not be an outstanding vkCmdBeginDebugUtilsLabelEXT command recorded to commandBuffer that has not previously been ended by a call to vkCmdEndDebugUtilsLabelEXT."
VUID-vkEndCommandBuffer-commandBuffer-parameter,Y,None,implicit,vkEndCommandBuffer,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkEnumerateDeviceExtensionProperties-pLayerName-parameter,N,None,implicit,vkEnumerateDeviceExtensionProperties,core," If pLayerName is not NULL, pLayerName must be a null-terminated UTF-8 string"
VUID-vkEnumerateDeviceExtensionProperties-pProperties-parameter,Y,None,implicit,vkEnumerateDeviceExtensionProperties,core," If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkExtensionProperties structures"
VUID-vkEnumerateDeviceExtensionProperties-pPropertyCount-parameter,N,None,implicit,vkEnumerateDeviceExtensionProperties,core, pPropertyCount must be a valid pointer to a uint32_t value
VUID-vkEnumerateDeviceExtensionProperties-physicalDevice-parameter,N,None,implicit,vkEnumerateDeviceExtensionProperties,core, physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkEnumerateDeviceLayerProperties-pProperties-parameter,N,None,implicit,vkEnumerateDeviceLayerProperties,core," If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkLayerProperties structures"
VUID-vkEnumerateDeviceLayerProperties-pPropertyCount-parameter,N,None,implicit,vkEnumerateDeviceLayerProperties,core, pPropertyCount must be a valid pointer to a uint32_t value
VUID-vkEnumerateDeviceLayerProperties-physicalDevice-parameter,N,None,implicit,vkEnumerateDeviceLayerProperties,core, physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkEnumerateInstanceExtensionProperties-pLayerName-parameter,N,None,implicit,vkEnumerateInstanceExtensionProperties,core," If pLayerName is not NULL, pLayerName must be a null-terminated UTF-8 string"
VUID-vkEnumerateInstanceExtensionProperties-pProperties-parameter,N,None,implicit,vkEnumerateInstanceExtensionProperties,core," If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkExtensionProperties structures"
VUID-vkEnumerateInstanceExtensionProperties-pPropertyCount-parameter,N,None,implicit,vkEnumerateInstanceExtensionProperties,core, pPropertyCount must be a valid pointer to a uint32_t value
VUID-vkEnumerateInstanceLayerProperties-pProperties-parameter,N,None,implicit,vkEnumerateInstanceLayerProperties,core," If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkLayerProperties structures"
VUID-vkEnumerateInstanceLayerProperties-pPropertyCount-parameter,N,None,implicit,vkEnumerateInstanceLayerProperties,core, pPropertyCount must be a valid pointer to a uint32_t value
VUID-vkEnumerateInstanceVersion-pApiVersion-parameter,N,None,implicit,vkEnumerateInstanceVersion,(VK_VERSION_1_1), pApiVersion must be a valid pointer to a uint32_t value
VUID-vkEnumeratePhysicalDeviceGroups-instance-parameter,Y,None,implicit,vkEnumeratePhysicalDeviceGroups,"(VK_VERSION_1_1,VK_KHR_device_group_creation)", instance must be a valid VkInstance handle
VUID-vkEnumeratePhysicalDeviceGroups-pPhysicalDeviceGroupCount-parameter,N,None,implicit,vkEnumeratePhysicalDeviceGroups,"(VK_VERSION_1_1,VK_KHR_device_group_creation)", pPhysicalDeviceGroupCount must be a valid pointer to a uint32_t value
VUID-vkEnumeratePhysicalDeviceGroups-pPhysicalDeviceGroupProperties-parameter,Y,None,implicit,vkEnumeratePhysicalDeviceGroups,"(VK_VERSION_1_1,VK_KHR_device_group_creation)"," If the value referenced by pPhysicalDeviceGroupCount is not 0, and pPhysicalDeviceGroupProperties is not NULL, pPhysicalDeviceGroupProperties must be a valid pointer to an array of pPhysicalDeviceGroupCount VkPhysicalDeviceGroupProperties structures"
VUID-vkEnumeratePhysicalDevices-instance-parameter,Y,None,implicit,vkEnumeratePhysicalDevices,core, instance must be a valid VkInstance handle
VUID-vkEnumeratePhysicalDevices-pPhysicalDeviceCount-parameter,N,None,implicit,vkEnumeratePhysicalDevices,core, pPhysicalDeviceCount must be a valid pointer to a uint32_t value
VUID-vkEnumeratePhysicalDevices-pPhysicalDevices-parameter,Y,None,implicit,vkEnumeratePhysicalDevices,core," If the value referenced by pPhysicalDeviceCount is not 0, and pPhysicalDevices is not NULL, pPhysicalDevices must be a valid pointer to an array of pPhysicalDeviceCount VkPhysicalDevice handles"
VUID-vkFlushMappedMemoryRanges-device-parameter,Y,None,implicit,vkFlushMappedMemoryRanges,core, device must be a valid VkDevice handle
VUID-vkFlushMappedMemoryRanges-memoryRangeCount-arraylength,N,None,implicit,vkFlushMappedMemoryRanges,core, memoryRangeCount must be greater than 0
VUID-vkFlushMappedMemoryRanges-pMemoryRanges-parameter,Y,None,implicit,vkFlushMappedMemoryRanges,core, pMemoryRanges must be a valid pointer to an array of memoryRangeCount valid VkMappedMemoryRange structures
VUID-vkFreeCommandBuffers-commandBufferCount-arraylength,N,None,implicit,vkFreeCommandBuffers,core, commandBufferCount must be greater than 0
VUID-vkFreeCommandBuffers-commandPool-parameter,Y,None,implicit,vkFreeCommandBuffers,core, commandPool must be a valid VkCommandPool handle
VUID-vkFreeCommandBuffers-commandPool-parent,Y,None,implicit,vkFreeCommandBuffers,core," commandPool must have been created, allocated, or retrieved from device"
VUID-vkFreeCommandBuffers-device-parameter,Y,None,implicit,vkFreeCommandBuffers,core, device must be a valid VkDevice handle
VUID-vkFreeCommandBuffers-pCommandBuffers-00047,Y,None,explicit,vkFreeCommandBuffers,core, All elements of pCommandBuffers must not be in the pending state
VUID-vkFreeCommandBuffers-pCommandBuffers-00048,Y,None,explicit,vkFreeCommandBuffers,core," pCommandBuffers must be a valid pointer to an array of commandBufferCount VkCommandBuffer handles, each element of which must either be a valid handle or NULL"
VUID-vkFreeCommandBuffers-pCommandBuffers-parent,Y,None,implicit,vkFreeCommandBuffers,core," Each element of pCommandBuffers that is a valid handle must have been created, allocated, or retrieved from commandPool"
VUID-vkFreeDescriptorSets-descriptorPool-00312,Y,FreeDescriptorFromOneShotPool,explicit,vkFreeDescriptorSets,core, descriptorPool must have been created with the VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT flag
VUID-vkFreeDescriptorSets-descriptorPool-parameter,Y,None,implicit,vkFreeDescriptorSets,core, descriptorPool must be a valid VkDescriptorPool handle
VUID-vkFreeDescriptorSets-descriptorPool-parent,Y,None,implicit,vkFreeDescriptorSets,core," descriptorPool must have been created, allocated, or retrieved from device"
VUID-vkFreeDescriptorSets-descriptorSetCount-arraylength,N,None,implicit,vkFreeDescriptorSets,core, descriptorSetCount must be greater than 0
VUID-vkFreeDescriptorSets-device-parameter,Y,None,implicit,vkFreeDescriptorSets,core, device must be a valid VkDevice handle
VUID-vkFreeDescriptorSets-pDescriptorSets-00309,Y,None,explicit,vkFreeDescriptorSets,core, All submitted commands that refer to any element of pDescriptorSets must have completed execution
VUID-vkFreeDescriptorSets-pDescriptorSets-00310,Y,None,explicit,vkFreeDescriptorSets,core," pDescriptorSets must be a valid pointer to an array of descriptorSetCount VkDescriptorSet handles, each element of which must either be a valid handle or VK_NULL_HANDLE"
VUID-vkFreeDescriptorSets-pDescriptorSets-00311,N,None,explicit,vkFreeDescriptorSets,core, Each valid handle in pDescriptorSets must have been allocated from descriptorPool
VUID-vkFreeDescriptorSets-pDescriptorSets-parent,Y,None,implicit,vkFreeDescriptorSets,core," Each element of pDescriptorSets that is a valid handle must have been created, allocated, or retrieved from descriptorPool"
VUID-vkFreeMemory-device-parameter,Y,None,implicit,vkFreeMemory,core, device must be a valid VkDevice handle
VUID-vkFreeMemory-memory-00677,Y,None,explicit,vkFreeMemory,core, All submitted commands that refer to memory (via images or buffers) must have completed execution
VUID-vkFreeMemory-memory-parameter,Y,VertexBufferInvalid,implicit,vkFreeMemory,core," If memory is not VK_NULL_HANDLE, memory must be a valid VkDeviceMemory handle"
VUID-vkFreeMemory-memory-parent,Y,None,implicit,vkFreeMemory,core," If memory is a valid handle, it must have been created, allocated, or retrieved from device"
VUID-vkFreeMemory-pAllocator-parameter,N,None,implicit,vkFreeMemory,core," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkGetAccelerationStructureHandleNVX-accelerationStructure-parameter,Y,None,implicit,vkGetAccelerationStructureHandleNVX,(VK_NVX_raytracing), accelerationStructure must be a valid VkAccelerationStructureNVX handle
VUID-vkGetAccelerationStructureHandleNVX-accelerationStructure-parent,Y,None,implicit,vkGetAccelerationStructureHandleNVX,(VK_NVX_raytracing)," accelerationStructure must have been created, allocated, or retrieved from device"
VUID-vkGetAccelerationStructureHandleNVX-dataSize-02240,N,None,explicit,vkGetAccelerationStructureHandleNVX,(VK_NVX_raytracing)," dataSize must be large enough to contain the result of the query, as described above"
VUID-vkGetAccelerationStructureHandleNVX-dataSize-arraylength,Y,None,implicit,vkGetAccelerationStructureHandleNVX,(VK_NVX_raytracing), dataSize must be greater than 0
VUID-vkGetAccelerationStructureHandleNVX-device-parameter,Y,None,implicit,vkGetAccelerationStructureHandleNVX,(VK_NVX_raytracing), device must be a valid VkDevice handle
VUID-vkGetAccelerationStructureHandleNVX-pData-parameter,Y,None,implicit,vkGetAccelerationStructureHandleNVX,(VK_NVX_raytracing), pData must be a valid pointer to an array of dataSize bytes
VUID-vkGetAccelerationStructureMemoryRequirementsNVX-device-parameter,Y,None,implicit,vkGetAccelerationStructureMemoryRequirementsNVX,(VK_NVX_raytracing), device must be a valid VkDevice handle
VUID-vkGetAccelerationStructureMemoryRequirementsNVX-pInfo-parameter,Y,None,implicit,vkGetAccelerationStructureMemoryRequirementsNVX,(VK_NVX_raytracing), pInfo must be a valid pointer to a valid VkAccelerationStructureMemoryRequirementsInfoNVX structure
VUID-vkGetAccelerationStructureMemoryRequirementsNVX-pMemoryRequirements-parameter,Y,None,implicit,vkGetAccelerationStructureMemoryRequirementsNVX,(VK_NVX_raytracing), pMemoryRequirements must be a valid pointer to a VkMemoryRequirements2KHR structure
VUID-vkGetAccelerationStructureScratchMemoryRequirementsNVX-device-parameter,Y,None,implicit,vkGetAccelerationStructureScratchMemoryRequirementsNVX,(VK_NVX_raytracing), device must be a valid VkDevice handle
VUID-vkGetAccelerationStructureScratchMemoryRequirementsNVX-pInfo-parameter,Y,None,implicit,vkGetAccelerationStructureScratchMemoryRequirementsNVX,(VK_NVX_raytracing), pInfo must be a valid pointer to a valid VkAccelerationStructureMemoryRequirementsInfoNVX structure
VUID-vkGetAccelerationStructureScratchMemoryRequirementsNVX-pMemoryRequirements-parameter,Y,None,implicit,vkGetAccelerationStructureScratchMemoryRequirementsNVX,(VK_NVX_raytracing), pMemoryRequirements must be a valid pointer to a VkMemoryRequirements2KHR structure
VUID-vkGetAndroidHardwareBufferPropertiesANDROID-buffer-01884,N,None,explicit,vkGetAndroidHardwareBufferPropertiesANDROID,(VK_ANDROID_external_memory_android_hardware_buffer), buffer must be a valid Android hardware buffer object with at least one of the AHARDWAREBUFFER_USAGE_GPU_* usage flags.
VUID-vkGetAndroidHardwareBufferPropertiesANDROID-buffer-parameter,Y,None,implicit,vkGetAndroidHardwareBufferPropertiesANDROID,(VK_ANDROID_external_memory_android_hardware_buffer), buffer must be a valid pointer to a valid AHardwareBuffer value
VUID-vkGetAndroidHardwareBufferPropertiesANDROID-device-parameter,Y,None,implicit,vkGetAndroidHardwareBufferPropertiesANDROID,(VK_ANDROID_external_memory_android_hardware_buffer), device must be a valid VkDevice handle
VUID-vkGetAndroidHardwareBufferPropertiesANDROID-pProperties-parameter,Y,None,implicit,vkGetAndroidHardwareBufferPropertiesANDROID,(VK_ANDROID_external_memory_android_hardware_buffer), pProperties must be a valid pointer to a VkAndroidHardwareBufferPropertiesANDROID structure
VUID-vkGetBufferMemoryRequirements-buffer-parameter,Y,None,implicit,vkGetBufferMemoryRequirements,core, buffer must be a valid VkBuffer handle
VUID-vkGetBufferMemoryRequirements-buffer-parent,Y,None,implicit,vkGetBufferMemoryRequirements,core," buffer must have been created, allocated, or retrieved from device"
VUID-vkGetBufferMemoryRequirements-device-parameter,Y,None,implicit,vkGetBufferMemoryRequirements,core, device must be a valid VkDevice handle
VUID-vkGetBufferMemoryRequirements-pMemoryRequirements-parameter,Y,None,implicit,vkGetBufferMemoryRequirements,core, pMemoryRequirements must be a valid pointer to a VkMemoryRequirements structure
VUID-vkGetBufferMemoryRequirements2-device-parameter,Y,None,implicit,vkGetBufferMemoryRequirements2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", device must be a valid VkDevice handle
VUID-vkGetBufferMemoryRequirements2-pInfo-parameter,Y,None,implicit,vkGetBufferMemoryRequirements2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", pInfo must be a valid pointer to a valid VkBufferMemoryRequirementsInfo2 structure
VUID-vkGetBufferMemoryRequirements2-pMemoryRequirements-parameter,Y,None,implicit,vkGetBufferMemoryRequirements2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", pMemoryRequirements must be a valid pointer to a VkMemoryRequirements2 structure
VUID-vkGetDescriptorSetLayoutSupport-device-parameter,Y,None,implicit,vkGetDescriptorSetLayoutSupport,"(VK_VERSION_1_1,VK_KHR_maintenance3)", device must be a valid VkDevice handle
VUID-vkGetDescriptorSetLayoutSupport-pCreateInfo-parameter,Y,None,implicit,vkGetDescriptorSetLayoutSupport,"(VK_VERSION_1_1,VK_KHR_maintenance3)", pCreateInfo must be a valid pointer to a valid VkDescriptorSetLayoutCreateInfo structure
VUID-vkGetDescriptorSetLayoutSupport-pSupport-parameter,Y,None,implicit,vkGetDescriptorSetLayoutSupport,"(VK_VERSION_1_1,VK_KHR_maintenance3)", pSupport must be a valid pointer to a VkDescriptorSetLayoutSupport structure
VUID-vkGetDeviceGroupPeerMemoryFeatures-device-parameter,Y,None,implicit,vkGetDeviceGroupPeerMemoryFeatures,"(VK_VERSION_1_1,VK_KHR_device_group)", device must be a valid VkDevice handle
VUID-vkGetDeviceGroupPeerMemoryFeatures-heapIndex-00691,N,None,explicit,vkGetDeviceGroupPeerMemoryFeatures,"(VK_VERSION_1_1,VK_KHR_device_group)", heapIndex must be less than memoryHeapCount
VUID-vkGetDeviceGroupPeerMemoryFeatures-localDeviceIndex-00692,N,None,explicit,vkGetDeviceGroupPeerMemoryFeatures,"(VK_VERSION_1_1,VK_KHR_device_group)", localDeviceIndex must be a valid device index
VUID-vkGetDeviceGroupPeerMemoryFeatures-localDeviceIndex-00694,N,None,explicit,vkGetDeviceGroupPeerMemoryFeatures,"(VK_VERSION_1_1,VK_KHR_device_group)", localDeviceIndex must not equal remoteDeviceIndex
VUID-vkGetDeviceGroupPeerMemoryFeatures-pPeerMemoryFeatures-parameter,Y,None,implicit,vkGetDeviceGroupPeerMemoryFeatures,"(VK_VERSION_1_1,VK_KHR_device_group)", pPeerMemoryFeatures must be a valid pointer to a VkPeerMemoryFeatureFlags value
VUID-vkGetDeviceGroupPeerMemoryFeatures-remoteDeviceIndex-00693,N,None,explicit,vkGetDeviceGroupPeerMemoryFeatures,"(VK_VERSION_1_1,VK_KHR_device_group)", remoteDeviceIndex must be a valid device index
VUID-vkGetDeviceGroupPresentCapabilitiesKHR-device-parameter,Y,None,implicit,vkGetDeviceGroupPresentCapabilitiesKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", device must be a valid VkDevice handle
VUID-vkGetDeviceGroupPresentCapabilitiesKHR-pDeviceGroupPresentCapabilities-parameter,Y,None,implicit,vkGetDeviceGroupPresentCapabilitiesKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", pDeviceGroupPresentCapabilities must be a valid pointer to a VkDeviceGroupPresentCapabilitiesKHR structure
VUID-vkGetDeviceGroupSurfacePresentModesKHR-commonparent,Y,None,implicit,vkGetDeviceGroupSurfacePresentModesKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)"," Both of device, and surface must have been created, allocated, or retrieved from the same VkInstance"
VUID-vkGetDeviceGroupSurfacePresentModesKHR-device-parameter,Y,None,implicit,vkGetDeviceGroupSurfacePresentModesKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", device must be a valid VkDevice handle
VUID-vkGetDeviceGroupSurfacePresentModesKHR-pModes-parameter,N,None,implicit,vkGetDeviceGroupSurfacePresentModesKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", pModes must be a valid pointer to a VkDeviceGroupPresentModeFlagsKHR value
VUID-vkGetDeviceGroupSurfacePresentModesKHR-surface-parameter,Y,None,implicit,vkGetDeviceGroupSurfacePresentModesKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", surface must be a valid VkSurfaceKHR handle
VUID-vkGetDeviceMemoryCommitment-device-parameter,Y,None,implicit,vkGetDeviceMemoryCommitment,core, device must be a valid VkDevice handle
VUID-vkGetDeviceMemoryCommitment-memory-00690,N,None,explicit,vkGetDeviceMemoryCommitment,core, memory must have been created with a memory type that reports VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT
VUID-vkGetDeviceMemoryCommitment-memory-parameter,Y,None,implicit,vkGetDeviceMemoryCommitment,core, memory must be a valid VkDeviceMemory handle
VUID-vkGetDeviceMemoryCommitment-memory-parent,Y,None,implicit,vkGetDeviceMemoryCommitment,core," memory must have been created, allocated, or retrieved from device"
VUID-vkGetDeviceMemoryCommitment-pCommittedMemoryInBytes-parameter,Y,None,implicit,vkGetDeviceMemoryCommitment,core, pCommittedMemoryInBytes must be a valid pointer to a VkDeviceSize value
VUID-vkGetDeviceProcAddr-device-parameter,N,None,implicit,vkGetDeviceProcAddr,core, device must be a valid VkDevice handle
VUID-vkGetDeviceProcAddr-pName-parameter,N,None,implicit,vkGetDeviceProcAddr,core, pName must be a null-terminated UTF-8 string
VUID-vkGetDeviceQueue-device-parameter,Y,None,implicit,vkGetDeviceQueue,core, device must be a valid VkDevice handle
VUID-vkGetDeviceQueue-flags-01841,N,None,explicit,vkGetDeviceQueue,core, VkDeviceQueueCreateInfo::flags must have been set to zero when device was created
VUID-vkGetDeviceQueue-pQueue-parameter,Y,None,implicit,vkGetDeviceQueue,core, pQueue must be a valid pointer to a VkQueue handle
VUID-vkGetDeviceQueue-queueFamilyIndex-00384,Y,None,explicit,vkGetDeviceQueue,core," queueFamilyIndex must be one of the queue family indices specified when device was created, via the VkDeviceQueueCreateInfo structure"
VUID-vkGetDeviceQueue-queueIndex-00385,Y,None,explicit,vkGetDeviceQueue,core," queueIndex must be less than the number of queues created for the specified queue family index when device was created, via the queueCount member of the VkDeviceQueueCreateInfo structure"
VUID-vkGetDeviceQueue2-device-parameter,Y,None,implicit,vkGetDeviceQueue2,(VK_VERSION_1_1), device must be a valid VkDevice handle
VUID-vkGetDeviceQueue2-pQueue-parameter,Y,None,implicit,vkGetDeviceQueue2,(VK_VERSION_1_1), pQueue must be a valid pointer to a VkQueue handle
VUID-vkGetDeviceQueue2-pQueueInfo-parameter,Y,None,implicit,vkGetDeviceQueue2,(VK_VERSION_1_1), pQueueInfo must be a valid pointer to a valid VkDeviceQueueInfo2 structure
VUID-vkGetDisplayModeProperties2KHR-display-parameter,N,None,implicit,vkGetDisplayModeProperties2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), display must be a valid VkDisplayKHR handle
VUID-vkGetDisplayModeProperties2KHR-pProperties-parameter,Y,None,implicit,vkGetDisplayModeProperties2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)," If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayModeProperties2KHR structures"
VUID-vkGetDisplayModeProperties2KHR-pPropertyCount-parameter,N,None,implicit,vkGetDisplayModeProperties2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), pPropertyCount must be a valid pointer to a uint32_t value
VUID-vkGetDisplayModeProperties2KHR-physicalDevice-parameter,N,None,implicit,vkGetDisplayModeProperties2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetDisplayModePropertiesKHR-display-parameter,Y,None,implicit,vkGetDisplayModePropertiesKHR,(VK_KHR_surface)+(VK_KHR_display), display must be a valid VkDisplayKHR handle
VUID-vkGetDisplayModePropertiesKHR-pProperties-parameter,Y,None,implicit,vkGetDisplayModePropertiesKHR,(VK_KHR_surface)+(VK_KHR_display)," If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayModePropertiesKHR structures"
VUID-vkGetDisplayModePropertiesKHR-pPropertyCount-parameter,N,None,implicit,vkGetDisplayModePropertiesKHR,(VK_KHR_surface)+(VK_KHR_display), pPropertyCount must be a valid pointer to a uint32_t value
VUID-vkGetDisplayModePropertiesKHR-physicalDevice-parameter,Y,None,implicit,vkGetDisplayModePropertiesKHR,(VK_KHR_surface)+(VK_KHR_display), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetDisplayPlaneCapabilities2KHR-pCapabilities-parameter,Y,None,implicit,vkGetDisplayPlaneCapabilities2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), pCapabilities must be a valid pointer to a VkDisplayPlaneCapabilities2KHR structure
VUID-vkGetDisplayPlaneCapabilities2KHR-pDisplayPlaneInfo-parameter,Y,None,implicit,vkGetDisplayPlaneCapabilities2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), pDisplayPlaneInfo must be a valid pointer to a valid VkDisplayPlaneInfo2KHR structure
VUID-vkGetDisplayPlaneCapabilities2KHR-physicalDevice-parameter,Y,None,implicit,vkGetDisplayPlaneCapabilities2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetDisplayPlaneCapabilitiesKHR-mode-parameter,Y,None,implicit,vkGetDisplayPlaneCapabilitiesKHR,(VK_KHR_surface)+(VK_KHR_display), mode must be a valid VkDisplayModeKHR handle
VUID-vkGetDisplayPlaneCapabilitiesKHR-pCapabilities-parameter,Y,None,implicit,vkGetDisplayPlaneCapabilitiesKHR,(VK_KHR_surface)+(VK_KHR_display), pCapabilities must be a valid pointer to a VkDisplayPlaneCapabilitiesKHR structure
VUID-vkGetDisplayPlaneCapabilitiesKHR-physicalDevice-parameter,Y,None,implicit,vkGetDisplayPlaneCapabilitiesKHR,(VK_KHR_surface)+(VK_KHR_display), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetDisplayPlaneSupportedDisplaysKHR-pDisplayCount-parameter,N,None,implicit,vkGetDisplayPlaneSupportedDisplaysKHR,(VK_KHR_surface)+(VK_KHR_display), pDisplayCount must be a valid pointer to a uint32_t value
VUID-vkGetDisplayPlaneSupportedDisplaysKHR-pDisplays-parameter,Y,None,implicit,vkGetDisplayPlaneSupportedDisplaysKHR,(VK_KHR_surface)+(VK_KHR_display)," If the value referenced by pDisplayCount is not 0, and pDisplays is not NULL, pDisplays must be a valid pointer to an array of pDisplayCount VkDisplayKHR handles"
VUID-vkGetDisplayPlaneSupportedDisplaysKHR-physicalDevice-parameter,Y,None,implicit,vkGetDisplayPlaneSupportedDisplaysKHR,(VK_KHR_surface)+(VK_KHR_display), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetDisplayPlaneSupportedDisplaysKHR-planeIndex-01249,Y,None,explicit,vkGetDisplayPlaneSupportedDisplaysKHR,(VK_KHR_surface)+(VK_KHR_display), planeIndex must be less than the number of display planes supported by the device as determined by calling vkGetPhysicalDeviceDisplayPlanePropertiesKHR
VUID-vkGetEventStatus-device-parameter,Y,None,implicit,vkGetEventStatus,core, device must be a valid VkDevice handle
VUID-vkGetEventStatus-event-parameter,Y,None,implicit,vkGetEventStatus,core, event must be a valid VkEvent handle
VUID-vkGetEventStatus-event-parent,Y,None,implicit,vkGetEventStatus,core," event must have been created, allocated, or retrieved from device"
VUID-vkGetFenceFdKHR-device-parameter,Y,None,implicit,vkGetFenceFdKHR,(VK_KHR_external_fence_fd), device must be a valid VkDevice handle
VUID-vkGetFenceFdKHR-pFd-parameter,Y,None,implicit,vkGetFenceFdKHR,(VK_KHR_external_fence_fd), pFd must be a valid pointer to a int value
VUID-vkGetFenceFdKHR-pGetFdInfo-parameter,Y,None,implicit,vkGetFenceFdKHR,(VK_KHR_external_fence_fd), pGetFdInfo must be a valid pointer to a valid VkFenceGetFdInfoKHR structure
VUID-vkGetFenceStatus-device-parameter,Y,None,implicit,vkGetFenceStatus,core, device must be a valid VkDevice handle
VUID-vkGetFenceStatus-fence-parameter,Y,None,implicit,vkGetFenceStatus,core, fence must be a valid VkFence handle
VUID-vkGetFenceStatus-fence-parent,Y,None,implicit,vkGetFenceStatus,core," fence must have been created, allocated, or retrieved from device"
VUID-vkGetFenceWin32HandleKHR-device-parameter,Y,None,implicit,vkGetFenceWin32HandleKHR,(VK_KHR_external_fence_win32), device must be a valid VkDevice handle
VUID-vkGetFenceWin32HandleKHR-pGetWin32HandleInfo-parameter,Y,None,implicit,vkGetFenceWin32HandleKHR,(VK_KHR_external_fence_win32), pGetWin32HandleInfo must be a valid pointer to a valid VkFenceGetWin32HandleInfoKHR structure
VUID-vkGetFenceWin32HandleKHR-pHandle-parameter,Y,None,implicit,vkGetFenceWin32HandleKHR,(VK_KHR_external_fence_win32), pHandle must be a valid pointer to a HANDLE value
VUID-vkGetImageMemoryRequirements-device-parameter,Y,None,implicit,vkGetImageMemoryRequirements,core, device must be a valid VkDevice handle
VUID-vkGetImageMemoryRequirements-image-01588,N,None,explicit,vkGetImageMemoryRequirements,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)", image must not have been created with the VK_IMAGE_CREATE_DISJOINT_BIT flag set
VUID-vkGetImageMemoryRequirements-image-parameter,Y,CreateUnknownObject,implicit,vkGetImageMemoryRequirements,core, image must be a valid VkImage handle
VUID-vkGetImageMemoryRequirements-image-parent,Y,None,implicit,vkGetImageMemoryRequirements,core," image must have been created, allocated, or retrieved from device"
VUID-vkGetImageMemoryRequirements-pMemoryRequirements-parameter,Y,None,implicit,vkGetImageMemoryRequirements,core, pMemoryRequirements must be a valid pointer to a VkMemoryRequirements structure
VUID-vkGetImageMemoryRequirements2-device-parameter,Y,None,implicit,vkGetImageMemoryRequirements2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", device must be a valid VkDevice handle
VUID-vkGetImageMemoryRequirements2-pInfo-parameter,Y,None,implicit,vkGetImageMemoryRequirements2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", pInfo must be a valid pointer to a valid VkImageMemoryRequirementsInfo2 structure
VUID-vkGetImageMemoryRequirements2-pMemoryRequirements-parameter,Y,None,implicit,vkGetImageMemoryRequirements2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", pMemoryRequirements must be a valid pointer to a VkMemoryRequirements2 structure
VUID-vkGetImageSparseMemoryRequirements-device-parameter,Y,None,implicit,vkGetImageSparseMemoryRequirements,core, device must be a valid VkDevice handle
VUID-vkGetImageSparseMemoryRequirements-image-parameter,Y,None,implicit,vkGetImageSparseMemoryRequirements,core, image must be a valid VkImage handle
VUID-vkGetImageSparseMemoryRequirements-image-parent,Y,None,implicit,vkGetImageSparseMemoryRequirements,core," image must have been created, allocated, or retrieved from device"
VUID-vkGetImageSparseMemoryRequirements-pSparseMemoryRequirementCount-parameter,N,None,implicit,vkGetImageSparseMemoryRequirements,core, pSparseMemoryRequirementCount must be a valid pointer to a uint32_t value
VUID-vkGetImageSparseMemoryRequirements-pSparseMemoryRequirements-parameter,Y,None,implicit,vkGetImageSparseMemoryRequirements,core," If the value referenced by pSparseMemoryRequirementCount is not 0, and pSparseMemoryRequirements is not NULL, pSparseMemoryRequirements must be a valid pointer to an array of pSparseMemoryRequirementCount VkSparseImageMemoryRequirements structures"
VUID-vkGetImageSparseMemoryRequirements2-device-parameter,Y,None,implicit,vkGetImageSparseMemoryRequirements2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", device must be a valid VkDevice handle
VUID-vkGetImageSparseMemoryRequirements2-pInfo-parameter,Y,None,implicit,vkGetImageSparseMemoryRequirements2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", pInfo must be a valid pointer to a valid VkImageSparseMemoryRequirementsInfo2 structure
VUID-vkGetImageSparseMemoryRequirements2-pSparseMemoryRequirementCount-parameter,N,None,implicit,vkGetImageSparseMemoryRequirements2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)", pSparseMemoryRequirementCount must be a valid pointer to a uint32_t value
VUID-vkGetImageSparseMemoryRequirements2-pSparseMemoryRequirements-parameter,Y,None,implicit,vkGetImageSparseMemoryRequirements2,"(VK_VERSION_1_1,VK_KHR_get_memory_requirements2)"," If the value referenced by pSparseMemoryRequirementCount is not 0, and pSparseMemoryRequirements is not NULL, pSparseMemoryRequirements must be a valid pointer to an array of pSparseMemoryRequirementCount VkSparseImageMemoryRequirements2 structures"
VUID-vkGetImageSubresourceLayout-arrayLayer-01717,Y,ExerciseGetImageSubresourceLayout,explicit,vkGetImageSubresourceLayout,core, The arrayLayer member of pSubresource must be less than the arrayLayers specified in VkImageCreateInfo when image was created
VUID-vkGetImageSubresourceLayout-aspectMask-00997,Y,ExerciseGetImageSubresourceLayout,explicit,vkGetImageSubresourceLayout,core, The aspectMask member of pSubresource must only have a single bit set
VUID-vkGetImageSubresourceLayout-device-parameter,Y,None,implicit,vkGetImageSubresourceLayout,core, device must be a valid VkDevice handle
VUID-vkGetImageSubresourceLayout-format-01581,Y,MultiplaneImageLayoutBadAspectFlags,explicit,vkGetImageSubresourceLayout,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the format of image is a multi-planar format with two planes, the aspectMask member of pSubresource must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT"
VUID-vkGetImageSubresourceLayout-format-01582,Y,MultiplaneImageLayoutBadAspectFlags,explicit,vkGetImageSubresourceLayout,"(VK_VERSION_1_1,VK_KHR_sampler_ycbcr_conversion)"," If the format of image is a multi-planar format with three planes, the aspectMask member of pSubresource must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT or VK_IMAGE_ASPECT_PLANE_2_BIT"
VUID-vkGetImageSubresourceLayout-image-00996,Y,ExerciseGetImageSubresourceLayout,explicit,vkGetImageSubresourceLayout,core, image must have been created with tiling equal to VK_IMAGE_TILING_LINEAR
VUID-vkGetImageSubresourceLayout-image-01895,N,None,explicit,vkGetImageSubresourceLayout,(VK_ANDROID_external_memory_android_hardware_buffer)," If image was created with the VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID external memory handle type, then image must be bound to memory."
VUID-vkGetImageSubresourceLayout-image-parameter,Y,None,implicit,vkGetImageSubresourceLayout,core, image must be a valid VkImage handle
VUID-vkGetImageSubresourceLayout-image-parent,Y,None,implicit,vkGetImageSubresourceLayout,core," image must have been created, allocated, or retrieved from device"
VUID-vkGetImageSubresourceLayout-mipLevel-01716,Y,ExerciseGetImageSubresourceLayout,explicit,vkGetImageSubresourceLayout,core, The mipLevel member of pSubresource must be less than the mipLevels specified in VkImageCreateInfo when image was created
VUID-vkGetImageSubresourceLayout-pLayout-parameter,Y,None,implicit,vkGetImageSubresourceLayout,core, pLayout must be a valid pointer to a VkSubresourceLayout structure
VUID-vkGetImageSubresourceLayout-pSubresource-parameter,Y,None,implicit,vkGetImageSubresourceLayout,core, pSubresource must be a valid pointer to a valid VkImageSubresource structure
VUID-vkGetInstanceProcAddr-instance-parameter,N,None,implicit,vkGetInstanceProcAddr,core," If instance is not NULL, instance must be a valid VkInstance handle"
VUID-vkGetInstanceProcAddr-pName-parameter,N,None,implicit,vkGetInstanceProcAddr,core, pName must be a null-terminated UTF-8 string
VUID-vkGetMemoryAndroidHardwareBufferANDROID-device-parameter,Y,None,implicit,vkGetMemoryAndroidHardwareBufferANDROID,(VK_ANDROID_external_memory_android_hardware_buffer), device must be a valid VkDevice handle
VUID-vkGetMemoryAndroidHardwareBufferANDROID-pBuffer-parameter,Y,None,implicit,vkGetMemoryAndroidHardwareBufferANDROID,(VK_ANDROID_external_memory_android_hardware_buffer), pBuffer must be a valid pointer to a valid pointer to a AHardwareBuffer value
VUID-vkGetMemoryAndroidHardwareBufferANDROID-pInfo-parameter,Y,None,implicit,vkGetMemoryAndroidHardwareBufferANDROID,(VK_ANDROID_external_memory_android_hardware_buffer), pInfo must be a valid pointer to a valid VkMemoryGetAndroidHardwareBufferInfoANDROID structure
VUID-vkGetMemoryFdKHR-device-parameter,Y,None,implicit,vkGetMemoryFdKHR,(VK_KHR_external_memory_fd), device must be a valid VkDevice handle
VUID-vkGetMemoryFdKHR-pFd-parameter,Y,None,implicit,vkGetMemoryFdKHR,(VK_KHR_external_memory_fd), pFd must be a valid pointer to a int value
VUID-vkGetMemoryFdKHR-pGetFdInfo-parameter,Y,None,implicit,vkGetMemoryFdKHR,(VK_KHR_external_memory_fd), pGetFdInfo must be a valid pointer to a valid VkMemoryGetFdInfoKHR structure
VUID-vkGetMemoryFdPropertiesKHR-device-parameter,Y,None,implicit,vkGetMemoryFdPropertiesKHR,(VK_KHR_external_memory_fd), device must be a valid VkDevice handle
VUID-vkGetMemoryFdPropertiesKHR-fd-00673,N,None,explicit,vkGetMemoryFdPropertiesKHR,(VK_KHR_external_memory_fd), fd must be an external memory handle created outside of the Vulkan API.
VUID-vkGetMemoryFdPropertiesKHR-handleType-00674,N,None,explicit,vkGetMemoryFdPropertiesKHR,(VK_KHR_external_memory_fd), handleType must not be VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR.
VUID-vkGetMemoryFdPropertiesKHR-handleType-parameter,Y,None,implicit,vkGetMemoryFdPropertiesKHR,(VK_KHR_external_memory_fd), handleType must be a valid VkExternalMemoryHandleTypeFlagBits value
VUID-vkGetMemoryFdPropertiesKHR-pMemoryFdProperties-parameter,Y,None,implicit,vkGetMemoryFdPropertiesKHR,(VK_KHR_external_memory_fd), pMemoryFdProperties must be a valid pointer to a VkMemoryFdPropertiesKHR structure
VUID-vkGetMemoryHostPointerPropertiesEXT-device-parameter,Y,None,implicit,vkGetMemoryHostPointerPropertiesEXT,(VK_EXT_external_memory_host), device must be a valid VkDevice handle
VUID-vkGetMemoryHostPointerPropertiesEXT-handleType-01752,N,None,explicit,vkGetMemoryHostPointerPropertiesEXT,(VK_EXT_external_memory_host), handleType must be VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT
VUID-vkGetMemoryHostPointerPropertiesEXT-handleType-01754,N,None,explicit,vkGetMemoryHostPointerPropertiesEXT,(VK_EXT_external_memory_host)," If handleType is VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT, pHostPointer must be a pointer to host memory"
VUID-vkGetMemoryHostPointerPropertiesEXT-handleType-01755,N,None,explicit,vkGetMemoryHostPointerPropertiesEXT,(VK_EXT_external_memory_host)," If handleType is VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT, pHostPointer must be a pointer to host mapped foreign memory"
VUID-vkGetMemoryHostPointerPropertiesEXT-handleType-parameter,Y,None,implicit,vkGetMemoryHostPointerPropertiesEXT,(VK_EXT_external_memory_host), handleType must be a valid VkExternalMemoryHandleTypeFlagBits value
VUID-vkGetMemoryHostPointerPropertiesEXT-pHostPointer-01753,N,None,explicit,vkGetMemoryHostPointerPropertiesEXT,(VK_EXT_external_memory_host), pHostPointer must be a pointer aligned to an integer multiple of VkPhysicalDeviceExternalMemoryHostPropertiesEXT::minImportedHostPointerAlignment
VUID-vkGetMemoryHostPointerPropertiesEXT-pMemoryHostPointerProperties-parameter,Y,None,implicit,vkGetMemoryHostPointerPropertiesEXT,(VK_EXT_external_memory_host), pMemoryHostPointerProperties must be a valid pointer to a VkMemoryHostPointerPropertiesEXT structure
VUID-vkGetMemoryWin32HandleKHR-device-parameter,Y,None,implicit,vkGetMemoryWin32HandleKHR,(VK_KHR_external_memory_win32), device must be a valid VkDevice handle
VUID-vkGetMemoryWin32HandleKHR-pGetWin32HandleInfo-parameter,Y,None,implicit,vkGetMemoryWin32HandleKHR,(VK_KHR_external_memory_win32), pGetWin32HandleInfo must be a valid pointer to a valid VkMemoryGetWin32HandleInfoKHR structure
VUID-vkGetMemoryWin32HandleKHR-pHandle-parameter,Y,None,implicit,vkGetMemoryWin32HandleKHR,(VK_KHR_external_memory_win32), pHandle must be a valid pointer to a HANDLE value
VUID-vkGetMemoryWin32HandleNV-device-parameter,Y,None,implicit,vkGetMemoryWin32HandleNV,(VK_NV_external_memory_win32), device must be a valid VkDevice handle
VUID-vkGetMemoryWin32HandleNV-handleType-01326,N,None,explicit,vkGetMemoryWin32HandleNV,(VK_NV_external_memory_win32), handleType must be a flag specified in VkExportMemoryAllocateInfoNV::handleTypes when allocating memory
VUID-vkGetMemoryWin32HandleNV-handleType-parameter,N,None,implicit,vkGetMemoryWin32HandleNV,(VK_NV_external_memory_win32), handleType must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values
VUID-vkGetMemoryWin32HandleNV-handleType-requiredbitmask,Y,None,implicit,vkGetMemoryWin32HandleNV,(VK_NV_external_memory_win32), handleType must not be 0
VUID-vkGetMemoryWin32HandleNV-memory-parameter,Y,None,implicit,vkGetMemoryWin32HandleNV,(VK_NV_external_memory_win32), memory must be a valid VkDeviceMemory handle
VUID-vkGetMemoryWin32HandleNV-memory-parent,Y,None,implicit,vkGetMemoryWin32HandleNV,(VK_NV_external_memory_win32)," memory must have been created, allocated, or retrieved from device"
VUID-vkGetMemoryWin32HandleNV-pHandle-parameter,Y,None,implicit,vkGetMemoryWin32HandleNV,(VK_NV_external_memory_win32), pHandle must be a valid pointer to a HANDLE value
VUID-vkGetMemoryWin32HandlePropertiesKHR-device-parameter,Y,None,implicit,vkGetMemoryWin32HandlePropertiesKHR,(VK_KHR_external_memory_win32), device must be a valid VkDevice handle
VUID-vkGetMemoryWin32HandlePropertiesKHR-handle-00665,N,None,explicit,vkGetMemoryWin32HandlePropertiesKHR,(VK_KHR_external_memory_win32), handle must be an external memory handle created outside of the Vulkan API.
VUID-vkGetMemoryWin32HandlePropertiesKHR-handleType-00666,N,None,explicit,vkGetMemoryWin32HandlePropertiesKHR,(VK_KHR_external_memory_win32), handleType must not be one of the handle types defined as opaque.
VUID-vkGetMemoryWin32HandlePropertiesKHR-handleType-parameter,Y,None,implicit,vkGetMemoryWin32HandlePropertiesKHR,(VK_KHR_external_memory_win32), handleType must be a valid VkExternalMemoryHandleTypeFlagBits value
VUID-vkGetMemoryWin32HandlePropertiesKHR-pMemoryWin32HandleProperties-parameter,Y,None,implicit,vkGetMemoryWin32HandlePropertiesKHR,(VK_KHR_external_memory_win32), pMemoryWin32HandleProperties must be a valid pointer to a VkMemoryWin32HandlePropertiesKHR structure
VUID-vkGetPastPresentationTimingGOOGLE-commonparent,Y,None,implicit,vkGetPastPresentationTimingGOOGLE,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing)," Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance"
VUID-vkGetPastPresentationTimingGOOGLE-device-parameter,Y,None,implicit,vkGetPastPresentationTimingGOOGLE,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing), device must be a valid VkDevice handle
VUID-vkGetPastPresentationTimingGOOGLE-pPresentationTimingCount-parameter,N,None,implicit,vkGetPastPresentationTimingGOOGLE,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing), pPresentationTimingCount must be a valid pointer to a uint32_t value
VUID-vkGetPastPresentationTimingGOOGLE-pPresentationTimings-parameter,Y,None,implicit,vkGetPastPresentationTimingGOOGLE,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing)," If the value referenced by pPresentationTimingCount is not 0, and pPresentationTimings is not NULL, pPresentationTimings must be a valid pointer to an array of pPresentationTimingCount VkPastPresentationTimingGOOGLE structures"
VUID-vkGetPastPresentationTimingGOOGLE-swapchain-parameter,Y,None,implicit,vkGetPastPresentationTimingGOOGLE,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing), swapchain must be a valid VkSwapchainKHR handle
VUID-vkGetPhysicalDeviceDisplayPlaneProperties2KHR-pProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceDisplayPlaneProperties2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)," If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayPlaneProperties2KHR structures"
VUID-vkGetPhysicalDeviceDisplayPlaneProperties2KHR-pPropertyCount-parameter,N,None,implicit,vkGetPhysicalDeviceDisplayPlaneProperties2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), pPropertyCount must be a valid pointer to a uint32_t value
VUID-vkGetPhysicalDeviceDisplayPlaneProperties2KHR-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceDisplayPlaneProperties2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceDisplayPlanePropertiesKHR-pProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceDisplayPlanePropertiesKHR,(VK_KHR_surface)+(VK_KHR_display)," If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayPlanePropertiesKHR structures"
VUID-vkGetPhysicalDeviceDisplayPlanePropertiesKHR-pPropertyCount-parameter,N,None,implicit,vkGetPhysicalDeviceDisplayPlanePropertiesKHR,(VK_KHR_surface)+(VK_KHR_display), pPropertyCount must be a valid pointer to a uint32_t value
VUID-vkGetPhysicalDeviceDisplayPlanePropertiesKHR-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceDisplayPlanePropertiesKHR,(VK_KHR_surface)+(VK_KHR_display), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceDisplayProperties2KHR-pProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceDisplayProperties2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2)," If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayProperties2KHR structures"
VUID-vkGetPhysicalDeviceDisplayProperties2KHR-pPropertyCount-parameter,N,None,implicit,vkGetPhysicalDeviceDisplayProperties2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), pPropertyCount must be a valid pointer to a uint32_t value
VUID-vkGetPhysicalDeviceDisplayProperties2KHR-physicalDevice-parameter,N,None,implicit,vkGetPhysicalDeviceDisplayProperties2KHR,(VK_KHR_surface)+(VK_KHR_display)+(VK_KHR_get_display_properties2), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceDisplayPropertiesKHR-pProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceDisplayPropertiesKHR,(VK_KHR_surface)+(VK_KHR_display)," If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayPropertiesKHR structures"
VUID-vkGetPhysicalDeviceDisplayPropertiesKHR-pPropertyCount-parameter,N,None,implicit,vkGetPhysicalDeviceDisplayPropertiesKHR,(VK_KHR_surface)+(VK_KHR_display), pPropertyCount must be a valid pointer to a uint32_t value
VUID-vkGetPhysicalDeviceDisplayPropertiesKHR-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceDisplayPropertiesKHR,(VK_KHR_surface)+(VK_KHR_display), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceExternalBufferProperties-pExternalBufferInfo-parameter,Y,None,implicit,vkGetPhysicalDeviceExternalBufferProperties,"(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)", pExternalBufferInfo must be a valid pointer to a valid VkPhysicalDeviceExternalBufferInfo structure
VUID-vkGetPhysicalDeviceExternalBufferProperties-pExternalBufferProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceExternalBufferProperties,"(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)", pExternalBufferProperties must be a valid pointer to a VkExternalBufferProperties structure
VUID-vkGetPhysicalDeviceExternalBufferProperties-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceExternalBufferProperties,"(VK_VERSION_1_1,VK_KHR_external_memory_capabilities)", physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceExternalFenceProperties-pExternalFenceInfo-parameter,Y,None,implicit,vkGetPhysicalDeviceExternalFenceProperties,"(VK_VERSION_1_1,VK_KHR_external_fence_capabilities)", pExternalFenceInfo must be a valid pointer to a valid VkPhysicalDeviceExternalFenceInfo structure
VUID-vkGetPhysicalDeviceExternalFenceProperties-pExternalFenceProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceExternalFenceProperties,"(VK_VERSION_1_1,VK_KHR_external_fence_capabilities)", pExternalFenceProperties must be a valid pointer to a VkExternalFenceProperties structure
VUID-vkGetPhysicalDeviceExternalFenceProperties-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceExternalFenceProperties,"(VK_VERSION_1_1,VK_KHR_external_fence_capabilities)", physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-externalHandleType-parameter,Y,None,implicit,vkGetPhysicalDeviceExternalImageFormatPropertiesNV,(VK_NV_external_memory_capabilities), externalHandleType must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values
VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-flags-parameter,Y,None,implicit,vkGetPhysicalDeviceExternalImageFormatPropertiesNV,(VK_NV_external_memory_capabilities), flags must be a valid combination of VkImageCreateFlagBits values
VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-format-parameter,Y,None,implicit,vkGetPhysicalDeviceExternalImageFormatPropertiesNV,(VK_NV_external_memory_capabilities), format must be a valid VkFormat value
VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-pExternalImageFormatProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceExternalImageFormatPropertiesNV,(VK_NV_external_memory_capabilities), pExternalImageFormatProperties must be a valid pointer to a VkExternalImageFormatPropertiesNV structure
VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceExternalImageFormatPropertiesNV,(VK_NV_external_memory_capabilities), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-tiling-parameter,Y,None,implicit,vkGetPhysicalDeviceExternalImageFormatPropertiesNV,(VK_NV_external_memory_capabilities), tiling must be a valid VkImageTiling value
VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-type-parameter,Y,None,implicit,vkGetPhysicalDeviceExternalImageFormatPropertiesNV,(VK_NV_external_memory_capabilities), type must be a valid VkImageType value
VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-usage-parameter,N,None,implicit,vkGetPhysicalDeviceExternalImageFormatPropertiesNV,(VK_NV_external_memory_capabilities), usage must be a valid combination of VkImageUsageFlagBits values
VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-usage-requiredbitmask,Y,None,implicit,vkGetPhysicalDeviceExternalImageFormatPropertiesNV,(VK_NV_external_memory_capabilities), usage must not be 0
VUID-vkGetPhysicalDeviceExternalSemaphoreProperties-pExternalSemaphoreInfo-parameter,Y,None,implicit,vkGetPhysicalDeviceExternalSemaphoreProperties,"(VK_VERSION_1_1,VK_KHR_external_semaphore_capabilities)", pExternalSemaphoreInfo must be a valid pointer to a valid VkPhysicalDeviceExternalSemaphoreInfo structure
VUID-vkGetPhysicalDeviceExternalSemaphoreProperties-pExternalSemaphoreProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceExternalSemaphoreProperties,"(VK_VERSION_1_1,VK_KHR_external_semaphore_capabilities)", pExternalSemaphoreProperties must be a valid pointer to a VkExternalSemaphoreProperties structure
VUID-vkGetPhysicalDeviceExternalSemaphoreProperties-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceExternalSemaphoreProperties,"(VK_VERSION_1_1,VK_KHR_external_semaphore_capabilities)", physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceFeatures-pFeatures-parameter,Y,None,implicit,vkGetPhysicalDeviceFeatures,core, pFeatures must be a valid pointer to a VkPhysicalDeviceFeatures structure
VUID-vkGetPhysicalDeviceFeatures-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceFeatures,core, physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceFeatures2-pFeatures-parameter,Y,None,implicit,vkGetPhysicalDeviceFeatures2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", pFeatures must be a valid pointer to a VkPhysicalDeviceFeatures2 structure
VUID-vkGetPhysicalDeviceFeatures2-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceFeatures2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceFormatProperties-format-parameter,Y,None,implicit,vkGetPhysicalDeviceFormatProperties,core, format must be a valid VkFormat value
VUID-vkGetPhysicalDeviceFormatProperties-pFormatProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceFormatProperties,core, pFormatProperties must be a valid pointer to a VkFormatProperties structure
VUID-vkGetPhysicalDeviceFormatProperties-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceFormatProperties,core, physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceFormatProperties2-format-parameter,Y,None,implicit,vkGetPhysicalDeviceFormatProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", format must be a valid VkFormat value
VUID-vkGetPhysicalDeviceFormatProperties2-pFormatProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceFormatProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", pFormatProperties must be a valid pointer to a VkFormatProperties2 structure
VUID-vkGetPhysicalDeviceFormatProperties2-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceFormatProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX-pFeatures-parameter,Y,None,implicit,vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX,(VK_NVX_device_generated_commands), pFeatures must be a valid pointer to a VkDeviceGeneratedCommandsFeaturesNVX structure
VUID-vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX-pLimits-parameter,Y,None,implicit,vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX,(VK_NVX_device_generated_commands), pLimits must be a valid pointer to a VkDeviceGeneratedCommandsLimitsNVX structure
VUID-vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX,(VK_NVX_device_generated_commands), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceImageFormatProperties-flags-parameter,Y,None,implicit,vkGetPhysicalDeviceImageFormatProperties,core, flags must be a valid combination of VkImageCreateFlagBits values
VUID-vkGetPhysicalDeviceImageFormatProperties-format-parameter,Y,None,implicit,vkGetPhysicalDeviceImageFormatProperties,core, format must be a valid VkFormat value
VUID-vkGetPhysicalDeviceImageFormatProperties-pImageFormatProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceImageFormatProperties,core, pImageFormatProperties must be a valid pointer to a VkImageFormatProperties structure
VUID-vkGetPhysicalDeviceImageFormatProperties-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceImageFormatProperties,core, physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceImageFormatProperties-tiling-parameter,Y,None,implicit,vkGetPhysicalDeviceImageFormatProperties,core, tiling must be a valid VkImageTiling value
VUID-vkGetPhysicalDeviceImageFormatProperties-type-parameter,Y,None,implicit,vkGetPhysicalDeviceImageFormatProperties,core, type must be a valid VkImageType value
VUID-vkGetPhysicalDeviceImageFormatProperties-usage-parameter,N,None,implicit,vkGetPhysicalDeviceImageFormatProperties,core, usage must be a valid combination of VkImageUsageFlagBits values
VUID-vkGetPhysicalDeviceImageFormatProperties-usage-requiredbitmask,Y,None,implicit,vkGetPhysicalDeviceImageFormatProperties,core, usage must not be 0
VUID-vkGetPhysicalDeviceImageFormatProperties2-pImageFormatInfo-parameter,Y,None,implicit,vkGetPhysicalDeviceImageFormatProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", pImageFormatInfo must be a valid pointer to a valid VkPhysicalDeviceImageFormatInfo2 structure
VUID-vkGetPhysicalDeviceImageFormatProperties2-pImageFormatProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceImageFormatProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", pImageFormatProperties must be a valid pointer to a VkImageFormatProperties2 structure
VUID-vkGetPhysicalDeviceImageFormatProperties2-pNext-01868,N,None,explicit,vkGetPhysicalDeviceImageFormatProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)+(VK_ANDROID_external_memory_android_hardware_buffer)"," If the pNext chain of pImageFormatProperties contains an instance of VkAndroidHardwareBufferUsageANDROID, the pNext chain of pImageFormatInfo must contain an instance of VkPhysicalDeviceExternalImageFormatInfo with handleType set to VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID."
VUID-vkGetPhysicalDeviceImageFormatProperties2-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceImageFormatProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceMemoryProperties-pMemoryProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceMemoryProperties,core, pMemoryProperties must be a valid pointer to a VkPhysicalDeviceMemoryProperties structure
VUID-vkGetPhysicalDeviceMemoryProperties-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceMemoryProperties,core, physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceMemoryProperties2-pMemoryProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceMemoryProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", pMemoryProperties must be a valid pointer to a VkPhysicalDeviceMemoryProperties2 structure
VUID-vkGetPhysicalDeviceMemoryProperties2-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceMemoryProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceMirPresentationSupportKHR-connection-parameter,Y,None,implicit,vkGetPhysicalDeviceMirPresentationSupportKHR,(VK_KHR_surface)+(VK_KHR_mir_surface), connection must be a valid pointer to a MirConnection value
VUID-vkGetPhysicalDeviceMirPresentationSupportKHR-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceMirPresentationSupportKHR,(VK_KHR_surface)+(VK_KHR_mir_surface), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceMirPresentationSupportKHR-queueFamilyIndex-01265,Y,None,explicit,vkGetPhysicalDeviceMirPresentationSupportKHR,(VK_KHR_surface)+(VK_KHR_mir_surface), queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice
VUID-vkGetPhysicalDeviceMultisamplePropertiesEXT-pMultisampleProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceMultisamplePropertiesEXT,(VK_EXT_sample_locations), pMultisampleProperties must be a valid pointer to a VkMultisamplePropertiesEXT structure
VUID-vkGetPhysicalDeviceMultisamplePropertiesEXT-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceMultisamplePropertiesEXT,(VK_EXT_sample_locations), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceMultisamplePropertiesEXT-samples-parameter,Y,None,implicit,vkGetPhysicalDeviceMultisamplePropertiesEXT,(VK_EXT_sample_locations), samples must be a valid VkSampleCountFlagBits value
VUID-vkGetPhysicalDevicePresentRectanglesKHR-commonparent,Y,None,implicit,vkGetPhysicalDevicePresentRectanglesKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)"," Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance"
VUID-vkGetPhysicalDevicePresentRectanglesKHR-pRectCount-parameter,N,None,implicit,vkGetPhysicalDevicePresentRectanglesKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", pRectCount must be a valid pointer to a uint32_t value
VUID-vkGetPhysicalDevicePresentRectanglesKHR-pRects-parameter,Y,None,implicit,vkGetPhysicalDevicePresentRectanglesKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)"," If the value referenced by pRectCount is not 0, and pRects is not NULL, pRects must be a valid pointer to an array of pRectCount VkRect2D structures"
VUID-vkGetPhysicalDevicePresentRectanglesKHR-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDevicePresentRectanglesKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDevicePresentRectanglesKHR-surface-parameter,Y,None,implicit,vkGetPhysicalDevicePresentRectanglesKHR,"(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_VERSION_1_1,VK_KHR_device_group)", surface must be a valid VkSurfaceKHR handle
VUID-vkGetPhysicalDeviceProperties-pProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceProperties,core, pProperties must be a valid pointer to a VkPhysicalDeviceProperties structure
VUID-vkGetPhysicalDeviceProperties-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceProperties,core, physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceProperties2-pProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", pProperties must be a valid pointer to a VkPhysicalDeviceProperties2 structure
VUID-vkGetPhysicalDeviceProperties2-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceQueueFamilyProperties-pQueueFamilyProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceQueueFamilyProperties,core," If the value referenced by pQueueFamilyPropertyCount is not 0, and pQueueFamilyProperties is not NULL, pQueueFamilyProperties must be a valid pointer to an array of pQueueFamilyPropertyCount VkQueueFamilyProperties structures"
VUID-vkGetPhysicalDeviceQueueFamilyProperties-pQueueFamilyPropertyCount-parameter,N,None,implicit,vkGetPhysicalDeviceQueueFamilyProperties,core, pQueueFamilyPropertyCount must be a valid pointer to a uint32_t value
VUID-vkGetPhysicalDeviceQueueFamilyProperties-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceQueueFamilyProperties,core, physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceQueueFamilyProperties2-pQueueFamilyProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceQueueFamilyProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)"," If the value referenced by pQueueFamilyPropertyCount is not 0, and pQueueFamilyProperties is not NULL, pQueueFamilyProperties must be a valid pointer to an array of pQueueFamilyPropertyCount VkQueueFamilyProperties2 structures"
VUID-vkGetPhysicalDeviceQueueFamilyProperties2-pQueueFamilyPropertyCount-parameter,N,None,implicit,vkGetPhysicalDeviceQueueFamilyProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", pQueueFamilyPropertyCount must be a valid pointer to a uint32_t value
VUID-vkGetPhysicalDeviceQueueFamilyProperties2-physicalDevice-parameter,N,None,implicit,vkGetPhysicalDeviceQueueFamilyProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceSparseImageFormatProperties-format-parameter,Y,None,implicit,vkGetPhysicalDeviceSparseImageFormatProperties,core, format must be a valid VkFormat value
VUID-vkGetPhysicalDeviceSparseImageFormatProperties-pProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceSparseImageFormatProperties,core," If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkSparseImageFormatProperties structures"
VUID-vkGetPhysicalDeviceSparseImageFormatProperties-pPropertyCount-parameter,N,None,implicit,vkGetPhysicalDeviceSparseImageFormatProperties,core, pPropertyCount must be a valid pointer to a uint32_t value
VUID-vkGetPhysicalDeviceSparseImageFormatProperties-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceSparseImageFormatProperties,core, physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceSparseImageFormatProperties-samples-01094,N,None,explicit,vkGetPhysicalDeviceSparseImageFormatProperties,core," samples must be a bit value that is set in VkImageFormatProperties::sampleCounts returned by vkGetPhysicalDeviceImageFormatProperties with format, type, tiling, and usage equal to those in this command and flags equal to the value that is set in VkImageCreateInfo::flags when the image is created"
VUID-vkGetPhysicalDeviceSparseImageFormatProperties-samples-parameter,Y,None,implicit,vkGetPhysicalDeviceSparseImageFormatProperties,core, samples must be a valid VkSampleCountFlagBits value
VUID-vkGetPhysicalDeviceSparseImageFormatProperties-tiling-parameter,Y,None,implicit,vkGetPhysicalDeviceSparseImageFormatProperties,core, tiling must be a valid VkImageTiling value
VUID-vkGetPhysicalDeviceSparseImageFormatProperties-type-parameter,Y,None,implicit,vkGetPhysicalDeviceSparseImageFormatProperties,core, type must be a valid VkImageType value
VUID-vkGetPhysicalDeviceSparseImageFormatProperties-usage-parameter,N,None,implicit,vkGetPhysicalDeviceSparseImageFormatProperties,core, usage must be a valid combination of VkImageUsageFlagBits values
VUID-vkGetPhysicalDeviceSparseImageFormatProperties-usage-requiredbitmask,Y,None,implicit,vkGetPhysicalDeviceSparseImageFormatProperties,core, usage must not be 0
VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-pFormatInfo-parameter,Y,None,implicit,vkGetPhysicalDeviceSparseImageFormatProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", pFormatInfo must be a valid pointer to a valid VkPhysicalDeviceSparseImageFormatInfo2 structure
VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-pProperties-parameter,Y,None,implicit,vkGetPhysicalDeviceSparseImageFormatProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)"," If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkSparseImageFormatProperties2 structures"
VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-pPropertyCount-parameter,N,None,implicit,vkGetPhysicalDeviceSparseImageFormatProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", pPropertyCount must be a valid pointer to a uint32_t value
VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceSparseImageFormatProperties2,"(VK_VERSION_1_1,VK_KHR_get_physical_device_properties2)", physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-commonparent,Y,None,implicit,vkGetPhysicalDeviceSurfaceCapabilities2EXT,(VK_KHR_surface)+(VK_EXT_display_surface_counter)," Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance"
VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-pSurfaceCapabilities-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfaceCapabilities2EXT,(VK_KHR_surface)+(VK_EXT_display_surface_counter), pSurfaceCapabilities must be a valid pointer to a VkSurfaceCapabilities2EXT structure
VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfaceCapabilities2EXT,(VK_KHR_surface)+(VK_EXT_display_surface_counter), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-surface-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfaceCapabilities2EXT,(VK_KHR_surface)+(VK_EXT_display_surface_counter), surface must be a valid VkSurfaceKHR handle
VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pSurfaceCapabilities-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfaceCapabilities2KHR,(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2), pSurfaceCapabilities must be a valid pointer to a VkSurfaceCapabilities2KHR structure
VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pSurfaceInfo-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfaceCapabilities2KHR,(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2), pSurfaceInfo must be a valid pointer to a valid VkPhysicalDeviceSurfaceInfo2KHR structure
VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfaceCapabilities2KHR,(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-commonparent,Y,None,implicit,vkGetPhysicalDeviceSurfaceCapabilitiesKHR,(VK_KHR_surface)," Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance"
VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-pSurfaceCapabilities-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfaceCapabilitiesKHR,(VK_KHR_surface), pSurfaceCapabilities must be a valid pointer to a VkSurfaceCapabilitiesKHR structure
VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfaceCapabilitiesKHR,(VK_KHR_surface), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-surface-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfaceCapabilitiesKHR,(VK_KHR_surface), surface must be a valid VkSurfaceKHR handle
VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceFormatCount-parameter,N,None,implicit,vkGetPhysicalDeviceSurfaceFormats2KHR,(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2), pSurfaceFormatCount must be a valid pointer to a uint32_t value
VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceFormats-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfaceFormats2KHR,(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2)," If the value referenced by pSurfaceFormatCount is not 0, and pSurfaceFormats is not NULL, pSurfaceFormats must be a valid pointer to an array of pSurfaceFormatCount VkSurfaceFormat2KHR structures"
VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceInfo-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfaceFormats2KHR,(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2), pSurfaceInfo must be a valid pointer to a valid VkPhysicalDeviceSurfaceInfo2KHR structure
VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfaceFormats2KHR,(VK_KHR_surface)+(VK_KHR_get_surface_capabilities2), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-commonparent,Y,None,implicit,vkGetPhysicalDeviceSurfaceFormatsKHR,(VK_KHR_surface)," Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance"
VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-pSurfaceFormatCount-parameter,N,None,implicit,vkGetPhysicalDeviceSurfaceFormatsKHR,(VK_KHR_surface), pSurfaceFormatCount must be a valid pointer to a uint32_t value
VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-pSurfaceFormats-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfaceFormatsKHR,(VK_KHR_surface)," If the value referenced by pSurfaceFormatCount is not 0, and pSurfaceFormats is not NULL, pSurfaceFormats must be a valid pointer to an array of pSurfaceFormatCount VkSurfaceFormatKHR structures"
VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfaceFormatsKHR,(VK_KHR_surface), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-surface-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfaceFormatsKHR,(VK_KHR_surface), surface must be a valid VkSurfaceKHR handle
VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-commonparent,Y,None,implicit,vkGetPhysicalDeviceSurfacePresentModesKHR,(VK_KHR_surface)," Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance"
VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-pPresentModeCount-parameter,N,None,implicit,vkGetPhysicalDeviceSurfacePresentModesKHR,(VK_KHR_surface), pPresentModeCount must be a valid pointer to a uint32_t value
VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-pPresentModes-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfacePresentModesKHR,(VK_KHR_surface)," If the value referenced by pPresentModeCount is not 0, and pPresentModes is not NULL, pPresentModes must be a valid pointer to an array of pPresentModeCount VkPresentModeKHR values"
VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfacePresentModesKHR,(VK_KHR_surface), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-surface-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfacePresentModesKHR,(VK_KHR_surface), surface must be a valid VkSurfaceKHR handle
VUID-vkGetPhysicalDeviceSurfaceSupportKHR-commonparent,Y,None,implicit,vkGetPhysicalDeviceSurfaceSupportKHR,(VK_KHR_surface)," Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance"
VUID-vkGetPhysicalDeviceSurfaceSupportKHR-pSupported-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfaceSupportKHR,(VK_KHR_surface), pSupported must be a valid pointer to a VkBool32 value
VUID-vkGetPhysicalDeviceSurfaceSupportKHR-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfaceSupportKHR,(VK_KHR_surface), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceSurfaceSupportKHR-queueFamilyIndex-01269,Y,None,explicit,vkGetPhysicalDeviceSurfaceSupportKHR,(VK_KHR_surface), queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice
VUID-vkGetPhysicalDeviceSurfaceSupportKHR-surface-parameter,Y,None,implicit,vkGetPhysicalDeviceSurfaceSupportKHR,(VK_KHR_surface), surface must be a valid VkSurfaceKHR handle
VUID-vkGetPhysicalDeviceWaylandPresentationSupportKHR-display-parameter,Y,None,implicit,vkGetPhysicalDeviceWaylandPresentationSupportKHR,(VK_KHR_surface)+(VK_KHR_wayland_surface), display must be a valid pointer to a wl_display value
VUID-vkGetPhysicalDeviceWaylandPresentationSupportKHR-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceWaylandPresentationSupportKHR,(VK_KHR_surface)+(VK_KHR_wayland_surface), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceWaylandPresentationSupportKHR-queueFamilyIndex-01306,Y,None,explicit,vkGetPhysicalDeviceWaylandPresentationSupportKHR,(VK_KHR_surface)+(VK_KHR_wayland_surface), queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice
VUID-vkGetPhysicalDeviceWin32PresentationSupportKHR-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceWin32PresentationSupportKHR,(VK_KHR_surface)+(VK_KHR_win32_surface), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceWin32PresentationSupportKHR-queueFamilyIndex-01309,Y,None,explicit,vkGetPhysicalDeviceWin32PresentationSupportKHR,(VK_KHR_surface)+(VK_KHR_win32_surface), queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice
VUID-vkGetPhysicalDeviceXcbPresentationSupportKHR-connection-parameter,Y,None,implicit,vkGetPhysicalDeviceXcbPresentationSupportKHR,(VK_KHR_surface)+(VK_KHR_xcb_surface), connection must be a valid pointer to a xcb_connection_t value
VUID-vkGetPhysicalDeviceXcbPresentationSupportKHR-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceXcbPresentationSupportKHR,(VK_KHR_surface)+(VK_KHR_xcb_surface), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceXcbPresentationSupportKHR-queueFamilyIndex-01312,Y,None,explicit,vkGetPhysicalDeviceXcbPresentationSupportKHR,(VK_KHR_surface)+(VK_KHR_xcb_surface), queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice
VUID-vkGetPhysicalDeviceXlibPresentationSupportKHR-dpy-parameter,Y,None,implicit,vkGetPhysicalDeviceXlibPresentationSupportKHR,(VK_KHR_surface)+(VK_KHR_xlib_surface), dpy must be a valid pointer to a Display value
VUID-vkGetPhysicalDeviceXlibPresentationSupportKHR-physicalDevice-parameter,Y,None,implicit,vkGetPhysicalDeviceXlibPresentationSupportKHR,(VK_KHR_surface)+(VK_KHR_xlib_surface), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetPhysicalDeviceXlibPresentationSupportKHR-queueFamilyIndex-01315,Y,None,explicit,vkGetPhysicalDeviceXlibPresentationSupportKHR,(VK_KHR_surface)+(VK_KHR_xlib_surface), queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice
VUID-vkGetPipelineCacheData-device-parameter,Y,None,implicit,vkGetPipelineCacheData,core, device must be a valid VkDevice handle
VUID-vkGetPipelineCacheData-pData-parameter,Y,None,implicit,vkGetPipelineCacheData,core," If the value referenced by pDataSize is not 0, and pData is not NULL, pData must be a valid pointer to an array of pDataSize bytes"
VUID-vkGetPipelineCacheData-pDataSize-parameter,N,None,implicit,vkGetPipelineCacheData,core, pDataSize must be a valid pointer to a size_t value
VUID-vkGetPipelineCacheData-pipelineCache-parameter,Y,None,implicit,vkGetPipelineCacheData,core, pipelineCache must be a valid VkPipelineCache handle
VUID-vkGetPipelineCacheData-pipelineCache-parent,Y,None,implicit,vkGetPipelineCacheData,core," pipelineCache must have been created, allocated, or retrieved from device"
VUID-vkGetQueryPoolResults-dataSize-00817,N,None,explicit,vkGetQueryPoolResults,core," dataSize must be large enough to contain the result of each query, as described here"
VUID-vkGetQueryPoolResults-dataSize-arraylength,Y,None,implicit,vkGetQueryPoolResults,core, dataSize must be greater than 0
VUID-vkGetQueryPoolResults-device-parameter,Y,None,implicit,vkGetQueryPoolResults,core, device must be a valid VkDevice handle
VUID-vkGetQueryPoolResults-firstQuery-00813,N,None,explicit,vkGetQueryPoolResults,core, firstQuery must be less than the number of queries in queryPool
VUID-vkGetQueryPoolResults-firstQuery-00816,N,None,explicit,vkGetQueryPoolResults,core, The sum of firstQuery and queryCount must be less than or equal to the number of queries in queryPool
VUID-vkGetQueryPoolResults-flags-00814,N,None,explicit,vkGetQueryPoolResults,core, If VK_QUERY_RESULT_64_BIT is not set in flags then pData and stride must be multiples of 4
VUID-vkGetQueryPoolResults-flags-00815,N,None,explicit,vkGetQueryPoolResults,core, If VK_QUERY_RESULT_64_BIT is set in flags then pData and stride must be multiples of 8
VUID-vkGetQueryPoolResults-flags-parameter,Y,None,implicit,vkGetQueryPoolResults,core, flags must be a valid combination of VkQueryResultFlagBits values
VUID-vkGetQueryPoolResults-pData-parameter,Y,None,implicit,vkGetQueryPoolResults,core, pData must be a valid pointer to an array of dataSize bytes
VUID-vkGetQueryPoolResults-queryPool-parameter,Y,None,implicit,vkGetQueryPoolResults,core, queryPool must be a valid VkQueryPool handle
VUID-vkGetQueryPoolResults-queryPool-parent,Y,None,implicit,vkGetQueryPoolResults,core," queryPool must have been created, allocated, or retrieved from device"
VUID-vkGetQueryPoolResults-queryType-00818,Y,QueryPoolInUseDestroyedSignaled,explicit,vkGetQueryPoolResults,core," If the queryType used to create queryPool was VK_QUERY_TYPE_TIMESTAMP, flags must not contain VK_QUERY_RESULT_PARTIAL_BIT"
VUID-vkGetQueueCheckpointDataNV-pCheckpointData-parameter,Y,None,implicit,vkGetQueueCheckpointDataNV,(VK_NV_device_diagnostic_checkpoints)," If the value referenced by pCheckpointDataCount is not 0, and pCheckpointData is not NULL, pCheckpointData must be a valid pointer to an array of pCheckpointDataCount VkCheckpointDataNV structures"
VUID-vkGetQueueCheckpointDataNV-pCheckpointDataCount-parameter,N,None,implicit,vkGetQueueCheckpointDataNV,(VK_NV_device_diagnostic_checkpoints), pCheckpointDataCount must be a valid pointer to a uint32_t value
VUID-vkGetQueueCheckpointDataNV-queue-02025,N,None,explicit,vkGetQueueCheckpointDataNV,(VK_NV_device_diagnostic_checkpoints), The device that queue belongs to must be in the lost state
VUID-vkGetQueueCheckpointDataNV-queue-parameter,Y,None,implicit,vkGetQueueCheckpointDataNV,(VK_NV_device_diagnostic_checkpoints), queue must be a valid VkQueue handle
VUID-vkGetRandROutputDisplayEXT-dpy-parameter,Y,None,implicit,vkGetRandROutputDisplayEXT,(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_direct_mode_display)+(VK_EXT_acquire_xlib_display), dpy must be a valid pointer to a Display value
VUID-vkGetRandROutputDisplayEXT-pDisplay-parameter,Y,None,implicit,vkGetRandROutputDisplayEXT,(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_direct_mode_display)+(VK_EXT_acquire_xlib_display), pDisplay must be a valid pointer to a VkDisplayKHR handle
VUID-vkGetRandROutputDisplayEXT-physicalDevice-parameter,Y,None,implicit,vkGetRandROutputDisplayEXT,(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_direct_mode_display)+(VK_EXT_acquire_xlib_display), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkGetRaytracingShaderHandlesNVX-dataSize-arraylength,Y,None,implicit,vkGetRaytracingShaderHandlesNVX,(VK_NVX_raytracing), dataSize must be greater than 0
VUID-vkGetRaytracingShaderHandlesNVX-device-parameter,Y,None,implicit,vkGetRaytracingShaderHandlesNVX,(VK_NVX_raytracing), device must be a valid VkDevice handle
VUID-vkGetRaytracingShaderHandlesNVX-pData-parameter,Y,None,implicit,vkGetRaytracingShaderHandlesNVX,(VK_NVX_raytracing), pData must be a valid pointer to an array of dataSize bytes
VUID-vkGetRaytracingShaderHandlesNVX-pipeline-parameter,Y,None,implicit,vkGetRaytracingShaderHandlesNVX,(VK_NVX_raytracing), pipeline must be a valid VkPipeline handle
VUID-vkGetRaytracingShaderHandlesNVX-pipeline-parent,Y,None,implicit,vkGetRaytracingShaderHandlesNVX,(VK_NVX_raytracing)," pipeline must have been created, allocated, or retrieved from device"
VUID-vkGetRefreshCycleDurationGOOGLE-commonparent,Y,None,implicit,vkGetRefreshCycleDurationGOOGLE,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing)," Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance"
VUID-vkGetRefreshCycleDurationGOOGLE-device-parameter,Y,None,implicit,vkGetRefreshCycleDurationGOOGLE,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing), device must be a valid VkDevice handle
VUID-vkGetRefreshCycleDurationGOOGLE-pDisplayTimingProperties-parameter,Y,None,implicit,vkGetRefreshCycleDurationGOOGLE,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing), pDisplayTimingProperties must be a valid pointer to a VkRefreshCycleDurationGOOGLE structure
VUID-vkGetRefreshCycleDurationGOOGLE-swapchain-parameter,Y,None,implicit,vkGetRefreshCycleDurationGOOGLE,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_GOOGLE_display_timing), swapchain must be a valid VkSwapchainKHR handle
VUID-vkGetRenderAreaGranularity-device-parameter,Y,None,implicit,vkGetRenderAreaGranularity,core, device must be a valid VkDevice handle
VUID-vkGetRenderAreaGranularity-pGranularity-parameter,Y,None,implicit,vkGetRenderAreaGranularity,core, pGranularity must be a valid pointer to a VkExtent2D structure
VUID-vkGetRenderAreaGranularity-renderPass-parameter,Y,None,implicit,vkGetRenderAreaGranularity,core, renderPass must be a valid VkRenderPass handle
VUID-vkGetRenderAreaGranularity-renderPass-parent,Y,None,implicit,vkGetRenderAreaGranularity,core," renderPass must have been created, allocated, or retrieved from device"
VUID-vkGetSemaphoreFdKHR-device-parameter,Y,None,implicit,vkGetSemaphoreFdKHR,(VK_KHR_external_semaphore_fd), device must be a valid VkDevice handle
VUID-vkGetSemaphoreFdKHR-pFd-parameter,Y,None,implicit,vkGetSemaphoreFdKHR,(VK_KHR_external_semaphore_fd), pFd must be a valid pointer to a int value
VUID-vkGetSemaphoreFdKHR-pGetFdInfo-parameter,Y,None,implicit,vkGetSemaphoreFdKHR,(VK_KHR_external_semaphore_fd), pGetFdInfo must be a valid pointer to a valid VkSemaphoreGetFdInfoKHR structure
VUID-vkGetSemaphoreWin32HandleKHR-device-parameter,Y,None,implicit,vkGetSemaphoreWin32HandleKHR,(VK_KHR_external_semaphore_win32), device must be a valid VkDevice handle
VUID-vkGetSemaphoreWin32HandleKHR-pGetWin32HandleInfo-parameter,Y,None,implicit,vkGetSemaphoreWin32HandleKHR,(VK_KHR_external_semaphore_win32), pGetWin32HandleInfo must be a valid pointer to a valid VkSemaphoreGetWin32HandleInfoKHR structure
VUID-vkGetSemaphoreWin32HandleKHR-pHandle-parameter,Y,None,implicit,vkGetSemaphoreWin32HandleKHR,(VK_KHR_external_semaphore_win32), pHandle must be a valid pointer to a HANDLE value
VUID-vkGetShaderInfoAMD-device-parameter,Y,None,implicit,vkGetShaderInfoAMD,(VK_AMD_shader_info), device must be a valid VkDevice handle
VUID-vkGetShaderInfoAMD-infoType-parameter,Y,None,implicit,vkGetShaderInfoAMD,(VK_AMD_shader_info), infoType must be a valid VkShaderInfoTypeAMD value
VUID-vkGetShaderInfoAMD-pInfo-parameter,Y,None,implicit,vkGetShaderInfoAMD,(VK_AMD_shader_info)," If the value referenced by pInfoSize is not 0, and pInfo is not NULL, pInfo must be a valid pointer to an array of pInfoSize bytes"
VUID-vkGetShaderInfoAMD-pInfoSize-parameter,N,None,implicit,vkGetShaderInfoAMD,(VK_AMD_shader_info), pInfoSize must be a valid pointer to a size_t value
VUID-vkGetShaderInfoAMD-pipeline-parameter,Y,None,implicit,vkGetShaderInfoAMD,(VK_AMD_shader_info), pipeline must be a valid VkPipeline handle
VUID-vkGetShaderInfoAMD-pipeline-parent,Y,None,implicit,vkGetShaderInfoAMD,(VK_AMD_shader_info)," pipeline must have been created, allocated, or retrieved from device"
VUID-vkGetShaderInfoAMD-shaderStage-parameter,Y,None,implicit,vkGetShaderInfoAMD,(VK_AMD_shader_info), shaderStage must be a valid VkShaderStageFlagBits value
VUID-vkGetSwapchainCounterEXT-commonparent,Y,None,implicit,vkGetSwapchainCounterEXT,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_display_control)," Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance"
VUID-vkGetSwapchainCounterEXT-counter-parameter,Y,None,implicit,vkGetSwapchainCounterEXT,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_display_control), counter must be a valid VkSurfaceCounterFlagBitsEXT value
VUID-vkGetSwapchainCounterEXT-device-parameter,Y,None,implicit,vkGetSwapchainCounterEXT,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_display_control), device must be a valid VkDevice handle
VUID-vkGetSwapchainCounterEXT-pCounterValue-parameter,Y,None,implicit,vkGetSwapchainCounterEXT,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_display_control), pCounterValue must be a valid pointer to a uint64_t value
VUID-vkGetSwapchainCounterEXT-swapchain-01245,N,None,explicit,vkGetSwapchainCounterEXT,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_display_control), One or more present commands on swapchain must have been processed by the presentation engine.
VUID-vkGetSwapchainCounterEXT-swapchain-parameter,Y,None,implicit,vkGetSwapchainCounterEXT,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_display_control), swapchain must be a valid VkSwapchainKHR handle
VUID-vkGetSwapchainImagesKHR-commonparent,N,None,implicit,vkGetSwapchainImagesKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance"
VUID-vkGetSwapchainImagesKHR-device-parameter,Y,None,implicit,vkGetSwapchainImagesKHR,(VK_KHR_surface)+(VK_KHR_swapchain), device must be a valid VkDevice handle
VUID-vkGetSwapchainImagesKHR-pSwapchainImageCount-parameter,N,None,implicit,vkGetSwapchainImagesKHR,(VK_KHR_surface)+(VK_KHR_swapchain), pSwapchainImageCount must be a valid pointer to a uint32_t value
VUID-vkGetSwapchainImagesKHR-pSwapchainImages-parameter,Y,None,implicit,vkGetSwapchainImagesKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," If the value referenced by pSwapchainImageCount is not 0, and pSwapchainImages is not NULL, pSwapchainImages must be a valid pointer to an array of pSwapchainImageCount VkImage handles"
VUID-vkGetSwapchainImagesKHR-swapchain-parameter,Y,None,implicit,vkGetSwapchainImagesKHR,(VK_KHR_surface)+(VK_KHR_swapchain), swapchain must be a valid VkSwapchainKHR handle
VUID-vkGetSwapchainStatusKHR-commonparent,Y,None,implicit,vkGetSwapchainStatusKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_shared_presentable_image)," Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance"
VUID-vkGetSwapchainStatusKHR-device-parameter,Y,None,implicit,vkGetSwapchainStatusKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_shared_presentable_image), device must be a valid VkDevice handle
VUID-vkGetSwapchainStatusKHR-swapchain-parameter,Y,None,implicit,vkGetSwapchainStatusKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_shared_presentable_image), swapchain must be a valid VkSwapchainKHR handle
VUID-vkGetValidationCacheDataEXT-device-parameter,Y,None,implicit,vkGetValidationCacheDataEXT,(VK_EXT_validation_cache), device must be a valid VkDevice handle
VUID-vkGetValidationCacheDataEXT-pData-parameter,Y,None,implicit,vkGetValidationCacheDataEXT,(VK_EXT_validation_cache)," If the value referenced by pDataSize is not 0, and pData is not NULL, pData must be a valid pointer to an array of pDataSize bytes"
VUID-vkGetValidationCacheDataEXT-pDataSize-parameter,N,None,implicit,vkGetValidationCacheDataEXT,(VK_EXT_validation_cache), pDataSize must be a valid pointer to a size_t value
VUID-vkGetValidationCacheDataEXT-validationCache-parameter,Y,None,implicit,vkGetValidationCacheDataEXT,(VK_EXT_validation_cache), validationCache must be a valid VkValidationCacheEXT handle
VUID-vkGetValidationCacheDataEXT-validationCache-parent,Y,None,implicit,vkGetValidationCacheDataEXT,(VK_EXT_validation_cache)," validationCache must have been created, allocated, or retrieved from device"
VUID-vkImportFenceFdKHR-device-parameter,Y,None,implicit,vkImportFenceFdKHR,(VK_KHR_external_fence_fd), device must be a valid VkDevice handle
VUID-vkImportFenceFdKHR-fence-01463,N,None,explicit,vkImportFenceFdKHR,(VK_KHR_external_fence_fd), fence must not be associated with any queue command that has not yet completed execution on that queue
VUID-vkImportFenceFdKHR-pImportFenceFdInfo-parameter,Y,None,implicit,vkImportFenceFdKHR,(VK_KHR_external_fence_fd), pImportFenceFdInfo must be a valid pointer to a valid VkImportFenceFdInfoKHR structure
VUID-vkImportFenceWin32HandleKHR-device-parameter,Y,None,implicit,vkImportFenceWin32HandleKHR,(VK_KHR_external_fence_win32), device must be a valid VkDevice handle
VUID-vkImportFenceWin32HandleKHR-pImportFenceWin32HandleInfo-parameter,Y,None,implicit,vkImportFenceWin32HandleKHR,(VK_KHR_external_fence_win32), pImportFenceWin32HandleInfo must be a valid pointer to a valid VkImportFenceWin32HandleInfoKHR structure
VUID-vkImportSemaphoreFdKHR-device-parameter,Y,None,implicit,vkImportSemaphoreFdKHR,(VK_KHR_external_semaphore_fd), device must be a valid VkDevice handle
VUID-vkImportSemaphoreFdKHR-pImportSemaphoreFdInfo-parameter,Y,None,implicit,vkImportSemaphoreFdKHR,(VK_KHR_external_semaphore_fd), pImportSemaphoreFdInfo must be a valid pointer to a valid VkImportSemaphoreFdInfoKHR structure
VUID-vkImportSemaphoreFdKHR-semaphore-01142,N,None,explicit,vkImportSemaphoreFdKHR,(VK_KHR_external_semaphore_fd), semaphore must not be associated with any queue command that has not yet completed execution on that queue
VUID-vkImportSemaphoreWin32HandleKHR-device-parameter,Y,None,implicit,vkImportSemaphoreWin32HandleKHR,(VK_KHR_external_semaphore_win32), device must be a valid VkDevice handle
VUID-vkImportSemaphoreWin32HandleKHR-pImportSemaphoreWin32HandleInfo-parameter,Y,None,implicit,vkImportSemaphoreWin32HandleKHR,(VK_KHR_external_semaphore_win32), pImportSemaphoreWin32HandleInfo must be a valid pointer to a valid VkImportSemaphoreWin32HandleInfoKHR structure
VUID-vkInvalidateMappedMemoryRanges-device-parameter,Y,None,implicit,vkInvalidateMappedMemoryRanges,core, device must be a valid VkDevice handle
VUID-vkInvalidateMappedMemoryRanges-memoryRangeCount-arraylength,N,None,implicit,vkInvalidateMappedMemoryRanges,core, memoryRangeCount must be greater than 0
VUID-vkInvalidateMappedMemoryRanges-pMemoryRanges-parameter,Y,None,implicit,vkInvalidateMappedMemoryRanges,core, pMemoryRanges must be a valid pointer to an array of memoryRangeCount valid VkMappedMemoryRange structures
VUID-vkMapMemory-device-parameter,Y,None,implicit,vkMapMemory,core, device must be a valid VkDevice handle
VUID-vkMapMemory-flags-zerobitmask,Y,None,implicit,vkMapMemory,core, flags must be 0
VUID-vkMapMemory-memory-00678,N,None,explicit,vkMapMemory,core, memory must not be currently mapped
VUID-vkMapMemory-memory-00682,Y,MapMemWithoutHostVisibleBit,explicit,vkMapMemory,core, memory must have been created with a memory type that reports VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT
VUID-vkMapMemory-memory-00683,N,None,explicit,vkMapMemory,(VK_KHR_device_group), memory must not have been allocated with multiple instances.
VUID-vkMapMemory-memory-parameter,Y,None,implicit,vkMapMemory,core, memory must be a valid VkDeviceMemory handle
VUID-vkMapMemory-memory-parent,Y,None,implicit,vkMapMemory,core," memory must have been created, allocated, or retrieved from device"
VUID-vkMapMemory-offset-00679,N,None,explicit,vkMapMemory,core, offset must be less than the size of memory
VUID-vkMapMemory-ppData-parameter,N,None,implicit,vkMapMemory,core, ppData must be a valid pointer to a pointer value
VUID-vkMapMemory-size-00680,N,None,explicit,vkMapMemory,core," If size is not equal to VK_WHOLE_SIZE, size must be greater than 0"
VUID-vkMapMemory-size-00681,Y,None,explicit,vkMapMemory,core," If size is not equal to VK_WHOLE_SIZE, size must be less than or equal to the size of the memory minus offset"
VUID-vkMergePipelineCaches-device-parameter,Y,None,implicit,vkMergePipelineCaches,core, device must be a valid VkDevice handle
VUID-vkMergePipelineCaches-dstCache-00770,N,None,explicit,vkMergePipelineCaches,core, dstCache must not appear in the list of source caches
VUID-vkMergePipelineCaches-dstCache-parameter,Y,None,implicit,vkMergePipelineCaches,core, dstCache must be a valid VkPipelineCache handle
VUID-vkMergePipelineCaches-dstCache-parent,Y,None,implicit,vkMergePipelineCaches,core," dstCache must have been created, allocated, or retrieved from device"
VUID-vkMergePipelineCaches-pSrcCaches-parameter,Y,None,implicit,vkMergePipelineCaches,core, pSrcCaches must be a valid pointer to an array of srcCacheCount valid VkPipelineCache handles
VUID-vkMergePipelineCaches-pSrcCaches-parent,Y,None,implicit,vkMergePipelineCaches,core," Each element of pSrcCaches must have been created, allocated, or retrieved from device"
VUID-vkMergePipelineCaches-srcCacheCount-arraylength,N,None,implicit,vkMergePipelineCaches,core, srcCacheCount must be greater than 0
VUID-vkMergeValidationCachesEXT-device-parameter,Y,None,implicit,vkMergeValidationCachesEXT,(VK_EXT_validation_cache), device must be a valid VkDevice handle
VUID-vkMergeValidationCachesEXT-dstCache-01536,Y,ValidationCacheTestBadMerge,explicit,vkMergeValidationCachesEXT,(VK_EXT_validation_cache), dstCache must not appear in the list of source caches
VUID-vkMergeValidationCachesEXT-dstCache-parameter,Y,None,implicit,vkMergeValidationCachesEXT,(VK_EXT_validation_cache), dstCache must be a valid VkValidationCacheEXT handle
VUID-vkMergeValidationCachesEXT-dstCache-parent,Y,None,implicit,vkMergeValidationCachesEXT,(VK_EXT_validation_cache)," dstCache must have been created, allocated, or retrieved from device"
VUID-vkMergeValidationCachesEXT-pSrcCaches-parameter,Y,None,implicit,vkMergeValidationCachesEXT,(VK_EXT_validation_cache), pSrcCaches must be a valid pointer to an array of srcCacheCount valid VkValidationCacheEXT handles
VUID-vkMergeValidationCachesEXT-pSrcCaches-parent,Y,None,implicit,vkMergeValidationCachesEXT,(VK_EXT_validation_cache)," Each element of pSrcCaches must have been created, allocated, or retrieved from device"
VUID-vkMergeValidationCachesEXT-srcCacheCount-arraylength,N,None,implicit,vkMergeValidationCachesEXT,(VK_EXT_validation_cache), srcCacheCount must be greater than 0
VUID-vkQueueBeginDebugUtilsLabelEXT-pLabelInfo-parameter,Y,None,implicit,vkQueueBeginDebugUtilsLabelEXT,(VK_EXT_debug_utils), pLabelInfo must be a valid pointer to a valid VkDebugUtilsLabelEXT structure
VUID-vkQueueBeginDebugUtilsLabelEXT-queue-parameter,N,None,implicit,vkQueueBeginDebugUtilsLabelEXT,(VK_EXT_debug_utils), queue must be a valid VkQueue handle
VUID-vkQueueBindSparse-commonparent,Y,None,implicit,vkQueueBindSparse,core," Both of fence, and queue that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkQueueBindSparse-fence-01113,N,None,explicit,vkQueueBindSparse,core," If fence is not VK_NULL_HANDLE, fence must be unsignaled"
VUID-vkQueueBindSparse-fence-01114,N,None,explicit,vkQueueBindSparse,core," If fence is not VK_NULL_HANDLE, fence must not be associated with any other queue command that has not yet completed execution on that queue"
VUID-vkQueueBindSparse-fence-parameter,Y,None,implicit,vkQueueBindSparse,core," If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle"
VUID-vkQueueBindSparse-pBindInfo-parameter,Y,None,implicit,vkQueueBindSparse,core," If bindInfoCount is not 0, pBindInfo must be a valid pointer to an array of bindInfoCount valid VkBindSparseInfo structures"
VUID-vkQueueBindSparse-pSignalSemaphores-01115,N,None,explicit,vkQueueBindSparse,core, Each element of the pSignalSemaphores member of each element of pBindInfo must be unsignaled when the semaphore signal operation it defines is executed on the device
VUID-vkQueueBindSparse-pWaitSemaphores-01116,N,None,explicit,vkQueueBindSparse,core," When a semaphore unsignal operation defined by any element of the pWaitSemaphores member of any element of pBindInfo executes on queue, no other queue must be waiting on the same semaphore."
VUID-vkQueueBindSparse-pWaitSemaphores-01117,N,None,explicit,vkQueueBindSparse,core," All elements of the pWaitSemaphores member of all elements of pBindInfo must be semaphores that are signaled, or have semaphore signal operations previously submitted for execution."
VUID-vkQueueBindSparse-queue-parameter,Y,None,implicit,vkQueueBindSparse,core, queue must be a valid VkQueue handle
VUID-vkQueueBindSparse-queuetype,Y,None,implicit,vkQueueBindSparse,core, The queue must support sparse binding operations
VUID-vkQueueEndDebugUtilsLabelEXT-None-01911,N,None,explicit,vkQueueEndDebugUtilsLabelEXT,(VK_EXT_debug_utils), There must be an outstanding vkQueueBeginDebugUtilsLabelEXT command prior to the vkQueueEndDebugUtilsLabelEXT on the queue
VUID-vkQueueEndDebugUtilsLabelEXT-queue-parameter,N,None,implicit,vkQueueEndDebugUtilsLabelEXT,(VK_EXT_debug_utils), queue must be a valid VkQueue handle
VUID-vkQueueInsertDebugUtilsLabelEXT-pLabelInfo-parameter,Y,None,implicit,vkQueueInsertDebugUtilsLabelEXT,(VK_EXT_debug_utils), pLabelInfo must be a valid pointer to a valid VkDebugUtilsLabelEXT structure
VUID-vkQueueInsertDebugUtilsLabelEXT-queue-parameter,N,None,implicit,vkQueueInsertDebugUtilsLabelEXT,(VK_EXT_debug_utils), queue must be a valid VkQueue handle
VUID-vkQueuePresentKHR-pPresentInfo-parameter,Y,None,implicit,vkQueuePresentKHR,(VK_KHR_surface)+(VK_KHR_swapchain), pPresentInfo must be a valid pointer to a valid VkPresentInfoKHR structure
VUID-vkQueuePresentKHR-pSwapchains-01292,Y,None,explicit,vkQueuePresentKHR,(VK_KHR_surface)+(VK_KHR_swapchain), Each element of pSwapchains member of pPresentInfo must be a swapchain that is created for a surface for which presentation is supported from queue as determined using a call to vkGetPhysicalDeviceSurfaceSupportKHR
VUID-vkQueuePresentKHR-pSwapchains-01293,N,None,explicit,vkQueuePresentKHR,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_KHR_display_swapchain)," If more than one member of pSwapchains was created from a display surface, all display surfaces referenced that refer to the same display must use the same display mode"
VUID-vkQueuePresentKHR-pWaitSemaphores-01294,N,None,explicit,vkQueuePresentKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," When a semaphore unsignal operation defined by the elements of the pWaitSemaphores member of pPresentInfo executes on queue, no other queue must be waiting on the same semaphore."
VUID-vkQueuePresentKHR-pWaitSemaphores-01295,N,None,explicit,vkQueuePresentKHR,(VK_KHR_surface)+(VK_KHR_swapchain)," All elements of the pWaitSemaphores member of pPresentInfo must be semaphores that are signaled, or have semaphore signal operations previously submitted for execution."
VUID-vkQueuePresentKHR-queue-parameter,Y,None,implicit,vkQueuePresentKHR,(VK_KHR_surface)+(VK_KHR_swapchain), queue must be a valid VkQueue handle
VUID-vkQueueSubmit-commonparent,Y,None,implicit,vkQueueSubmit,core," Both of fence, and queue that are valid handles must have been created, allocated, or retrieved from the same VkDevice"
VUID-vkQueueSubmit-fence-00063,N,None,explicit,vkQueueSubmit,core," If fence is not VK_NULL_HANDLE, fence must be unsignaled"
VUID-vkQueueSubmit-fence-00064,N,None,explicit,vkQueueSubmit,core," If fence is not VK_NULL_HANDLE, fence must not be associated with any other queue command that has not yet completed execution on that queue"
VUID-vkQueueSubmit-fence-parameter,Y,None,implicit,vkQueueSubmit,core," If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle"
VUID-vkQueueSubmit-pCommandBuffers-00065,N,None,explicit,vkQueueSubmit,core," Any calls to vkCmdSetEvent, vkCmdResetEvent or vkCmdWaitEvents that have been recorded into any of the command buffer elements of the pCommandBuffers member of any element of pSubmits, must not reference any VkEvent that is referenced by any of those commands in a command buffer that has been submitted to another queue and is still in the pending state."
VUID-vkQueueSubmit-pCommandBuffers-00070,N,None,explicit,vkQueueSubmit,core, Each element of the pCommandBuffers member of each element of pSubmits must be in the pending or executable state.
VUID-vkQueueSubmit-pCommandBuffers-00071,Y,None,explicit,vkQueueSubmit,core," If any element of the pCommandBuffers member of any element of pSubmits was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT, it must not be in the pending state."
VUID-vkQueueSubmit-pCommandBuffers-00072,Y,ExecuteUnrecordedPrimaryCB,explicit,vkQueueSubmit,core, Any secondary command buffers recorded into any element of the pCommandBuffers member of any element of pSubmits must be in the pending or executable state.
VUID-vkQueueSubmit-pCommandBuffers-00073,Y,None,explicit,vkQueueSubmit,core," If any secondary command buffers recorded into any element of the pCommandBuffers member of any element of pSubmits was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT, it must not be in the pending state."
VUID-vkQueueSubmit-pCommandBuffers-00074,Y,MismatchedQueueFamiliesOnSubmit,explicit,vkQueueSubmit,core, Each element of the pCommandBuffers member of each element of pSubmits must have been allocated from a VkCommandPool that was created for the same queue family queue belongs to.
VUID-vkQueueSubmit-pSignalSemaphores-00067,N,None,explicit,vkQueueSubmit,core, Each element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device
VUID-vkQueueSubmit-pSubmits-02207,N,None,explicit,vkQueueSubmit,core," If any element of pSubmits->pCommandBuffers includes a Queue Family Transfer Acquire Operation, there must exist a previously submitted Queue Family Transfer Release Operation on a queue in the queue family identified by the acquire operation, with parameters matching the acquire operation as defined in the definition of such acquire operations, and which happens before the acquire operation."
VUID-vkQueueSubmit-pSubmits-parameter,Y,None,implicit,vkQueueSubmit,core," If submitCount is not 0, pSubmits must be a valid pointer to an array of submitCount valid VkSubmitInfo structures"
VUID-vkQueueSubmit-pWaitDstStageMask-00066,N,None,explicit,vkQueueSubmit,core," Any stage flag included in any element of the pWaitDstStageMask member of any element of pSubmits must be a pipeline stage supported by one of the capabilities of queue, as specified in the table of supported pipeline stages."
VUID-vkQueueSubmit-pWaitSemaphores-00068,N,None,explicit,vkQueueSubmit,core," When a semaphore unsignal operation defined by any element of the pWaitSemaphores member of any element of pSubmits executes on queue, no other queue must be waiting on the same semaphore."
VUID-vkQueueSubmit-pWaitSemaphores-00069,N,None,explicit,vkQueueSubmit,core," All elements of the pWaitSemaphores member of all elements of pSubmits must be semaphores that are signaled, or have semaphore signal operations previously submitted for execution."
VUID-vkQueueSubmit-queue-parameter,Y,None,implicit,vkQueueSubmit,core, queue must be a valid VkQueue handle
VUID-vkQueueWaitIdle-queue-parameter,Y,None,implicit,vkQueueWaitIdle,core, queue must be a valid VkQueue handle
VUID-vkRegisterDeviceEventEXT-device-parameter,Y,None,implicit,vkRegisterDeviceEventEXT,(VK_EXT_display_control), device must be a valid VkDevice handle
VUID-vkRegisterDeviceEventEXT-pAllocator-parameter,N,None,implicit,vkRegisterDeviceEventEXT,(VK_EXT_display_control)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkRegisterDeviceEventEXT-pDeviceEventInfo-parameter,Y,None,implicit,vkRegisterDeviceEventEXT,(VK_EXT_display_control), pDeviceEventInfo must be a valid pointer to a valid VkDeviceEventInfoEXT structure
VUID-vkRegisterDeviceEventEXT-pFence-parameter,Y,None,implicit,vkRegisterDeviceEventEXT,(VK_EXT_display_control), pFence must be a valid pointer to a VkFence handle
VUID-vkRegisterDisplayEventEXT-device-parameter,Y,None,implicit,vkRegisterDisplayEventEXT,(VK_EXT_display_control), device must be a valid VkDevice handle
VUID-vkRegisterDisplayEventEXT-display-parameter,Y,None,implicit,vkRegisterDisplayEventEXT,(VK_EXT_display_control), display must be a valid VkDisplayKHR handle
VUID-vkRegisterDisplayEventEXT-pAllocator-parameter,N,None,implicit,vkRegisterDisplayEventEXT,(VK_EXT_display_control)," If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure"
VUID-vkRegisterDisplayEventEXT-pDisplayEventInfo-parameter,Y,None,implicit,vkRegisterDisplayEventEXT,(VK_EXT_display_control), pDisplayEventInfo must be a valid pointer to a valid VkDisplayEventInfoEXT structure
VUID-vkRegisterDisplayEventEXT-pFence-parameter,Y,None,implicit,vkRegisterDisplayEventEXT,(VK_EXT_display_control), pFence must be a valid pointer to a VkFence handle
VUID-vkRegisterObjectsNVX-device-parameter,Y,None,implicit,vkRegisterObjectsNVX,(VK_NVX_device_generated_commands), device must be a valid VkDevice handle
VUID-vkRegisterObjectsNVX-objectCount-arraylength,Y,None,implicit,vkRegisterObjectsNVX,(VK_NVX_device_generated_commands), objectCount must be greater than 0
VUID-vkRegisterObjectsNVX-objectTable-parameter,Y,None,implicit,vkRegisterObjectsNVX,(VK_NVX_device_generated_commands), objectTable must be a valid VkObjectTableNVX handle
VUID-vkRegisterObjectsNVX-objectTable-parent,Y,None,implicit,vkRegisterObjectsNVX,(VK_NVX_device_generated_commands)," objectTable must have been created, allocated, or retrieved from device"
VUID-vkRegisterObjectsNVX-pObjectIndices-01365,N,None,explicit,vkRegisterObjectsNVX,(VK_NVX_device_generated_commands), At any pObjectIndices there must not be a registered resource already.
VUID-vkRegisterObjectsNVX-pObjectIndices-01366,N,None,explicit,vkRegisterObjectsNVX,(VK_NVX_device_generated_commands), Any value inside pObjectIndices must be below the appropriate VkObjectTableCreateInfoNVX::pObjectEntryCounts limits provided at objectTable creation time.
VUID-vkRegisterObjectsNVX-pObjectIndices-parameter,Y,None,implicit,vkRegisterObjectsNVX,(VK_NVX_device_generated_commands), pObjectIndices must be a valid pointer to an array of objectCount uint32_t values
VUID-vkRegisterObjectsNVX-pObjectTableEntry-01364,N,None,explicit,vkRegisterObjectsNVX,(VK_NVX_device_generated_commands), The contents of pObjectTableEntry must yield plausible bindings supported by the device.
VUID-vkRegisterObjectsNVX-ppObjectTableEntries-parameter,Y,None,implicit,vkRegisterObjectsNVX,(VK_NVX_device_generated_commands), ppObjectTableEntries must be a valid pointer to an array of objectCount valid VkObjectTableEntryNVX structures
VUID-vkReleaseDisplayEXT-display-parameter,Y,None,implicit,vkReleaseDisplayEXT,(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_direct_mode_display), display must be a valid VkDisplayKHR handle
VUID-vkReleaseDisplayEXT-physicalDevice-parameter,Y,None,implicit,vkReleaseDisplayEXT,(VK_KHR_surface)+(VK_KHR_display)+(VK_EXT_direct_mode_display), physicalDevice must be a valid VkPhysicalDevice handle
VUID-vkResetCommandBuffer-commandBuffer-00045,Y,None,explicit,vkResetCommandBuffer,core, commandBuffer must not be in the pending state
VUID-vkResetCommandBuffer-commandBuffer-00046,Y,CommandBufferResetErrors,explicit,vkResetCommandBuffer,core, commandBuffer must have been allocated from a pool that was created with the VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT
VUID-vkResetCommandBuffer-commandBuffer-parameter,Y,None,implicit,vkResetCommandBuffer,core, commandBuffer must be a valid VkCommandBuffer handle
VUID-vkResetCommandBuffer-flags-parameter,Y,None,implicit,vkResetCommandBuffer,core, flags must be a valid combination of VkCommandBufferResetFlagBits values
VUID-vkResetCommandPool-commandPool-00040,Y,None,explicit,vkResetCommandPool,core, All VkCommandBuffer objects allocated from commandPool must not be in the pending state
VUID-vkResetCommandPool-commandPool-parameter,Y,None,implicit,vkResetCommandPool,core, commandPool must be a valid VkCommandPool handle
VUID-vkResetCommandPool-commandPool-parent,Y,None,implicit,vkResetCommandPool,core," commandPool must have been created, allocated, or retrieved from device"
VUID-vkResetCommandPool-device-parameter,Y,None,implicit,vkResetCommandPool,core, device must be a valid VkDevice handle
VUID-vkResetCommandPool-flags-parameter,Y,None,implicit,vkResetCommandPool,core, flags must be a valid combination of VkCommandPoolResetFlagBits values
VUID-vkResetDescriptorPool-descriptorPool-00313,Y,DescriptorPoolInUseResetSignaled,explicit,vkResetDescriptorPool,core, All uses of descriptorPool (via any allocated descriptor sets) must have completed execution
VUID-vkResetDescriptorPool-descriptorPool-parameter,Y,InvalidDescriptorPool,implicit,vkResetDescriptorPool,core, descriptorPool must be a valid VkDescriptorPool handle
VUID-vkResetDescriptorPool-descriptorPool-parent,Y,None,implicit,vkResetDescriptorPool,core," descriptorPool must have been created, allocated, or retrieved from device"
VUID-vkResetDescriptorPool-device-parameter,Y,None,implicit,vkResetDescriptorPool,core, device must be a valid VkDevice handle
VUID-vkResetDescriptorPool-flags-zerobitmask,Y,None,implicit,vkResetDescriptorPool,core, flags must be 0
VUID-vkResetEvent-device-parameter,Y,None,implicit,vkResetEvent,core, device must be a valid VkDevice handle
VUID-vkResetEvent-event-01148,N,None,explicit,vkResetEvent,core, event must not be waited on by a vkCmdWaitEvents command that is currently executing
VUID-vkResetEvent-event-parameter,Y,None,implicit,vkResetEvent,core, event must be a valid VkEvent handle
VUID-vkResetEvent-event-parent,Y,None,implicit,vkResetEvent,core," event must have been created, allocated, or retrieved from device"
VUID-vkResetFences-device-parameter,Y,None,implicit,vkResetFences,core, device must be a valid VkDevice handle
VUID-vkResetFences-fenceCount-arraylength,N,None,implicit,vkResetFences,core, fenceCount must be greater than 0
VUID-vkResetFences-pFences-01123,Y,None,explicit,vkResetFences,core, Each element of pFences must not be currently associated with any queue command that has not yet completed execution on that queue
VUID-vkResetFences-pFences-parameter,Y,None,implicit,vkResetFences,core, pFences must be a valid pointer to an array of fenceCount valid VkFence handles
VUID-vkResetFences-pFences-parent,Y,None,implicit,vkResetFences,core," Each element of pFences must have been created, allocated, or retrieved from device"
VUID-vkSetDebugUtilsObjectNameEXT-device-parameter,N,None,implicit,vkSetDebugUtilsObjectNameEXT,(VK_EXT_debug_utils), device must be a valid VkDevice handle
VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-parameter,Y,None,implicit,vkSetDebugUtilsObjectNameEXT,(VK_EXT_debug_utils), pNameInfo must be a valid pointer to a valid VkDebugUtilsObjectNameInfoEXT structure
VUID-vkSetDebugUtilsObjectTagEXT-device-parameter,N,None,implicit,vkSetDebugUtilsObjectTagEXT,(VK_EXT_debug_utils), device must be a valid VkDevice handle
VUID-vkSetDebugUtilsObjectTagEXT-pTagInfo-parameter,Y,None,implicit,vkSetDebugUtilsObjectTagEXT,(VK_EXT_debug_utils), pTagInfo must be a valid pointer to a valid VkDebugUtilsObjectTagInfoEXT structure
VUID-vkSetEvent-device-parameter,Y,None,implicit,vkSetEvent,core, device must be a valid VkDevice handle
VUID-vkSetEvent-event-parameter,Y,None,implicit,vkSetEvent,core, event must be a valid VkEvent handle
VUID-vkSetEvent-event-parent,Y,None,implicit,vkSetEvent,core," event must have been created, allocated, or retrieved from device"
VUID-vkSetHdrMetadataEXT-commonparent,Y,None,implicit,vkSetHdrMetadataEXT,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_hdr_metadata)," Both of device, and the elements of pSwapchains must have been created, allocated, or retrieved from the same VkInstance"
VUID-vkSetHdrMetadataEXT-device-parameter,Y,None,implicit,vkSetHdrMetadataEXT,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_hdr_metadata), device must be a valid VkDevice handle
VUID-vkSetHdrMetadataEXT-pMetadata-parameter,Y,None,implicit,vkSetHdrMetadataEXT,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_hdr_metadata), pMetadata must be a valid pointer to an array of swapchainCount valid VkHdrMetadataEXT structures
VUID-vkSetHdrMetadataEXT-pSwapchains-parameter,Y,None,implicit,vkSetHdrMetadataEXT,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_hdr_metadata), pSwapchains must be a valid pointer to an array of swapchainCount valid VkSwapchainKHR handles
VUID-vkSetHdrMetadataEXT-swapchainCount-arraylength,N,None,implicit,vkSetHdrMetadataEXT,(VK_KHR_surface)+(VK_KHR_swapchain)+(VK_EXT_hdr_metadata), swapchainCount must be greater than 0
VUID-vkSubmitDebugUtilsMessageEXT-instance-parameter,N,None,implicit,vkSubmitDebugUtilsMessageEXT,(VK_EXT_debug_utils), instance must be a valid VkInstance handle
VUID-vkSubmitDebugUtilsMessageEXT-messageSeverity-parameter,Y,None,implicit,vkSubmitDebugUtilsMessageEXT,(VK_EXT_debug_utils), messageSeverity must be a valid VkDebugUtilsMessageSeverityFlagBitsEXT value
VUID-vkSubmitDebugUtilsMessageEXT-messageTypes-parameter,N,None,implicit,vkSubmitDebugUtilsMessageEXT,(VK_EXT_debug_utils), messageTypes must be a valid combination of VkDebugUtilsMessageTypeFlagBitsEXT values
VUID-vkSubmitDebugUtilsMessageEXT-messageTypes-requiredbitmask,Y,None,implicit,vkSubmitDebugUtilsMessageEXT,(VK_EXT_debug_utils), messageTypes must not be 0
VUID-vkSubmitDebugUtilsMessageEXT-pCallbackData-parameter,Y,None,implicit,vkSubmitDebugUtilsMessageEXT,(VK_EXT_debug_utils), pCallbackData must be a valid pointer to a valid VkDebugUtilsMessengerCallbackDataEXT structure
VUID-vkTrimCommandPool-commandPool-parameter,Y,None,implicit,vkTrimCommandPool,"(VK_VERSION_1_1,VK_KHR_maintenance1)", commandPool must be a valid VkCommandPool handle
VUID-vkTrimCommandPool-commandPool-parent,Y,None,implicit,vkTrimCommandPool,"(VK_VERSION_1_1,VK_KHR_maintenance1)"," commandPool must have been created, allocated, or retrieved from device"
VUID-vkTrimCommandPool-device-parameter,Y,None,implicit,vkTrimCommandPool,"(VK_VERSION_1_1,VK_KHR_maintenance1)", device must be a valid VkDevice handle
VUID-vkTrimCommandPool-flags-zerobitmask,Y,None,implicit,vkTrimCommandPool,"(VK_VERSION_1_1,VK_KHR_maintenance1)", flags must be 0
VUID-vkUnmapMemory-device-parameter,Y,None,implicit,vkUnmapMemory,core, device must be a valid VkDevice handle
VUID-vkUnmapMemory-memory-00689,Y,None,explicit,vkUnmapMemory,core, memory must be currently mapped
VUID-vkUnmapMemory-memory-parameter,Y,None,implicit,vkUnmapMemory,core, memory must be a valid VkDeviceMemory handle
VUID-vkUnmapMemory-memory-parent,Y,None,implicit,vkUnmapMemory,core," memory must have been created, allocated, or retrieved from device"
VUID-vkUnregisterObjectsNVX-None-01375,N,None,explicit,vkUnregisterObjectsNVX,(VK_NVX_device_generated_commands), All operations on the device using the registered resource must have been completed.
VUID-vkUnregisterObjectsNVX-device-parameter,Y,None,implicit,vkUnregisterObjectsNVX,(VK_NVX_device_generated_commands), device must be a valid VkDevice handle
VUID-vkUnregisterObjectsNVX-objectCount-arraylength,Y,None,implicit,vkUnregisterObjectsNVX,(VK_NVX_device_generated_commands), objectCount must be greater than 0
VUID-vkUnregisterObjectsNVX-objectTable-parameter,Y,None,implicit,vkUnregisterObjectsNVX,(VK_NVX_device_generated_commands), objectTable must be a valid VkObjectTableNVX handle
VUID-vkUnregisterObjectsNVX-objectTable-parent,Y,None,implicit,vkUnregisterObjectsNVX,(VK_NVX_device_generated_commands)," objectTable must have been created, allocated, or retrieved from device"
VUID-vkUnregisterObjectsNVX-pObjectEntryTypes-01374,N,None,explicit,vkUnregisterObjectsNVX,(VK_NVX_device_generated_commands), The pObjectEntryTypes of the resource at pObjectIndices must match.
VUID-vkUnregisterObjectsNVX-pObjectEntryTypes-parameter,N,None,implicit,vkUnregisterObjectsNVX,(VK_NVX_device_generated_commands), pObjectEntryTypes must be a valid pointer to an array of objectCount valid VkObjectEntryTypeNVX values
VUID-vkUnregisterObjectsNVX-pObjectIndices-01373,N,None,explicit,vkUnregisterObjectsNVX,(VK_NVX_device_generated_commands), At any pObjectIndices there must be a registered resource already.
VUID-vkUnregisterObjectsNVX-pObjectIndices-parameter,Y,None,implicit,vkUnregisterObjectsNVX,(VK_NVX_device_generated_commands), pObjectIndices must be a valid pointer to an array of objectCount uint32_t values
VUID-vkUpdateDescriptorSetWithTemplate-descriptorSet-parameter,Y,None,implicit,vkUpdateDescriptorSetWithTemplate,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", descriptorSet must be a valid VkDescriptorSet handle
VUID-vkUpdateDescriptorSetWithTemplate-descriptorUpdateTemplate-parameter,Y,None,implicit,vkUpdateDescriptorSetWithTemplate,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", descriptorUpdateTemplate must be a valid VkDescriptorUpdateTemplate handle
VUID-vkUpdateDescriptorSetWithTemplate-descriptorUpdateTemplate-parent,Y,None,implicit,vkUpdateDescriptorSetWithTemplate,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)"," descriptorUpdateTemplate must have been created, allocated, or retrieved from device"
VUID-vkUpdateDescriptorSetWithTemplate-device-parameter,Y,None,implicit,vkUpdateDescriptorSetWithTemplate,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)", device must be a valid VkDevice handle
VUID-vkUpdateDescriptorSetWithTemplate-pData-01685,N,None,explicit,vkUpdateDescriptorSetWithTemplate,"(VK_VERSION_1_1,VK_KHR_descriptor_update_template)"," pData must be a valid pointer to a memory that contains one or more valid instances of VkDescriptorImageInfo, VkDescriptorBufferInfo, or VkBufferView in a layout defined by descriptorUpdateTemplate when it was created with vkCreateDescriptorUpdateTemplate"
VUID-vkUpdateDescriptorSets-None-03047,N,None,explicit,vkUpdateDescriptorSets,(VK_EXT_descriptor_indexing), Descriptor bindings updated by this command which were created without the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT or VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT bits set must not be used by any command that was recorded to a command buffer which is in the pending state.
VUID-vkUpdateDescriptorSets-device-parameter,Y,None,implicit,vkUpdateDescriptorSets,core, device must be a valid VkDevice handle
VUID-vkUpdateDescriptorSets-dstSet-00314,N,None,explicit,vkUpdateDescriptorSets,!(VK_EXT_descriptor_indexing), The dstSet member of each element of pDescriptorWrites or pDescriptorCopies must not be used by any command that was recorded to a command buffer which is in the pending state.
VUID-vkUpdateDescriptorSets-pDescriptorCopies-parameter,Y,None,implicit,vkUpdateDescriptorSets,core," If descriptorCopyCount is not 0, pDescriptorCopies must be a valid pointer to an array of descriptorCopyCount valid VkCopyDescriptorSet structures"
VUID-vkUpdateDescriptorSets-pDescriptorWrites-parameter,Y,None,implicit,vkUpdateDescriptorSets,core," If descriptorWriteCount is not 0, pDescriptorWrites must be a valid pointer to an array of descriptorWriteCount valid VkWriteDescriptorSet structures"
VUID-vkWaitForFences-device-parameter,Y,None,implicit,vkWaitForFences,core, device must be a valid VkDevice handle
VUID-vkWaitForFences-fenceCount-arraylength,N,None,implicit,vkWaitForFences,core, fenceCount must be greater than 0
VUID-vkWaitForFences-pFences-parameter,Y,None,implicit,vkWaitForFences,core, pFences must be a valid pointer to an array of fenceCount valid VkFence handles
VUID-vkWaitForFences-pFences-parent,Y,None,implicit,vkWaitForFences,core," Each element of pFences must have been created, allocated, or retrieved from device"
